{
  "version": 3,
  "sources": ["../node_modules/fast-unique-numbers/build/es5/bundle.js", "../node_modules/@babel/runtime/helpers/arrayWithHoles.js", "../node_modules/@babel/runtime/helpers/iterableToArrayLimit.js", "../node_modules/@babel/runtime/helpers/arrayLikeToArray.js", "../node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js", "../node_modules/@babel/runtime/helpers/nonIterableRest.js", "../node_modules/@babel/runtime/helpers/slicedToArray.js", "../node_modules/@babel/runtime/helpers/classCallCheck.js", "../node_modules/@babel/runtime/helpers/typeof.js", "../node_modules/@babel/runtime/helpers/toPrimitive.js", "../node_modules/@babel/runtime/helpers/toPropertyKey.js", "../node_modules/@babel/runtime/helpers/createClass.js", "../node_modules/automation-events/build/es5/bundle.js", "mods/events.ts", "mods/enumerate.ts", "mods/ws.ts", "../node_modules/web-audio-beat-detector-broker/src/module.ts", "../node_modules/standardized-audio-context/src/module.ts", "../node_modules/standardized-audio-context/src/factories/abort-error.ts", "../node_modules/standardized-audio-context/src/factories/add-active-input-connection-to-audio-node.ts", "../node_modules/standardized-audio-context/src/factories/add-audio-node-connections.ts", "../node_modules/standardized-audio-context/src/factories/add-audio-param-connections.ts", "../node_modules/standardized-audio-context/src/globals.ts", "../node_modules/standardized-audio-context/src/helpers/is-constructible.ts", "../node_modules/standardized-audio-context/src/helpers/split-import-statements.ts", "../node_modules/standardized-audio-context/src/factories/add-audio-worklet-module.ts", "../node_modules/standardized-audio-context/src/helpers/get-value-for-key.ts", "../node_modules/standardized-audio-context/src/helpers/pick-element-from-set.ts", "../node_modules/standardized-audio-context/src/helpers/delete-passive-input-connection-to-audio-node.ts", "../node_modules/standardized-audio-context/src/helpers/get-event-listeners-of-audio-node.ts", "../node_modules/standardized-audio-context/src/helpers/set-internal-state-to-active.ts", "../node_modules/standardized-audio-context/src/guards/audio-worklet-node.ts", "../node_modules/standardized-audio-context/src/helpers/set-internal-state-to-passive.ts", "../node_modules/standardized-audio-context/src/helpers/set-internal-state-to-passive-when-necessary.ts", "../node_modules/standardized-audio-context/src/factories/add-connection-to-audio-node.ts", "../node_modules/standardized-audio-context/src/factories/add-passive-input-connection-to-audio-node.ts", "../node_modules/standardized-audio-context/src/factories/add-silent-connection.ts", "../node_modules/standardized-audio-context/src/factories/add-unrendered-audio-worklet-node.ts", "../node_modules/standardized-audio-context/src/factories/analyser-node-constructor.ts", "../node_modules/standardized-audio-context/src/helpers/is-owned-by-context.ts", "../node_modules/standardized-audio-context/src/factories/analyser-node-renderer-factory.ts", "../node_modules/standardized-audio-context/src/helpers/test-audio-buffer-copy-channel-methods-out-of-bounds-support.ts", "../node_modules/standardized-audio-context/src/factories/index-size-error.ts", "../node_modules/standardized-audio-context/src/helpers/wrap-audio-buffer-get-channel-data-method.ts", "../node_modules/standardized-audio-context/src/factories/audio-buffer-constructor.ts", "../node_modules/standardized-audio-context/src/constants.ts", "../node_modules/standardized-audio-context/src/helpers/is-active-audio-node.ts", "../node_modules/standardized-audio-context/src/factories/audio-buffer-source-node-constructor.ts", "../node_modules/standardized-audio-context/src/factories/audio-buffer-source-node-renderer-factory.ts", "../node_modules/standardized-audio-context/src/guards/audio-buffer-source-node.ts", "../node_modules/standardized-audio-context/src/guards/biquad-filter-node.ts", "../node_modules/standardized-audio-context/src/guards/constant-source-node.ts", "../node_modules/standardized-audio-context/src/guards/gain-node.ts", "../node_modules/standardized-audio-context/src/guards/oscillator-node.ts", "../node_modules/standardized-audio-context/src/guards/stereo-panner-node.ts", "../node_modules/standardized-audio-context/src/helpers/get-audio-node-connections.ts", "../node_modules/standardized-audio-context/src/helpers/get-audio-param-connections.ts", "../node_modules/standardized-audio-context/src/helpers/deactivate-active-audio-node-input-connections.ts", "../node_modules/standardized-audio-context/src/helpers/deactivate-audio-graph.ts", "../node_modules/standardized-audio-context/src/helpers/is-valid-latency-hint.ts", "../node_modules/standardized-audio-context/src/factories/audio-context-constructor.ts", "../node_modules/standardized-audio-context/src/factories/audio-destination-node-constructor.ts", "../node_modules/standardized-audio-context/src/factories/audio-destination-node-renderer-factory.ts", "../node_modules/standardized-audio-context/src/factories/audio-listener-factory.ts", "../node_modules/standardized-audio-context/src/guards/audio-node.ts", "../node_modules/standardized-audio-context/src/guards/audio-node-output-connection.ts", "../node_modules/standardized-audio-context/src/helpers/insert-element-in-set.ts", "../node_modules/standardized-audio-context/src/helpers/add-active-input-connection-to-audio-param.ts", "../node_modules/standardized-audio-context/src/helpers/add-passive-input-connection-to-audio-param.ts", "../node_modules/standardized-audio-context/src/guards/native-audio-node-faker.ts", "../node_modules/standardized-audio-context/src/helpers/connect-native-audio-node-to-native-audio-node.ts", "../node_modules/standardized-audio-context/src/helpers/delete-active-input-connection.ts", "../node_modules/standardized-audio-context/src/helpers/delete-active-input-connection-to-audio-param.ts", "../node_modules/standardized-audio-context/src/helpers/delete-event-listeners-of-audio-node.ts", "../node_modules/standardized-audio-context/src/helpers/delete-passive-input-connection-to-audio-param.ts", "../node_modules/standardized-audio-context/src/helpers/disconnect-native-audio-node-from-native-audio-node.ts", "../node_modules/standardized-audio-context/src/helpers/get-native-audio-node.ts", "../node_modules/standardized-audio-context/src/helpers/get-native-audio-param.ts", "../node_modules/standardized-audio-context/src/helpers/is-part-of-a-cycle.ts", "../node_modules/standardized-audio-context/src/helpers/is-passive-audio-node.ts", "../node_modules/standardized-audio-context/src/helpers/test-audio-node-disconnect-method-support.ts", "../node_modules/standardized-audio-context/src/helpers/visit-each-audio-node-once.ts", "../node_modules/standardized-audio-context/src/guards/native-audio-node.ts", "../node_modules/standardized-audio-context/src/helpers/wrap-audio-node-disconnect-method.ts", "../node_modules/standardized-audio-context/src/factories/audio-node-constructor.ts", "../node_modules/standardized-audio-context/src/factories/audio-param-factory.ts", "../node_modules/standardized-audio-context/src/factories/audio-param-renderer.ts", "../node_modules/standardized-audio-context/src/read-only-map.ts", "../node_modules/standardized-audio-context/src/factories/audio-worklet-node-constructor.ts", "../node_modules/standardized-audio-context/src/helpers/copy-from-channel.ts", "../node_modules/standardized-audio-context/src/helpers/copy-to-channel.ts", "../node_modules/standardized-audio-context/src/helpers/create-nested-arrays.ts", "../node_modules/standardized-audio-context/src/helpers/get-audio-worklet-processor.ts", "../node_modules/standardized-audio-context/src/factories/audio-worklet-node-renderer-factory.ts", "../node_modules/standardized-audio-context/src/factories/base-audio-context-constructor.ts", "../node_modules/standardized-audio-context/src/factories/biquad-filter-node-constructor.ts", "../node_modules/standardized-audio-context/src/factories/biquad-filter-node-renderer-factory.ts", "../node_modules/standardized-audio-context/src/factories/cache-test-result.ts", "../node_modules/standardized-audio-context/src/factories/channel-merger-node-constructor.ts", "../node_modules/standardized-audio-context/src/factories/channel-merger-node-renderer-factory.ts", "../node_modules/standardized-audio-context/src/factories/channel-splitter-node-constructor.ts", "../node_modules/standardized-audio-context/src/factories/channel-splitter-node-renderer-factory.ts", "../node_modules/standardized-audio-context/src/factories/connect-audio-param.ts", "../node_modules/standardized-audio-context/src/factories/connect-multiple-outputs.ts", "../node_modules/standardized-audio-context/src/factories/connected-native-audio-buffer-source-node-factory.ts", "../node_modules/standardized-audio-context/src/factories/constant-source-node-constructor.ts", "../node_modules/standardized-audio-context/src/factories/constant-source-node-renderer-factory.ts", "../node_modules/standardized-audio-context/src/factories/convert-number-to-unsigned-long.ts", "../node_modules/standardized-audio-context/src/factories/convolver-node-constructor.ts", "../node_modules/standardized-audio-context/src/factories/convolver-node-renderer-factory.ts", "../node_modules/standardized-audio-context/src/factories/create-native-offline-audio-context.ts", "../node_modules/standardized-audio-context/src/factories/data-clone-error.ts", "../node_modules/standardized-audio-context/src/helpers/detach-array-buffer.ts", "../node_modules/standardized-audio-context/src/factories/decode-audio-data.ts", "../node_modules/standardized-audio-context/src/factories/decrement-cycle-counter.ts", "../node_modules/standardized-audio-context/src/factories/delay-node-constructor.ts", "../node_modules/standardized-audio-context/src/factories/delay-node-renderer-factory.ts", "../node_modules/standardized-audio-context/src/factories/delete-active-input-connection-to-audio-node.ts", "../node_modules/standardized-audio-context/src/factories/delete-unrendered-audio-worklet-node.ts", "../node_modules/standardized-audio-context/src/guards/delay-node.ts", "../node_modules/standardized-audio-context/src/factories/detect-cycles.ts", "../node_modules/standardized-audio-context/src/factories/disconnect-multiple-outputs.ts", "../node_modules/standardized-audio-context/src/factories/dynamics-compressor-node-constructor.ts", "../node_modules/standardized-audio-context/src/factories/dynamics-compressor-node-renderer-factory.ts", "../node_modules/standardized-audio-context/src/factories/encoding-error.ts", "../node_modules/standardized-audio-context/src/factories/evaluate-source.ts", "../node_modules/standardized-audio-context/src/factories/event-target-constructor.ts", "../node_modules/standardized-audio-context/src/factories/expose-current-frame-and-current-time.ts", "../node_modules/standardized-audio-context/src/factories/fetch-source.ts", "../node_modules/standardized-audio-context/src/factories/gain-node-constructor.ts", "../node_modules/standardized-audio-context/src/factories/gain-node-renderer-factory.ts", "../node_modules/standardized-audio-context/src/factories/get-active-audio-worklet-node-inputs.ts", "../node_modules/standardized-audio-context/src/factories/get-audio-node-renderer.ts", "../node_modules/standardized-audio-context/src/factories/get-audio-node-tail-time.ts", "../node_modules/standardized-audio-context/src/factories/get-audio-param-renderer.ts", "../node_modules/standardized-audio-context/src/factories/get-backup-offline-audio-context.ts", "../node_modules/standardized-audio-context/src/factories/invalid-state-error.ts", "../node_modules/standardized-audio-context/src/factories/get-native-context.ts", "../node_modules/standardized-audio-context/src/factories/get-or-create-backup-offline-audio-context.ts", "../node_modules/standardized-audio-context/src/factories/get-unrendered-audio-worklet-nodes.ts", "../node_modules/standardized-audio-context/src/factories/invalid-access-error.ts", "../node_modules/standardized-audio-context/src/helpers/wrap-iir-filter-node-get-frequency-response-method.ts", "../node_modules/standardized-audio-context/src/factories/iir-filter-node-constructor.ts", "../node_modules/standardized-audio-context/src/helpers/filter-buffer.ts", "../node_modules/standardized-audio-context/src/factories/iir-filter-node-renderer-factory.ts", "../node_modules/standardized-audio-context/src/factories/increment-cycle-counter-factory.ts", "../node_modules/standardized-audio-context/src/factories/is-any-audio-context.ts", "../node_modules/standardized-audio-context/src/factories/is-any-audio-node.ts", "../node_modules/standardized-audio-context/src/factories/is-any-audio-param.ts", "../node_modules/standardized-audio-context/src/factories/is-any-offline-audio-context.ts", "../node_modules/standardized-audio-context/src/factories/is-native-audio-context.ts", "../node_modules/standardized-audio-context/src/factories/is-native-audio-node.ts", "../node_modules/standardized-audio-context/src/factories/is-native-audio-param.ts", "../node_modules/standardized-audio-context/src/factories/is-native-context.ts", "../node_modules/standardized-audio-context/src/factories/is-native-offline-audio-context.ts", "../node_modules/standardized-audio-context/src/factories/is-secure-context.ts", "../node_modules/standardized-audio-context/src/factories/media-element-audio-source-node-constructor.ts", "../node_modules/standardized-audio-context/src/factories/media-stream-audio-destination-node-constructor.ts", "../node_modules/standardized-audio-context/src/factories/media-stream-audio-source-node-constructor.ts", "../node_modules/standardized-audio-context/src/factories/media-stream-track-audio-source-node-constructor.ts", "../node_modules/standardized-audio-context/src/factories/minimal-audio-context-constructor.ts", "../node_modules/standardized-audio-context/src/factories/minimal-base-audio-context-constructor.ts", "../node_modules/standardized-audio-context/src/helpers/test-promise-support.ts", "../node_modules/standardized-audio-context/src/factories/minimal-offline-audio-context-constructor.ts", "../node_modules/standardized-audio-context/src/factories/monitor-connections.ts", "../node_modules/standardized-audio-context/src/helpers/assign-native-audio-node-option.ts", "../node_modules/standardized-audio-context/src/helpers/assign-native-audio-node-options.ts", "../node_modules/standardized-audio-context/src/helpers/test-analyser-node-get-float-time-domain-data-method-support.ts", "../node_modules/standardized-audio-context/src/helpers/wrap-analyser-node-get-float-time-domain-data-method.ts", "../node_modules/standardized-audio-context/src/factories/native-analyser-node-factory.ts", "../node_modules/standardized-audio-context/src/factories/native-audio-buffer-constructor.ts", "../node_modules/standardized-audio-context/src/helpers/assign-native-audio-node-audio-param-value.ts", "../node_modules/standardized-audio-context/src/helpers/wrap-audio-buffer-source-node-start-method-consecutive-calls.ts", "../node_modules/standardized-audio-context/src/helpers/wrap-audio-scheduled-source-node-start-method-negative-parameters.ts", "../node_modules/standardized-audio-context/src/helpers/wrap-audio-scheduled-source-node-stop-method-negative-parameters.ts", "../node_modules/standardized-audio-context/src/factories/native-audio-buffer-source-node-factory.ts", "../node_modules/standardized-audio-context/src/factories/native-audio-context-constructor.ts", "../node_modules/standardized-audio-context/src/factories/native-audio-destination-node.ts", "../node_modules/standardized-audio-context/src/factories/native-audio-worklet-node-constructor.ts", "../node_modules/standardized-audio-context/src/helpers/test-clonability-of-audio-worklet-node-options.ts", "../node_modules/standardized-audio-context/src/factories/native-audio-worklet-node-factory.ts", "../node_modules/standardized-audio-context/src/helpers/compute-buffer-size.ts", "../node_modules/standardized-audio-context/src/helpers/clone-audio-worklet-node-options.ts", "../node_modules/standardized-audio-context/src/helpers/create-audio-worklet-processor-promise.ts", "../node_modules/standardized-audio-context/src/helpers/create-audio-worklet-processor.ts", "../node_modules/standardized-audio-context/src/factories/native-audio-worklet-node-faker-factory.ts", "../node_modules/standardized-audio-context/src/factories/native-biquad-filter-node.ts", "../node_modules/standardized-audio-context/src/factories/native-channel-merger-node-factory.ts", "../node_modules/standardized-audio-context/src/helpers/wrap-channel-splitter-node.ts", "../node_modules/standardized-audio-context/src/factories/native-channel-splitter-node.ts", "../node_modules/standardized-audio-context/src/factories/native-constant-source-node-factory.ts", "../node_modules/standardized-audio-context/src/helpers/intercept-connections.ts", "../node_modules/standardized-audio-context/src/factories/native-constant-source-node-faker-factory.ts", "../node_modules/standardized-audio-context/src/factories/native-convolver-node-factory.ts", "../node_modules/standardized-audio-context/src/factories/native-delay-node.ts", "../node_modules/standardized-audio-context/src/factories/native-dynamics-compressor-node-factory.ts", "../node_modules/standardized-audio-context/src/factories/native-gain-node.ts", "../node_modules/standardized-audio-context/src/factories/native-iir-filter-node-factory.ts", "../node_modules/standardized-audio-context/src/factories/native-iir-filter-node-faker-factory.ts", "../node_modules/standardized-audio-context/src/factories/native-media-element-audio-source-node.ts", "../node_modules/standardized-audio-context/src/factories/native-media-stream-audio-destination-node.ts", "../node_modules/standardized-audio-context/src/factories/native-media-stream-audio-source-node.ts", "../node_modules/standardized-audio-context/src/factories/native-media-stream-track-audio-source-node-factory.ts", "../node_modules/standardized-audio-context/src/factories/native-offline-audio-context-constructor.ts", "../node_modules/standardized-audio-context/src/factories/native-oscillator-node-factory.ts", "../node_modules/standardized-audio-context/src/factories/native-panner-node-factory.ts", "../node_modules/standardized-audio-context/src/factories/native-panner-node-faker-factory.ts", "../node_modules/standardized-audio-context/src/factories/native-periodic-wave-factory.ts", "../node_modules/standardized-audio-context/src/factories/native-script-processor-node.ts", "../node_modules/standardized-audio-context/src/factories/native-stereo-panner-node-factory.ts", "../node_modules/standardized-audio-context/src/factories/native-stereo-panner-node-faker-factory.ts", "../node_modules/standardized-audio-context/src/factories/native-wave-shaper-node-factory.ts", "../node_modules/standardized-audio-context/src/factories/native-wave-shaper-node-faker-factory.ts", "../node_modules/standardized-audio-context/src/factories/not-supported-error.ts", "../node_modules/standardized-audio-context/src/factories/offline-audio-context-constructor.ts", "../node_modules/standardized-audio-context/src/factories/oscillator-node-constructor.ts", "../node_modules/standardized-audio-context/src/factories/oscillator-node-renderer-factory.ts", "../node_modules/standardized-audio-context/src/factories/panner-node-constructor.ts", "../node_modules/standardized-audio-context/src/factories/panner-node-renderer-factory.ts", "../node_modules/standardized-audio-context/src/factories/periodic-wave-constructor.ts", "../node_modules/standardized-audio-context/src/factories/render-automation.ts", "../node_modules/standardized-audio-context/src/factories/render-inputs-of-audio-node.ts", "../node_modules/standardized-audio-context/src/factories/render-inputs-of-audio-param.ts", "../node_modules/standardized-audio-context/src/factories/render-native-offline-audio-context.ts", "../node_modules/standardized-audio-context/src/factories/set-active-audio-worklet-node-inputs.ts", "../node_modules/standardized-audio-context/src/factories/set-audio-node-tail-time.ts", "../node_modules/standardized-audio-context/src/factories/start-rendering.ts", "../node_modules/standardized-audio-context/src/factories/stereo-panner-node-constructor.ts", "../node_modules/standardized-audio-context/src/factories/stereo-panner-node-renderer-factory.ts", "../node_modules/standardized-audio-context/src/factories/test-audio-buffer-constructor-support.ts", "../node_modules/standardized-audio-context/src/factories/test-audio-worklet-processor-post-message-support.ts", "../node_modules/standardized-audio-context/src/factories/test-offline-audio-context-current-time-support.ts", "../node_modules/standardized-audio-context/src/factories/unknown-error.ts", "../node_modules/standardized-audio-context/src/factories/wave-shaper-node-constructor.ts", "../node_modules/standardized-audio-context/src/factories/wave-shaper-node-renderer-factory.ts", "../node_modules/standardized-audio-context/src/factories/window.ts", "../node_modules/standardized-audio-context/src/factories/wrap-audio-buffer-copy-channel-methods.ts", "../node_modules/standardized-audio-context/src/factories/wrap-audio-buffer-copy-channel-methods-out-of-bounds.ts", "../node_modules/standardized-audio-context/src/factories/wrap-audio-buffer-source-node-stop-method-nullified-buffer.ts", "../node_modules/standardized-audio-context/src/factories/wrap-channel-merger-node.ts", "../node_modules/standardized-audio-context/src/helpers/get-first-sample.ts", "../node_modules/standardized-audio-context/src/helpers/is-dc-curve.ts", "../node_modules/standardized-audio-context/src/helpers/overwrite-accessors.ts", "../node_modules/standardized-audio-context/src/helpers/sanitize-audio-worklet-node-options.ts", "../node_modules/standardized-audio-context/src/helpers/sanitize-channel-splitter-options.ts", "../node_modules/standardized-audio-context/src/helpers/sanitize-periodic-wave-options.ts", "../node_modules/standardized-audio-context/src/helpers/set-value-at-time-until-possible.ts", "../node_modules/standardized-audio-context/src/helpers/test-audio-buffer-source-node-start-method-consecutive-calls-support.ts", "../node_modules/standardized-audio-context/src/helpers/test-audio-buffer-source-node-start-method-offset-clamping-support.ts", "../node_modules/standardized-audio-context/src/helpers/test-audio-buffer-source-node-stop-method-nullified-buffer-support.ts", "../node_modules/standardized-audio-context/src/helpers/test-audio-scheduled-source-node-start-method-negative-parameters-support.ts", "../node_modules/standardized-audio-context/src/helpers/test-audio-scheduled-source-node-stop-method-consecutive-calls-support.ts", "../node_modules/standardized-audio-context/src/helpers/test-audio-scheduled-source-node-stop-method-negative-parameters-support.ts", "../node_modules/standardized-audio-context/src/helpers/test-audio-worklet-node-options-clonability.ts", "../node_modules/standardized-audio-context/src/helpers/wrap-audio-buffer-source-node-start-method-offset-clamping.ts", "../node_modules/standardized-audio-context/src/helpers/wrap-audio-scheduled-source-node-stop-method-consecutive-calls.ts", "../node_modules/standardized-audio-context/src/helpers/wrap-event-listener.ts", "../node_modules/web-audio-beat-detector-broker/src/helpers/render.ts", "../node_modules/web-audio-beat-detector/src/factories/load-or-return-broker.ts", "../node_modules/web-audio-beat-detector/src/worker/worker.ts", "../node_modules/web-audio-beat-detector/src/module.ts", "mods/clip.ts", "mods/index.ts"],
  "sourcesContent": ["(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n    typeof define === 'function' && define.amd ? define(['exports'], factory) :\n    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.fastUniqueNumbers = {}));\n})(this, (function (exports) { 'use strict';\n\n    var createAddUniqueNumber = function createAddUniqueNumber(generateUniqueNumber) {\n      return function (set) {\n        var number = generateUniqueNumber(set);\n        set.add(number);\n        return number;\n      };\n    };\n\n    var createCache = function createCache(lastNumberWeakMap) {\n      return function (collection, nextNumber) {\n        lastNumberWeakMap.set(collection, nextNumber);\n        return nextNumber;\n      };\n    };\n\n    /*\n     * The value of the constant Number.MAX_SAFE_INTEGER equals (2 ** 53 - 1) but it\n     * is fairly new.\n     */\n    var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER === undefined ? 9007199254740991 : Number.MAX_SAFE_INTEGER;\n    var TWO_TO_THE_POWER_OF_TWENTY_NINE = 536870912;\n    var TWO_TO_THE_POWER_OF_THIRTY = TWO_TO_THE_POWER_OF_TWENTY_NINE * 2;\n    var createGenerateUniqueNumber = function createGenerateUniqueNumber(cache, lastNumberWeakMap) {\n      return function (collection) {\n        var lastNumber = lastNumberWeakMap.get(collection);\n        /*\n         * Let's try the cheapest algorithm first. It might fail to produce a new\n         * number, but it is so cheap that it is okay to take the risk. Just\n         * increase the last number by one or reset it to 0 if we reached the upper\n         * bound of SMIs (which stands for small integers). When the last number is\n         * unknown it is assumed that the collection contains zero based consecutive\n         * numbers.\n         */\n        var nextNumber = lastNumber === undefined ? collection.size : lastNumber < TWO_TO_THE_POWER_OF_THIRTY ? lastNumber + 1 : 0;\n        if (!collection.has(nextNumber)) {\n          return cache(collection, nextNumber);\n        }\n        /*\n         * If there are less than half of 2 ** 30 numbers stored in the collection,\n         * the chance to generate a new random number in the range from 0 to 2 ** 30\n         * is at least 50%. It's benifitial to use only SMIs because they perform\n         * much better in any environment based on V8.\n         */\n        if (collection.size < TWO_TO_THE_POWER_OF_TWENTY_NINE) {\n          while (collection.has(nextNumber)) {\n            nextNumber = Math.floor(Math.random() * TWO_TO_THE_POWER_OF_THIRTY);\n          }\n          return cache(collection, nextNumber);\n        }\n        // Quickly check if there is a theoretical chance to generate a new number.\n        if (collection.size > MAX_SAFE_INTEGER) {\n          throw new Error('Congratulations, you created a collection of unique numbers which uses all available integers!');\n        }\n        // Otherwise use the full scale of safely usable integers.\n        while (collection.has(nextNumber)) {\n          nextNumber = Math.floor(Math.random() * MAX_SAFE_INTEGER);\n        }\n        return cache(collection, nextNumber);\n      };\n    };\n\n    var LAST_NUMBER_WEAK_MAP = new WeakMap();\n    var cache = createCache(LAST_NUMBER_WEAK_MAP);\n    var generateUniqueNumber = createGenerateUniqueNumber(cache, LAST_NUMBER_WEAK_MAP);\n    var addUniqueNumber = createAddUniqueNumber(generateUniqueNumber);\n\n    exports.addUniqueNumber = addUniqueNumber;\n    exports.generateUniqueNumber = generateUniqueNumber;\n\n}));\n", "function _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\nmodule.exports = _arrayWithHoles, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;", "function _iterableToArrayLimit(r, l) {\n  var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"];\n  if (null != t) {\n    var e,\n      n,\n      i,\n      u,\n      a = [],\n      f = !0,\n      o = !1;\n    try {\n      if (i = (t = t.call(r)).next, 0 === l) {\n        if (Object(t) !== t) return;\n        f = !1;\n      } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);\n    } catch (r) {\n      o = !0, n = r;\n    } finally {\n      try {\n        if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return;\n      } finally {\n        if (o) throw n;\n      }\n    }\n    return a;\n  }\n}\nmodule.exports = _iterableToArrayLimit, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;", "function _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n  return arr2;\n}\nmodule.exports = _arrayLikeToArray, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;", "var arrayLikeToArray = require(\"./arrayLikeToArray.js\");\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);\n}\nmodule.exports = _unsupportedIterableToArray, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;", "function _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nmodule.exports = _nonIterableRest, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;", "var arrayWithHoles = require(\"./arrayWithHoles.js\");\nvar iterableToArrayLimit = require(\"./iterableToArrayLimit.js\");\nvar unsupportedIterableToArray = require(\"./unsupportedIterableToArray.js\");\nvar nonIterableRest = require(\"./nonIterableRest.js\");\nfunction _slicedToArray(arr, i) {\n  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || unsupportedIterableToArray(arr, i) || nonIterableRest();\n}\nmodule.exports = _slicedToArray, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;", "function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nmodule.exports = _classCallCheck, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;", "function _typeof(o) {\n  \"@babel/helpers - typeof\";\n\n  return (module.exports = _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) {\n    return typeof o;\n  } : function (o) {\n    return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n  }, module.exports.__esModule = true, module.exports[\"default\"] = module.exports), _typeof(o);\n}\nmodule.exports = _typeof, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;", "var _typeof = require(\"./typeof.js\")[\"default\"];\nfunction toPrimitive(t, r) {\n  if (\"object\" != _typeof(t) || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != _typeof(i)) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\nmodule.exports = toPrimitive, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;", "var _typeof = require(\"./typeof.js\")[\"default\"];\nvar toPrimitive = require(\"./toPrimitive.js\");\nfunction toPropertyKey(t) {\n  var i = toPrimitive(t, \"string\");\n  return \"symbol\" == _typeof(i) ? i : String(i);\n}\nmodule.exports = toPropertyKey, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;", "var toPropertyKey = require(\"./toPropertyKey.js\");\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, toPropertyKey(descriptor.key), descriptor);\n  }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  Object.defineProperty(Constructor, \"prototype\", {\n    writable: false\n  });\n  return Constructor;\n}\nmodule.exports = _createClass, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;", "(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@babel/runtime/helpers/slicedToArray'), require('@babel/runtime/helpers/classCallCheck'), require('@babel/runtime/helpers/createClass')) :\n    typeof define === 'function' && define.amd ? define(['exports', '@babel/runtime/helpers/slicedToArray', '@babel/runtime/helpers/classCallCheck', '@babel/runtime/helpers/createClass'], factory) :\n    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.automationEvents = {}, global._slicedToArray, global._classCallCheck, global._createClass));\n})(this, (function (exports, _slicedToArray, _classCallCheck, _createClass) { 'use strict';\n\n    var createExtendedExponentialRampToValueAutomationEvent = function createExtendedExponentialRampToValueAutomationEvent(value, endTime, insertTime) {\n      return {\n        endTime: endTime,\n        insertTime: insertTime,\n        type: 'exponentialRampToValue',\n        value: value\n      };\n    };\n\n    var createExtendedLinearRampToValueAutomationEvent = function createExtendedLinearRampToValueAutomationEvent(value, endTime, insertTime) {\n      return {\n        endTime: endTime,\n        insertTime: insertTime,\n        type: 'linearRampToValue',\n        value: value\n      };\n    };\n\n    var createSetValueAutomationEvent = function createSetValueAutomationEvent(value, startTime) {\n      return {\n        startTime: startTime,\n        type: 'setValue',\n        value: value\n      };\n    };\n\n    var createSetValueCurveAutomationEvent = function createSetValueCurveAutomationEvent(values, startTime, duration) {\n      return {\n        duration: duration,\n        startTime: startTime,\n        type: 'setValueCurve',\n        values: values\n      };\n    };\n\n    var getTargetValueAtTime = function getTargetValueAtTime(time, valueAtStartTime, _ref) {\n      var startTime = _ref.startTime,\n        target = _ref.target,\n        timeConstant = _ref.timeConstant;\n      return target + (valueAtStartTime - target) * Math.exp((startTime - time) / timeConstant);\n    };\n\n    var isExponentialRampToValueAutomationEvent = function isExponentialRampToValueAutomationEvent(automationEvent) {\n      return automationEvent.type === 'exponentialRampToValue';\n    };\n\n    var isLinearRampToValueAutomationEvent = function isLinearRampToValueAutomationEvent(automationEvent) {\n      return automationEvent.type === 'linearRampToValue';\n    };\n\n    var isAnyRampToValueAutomationEvent = function isAnyRampToValueAutomationEvent(automationEvent) {\n      return isExponentialRampToValueAutomationEvent(automationEvent) || isLinearRampToValueAutomationEvent(automationEvent);\n    };\n\n    var isSetValueAutomationEvent = function isSetValueAutomationEvent(automationEvent) {\n      return automationEvent.type === 'setValue';\n    };\n\n    var isSetValueCurveAutomationEvent = function isSetValueCurveAutomationEvent(automationEvent) {\n      return automationEvent.type === 'setValueCurve';\n    };\n\n    var getValueOfAutomationEventAtIndexAtTime = function getValueOfAutomationEventAtIndexAtTime(automationEvents, index, time, defaultValue) {\n      var automationEvent = automationEvents[index];\n      return automationEvent === undefined ? defaultValue : isAnyRampToValueAutomationEvent(automationEvent) || isSetValueAutomationEvent(automationEvent) ? automationEvent.value : isSetValueCurveAutomationEvent(automationEvent) ? automationEvent.values[automationEvent.values.length - 1] : getTargetValueAtTime(time, getValueOfAutomationEventAtIndexAtTime(automationEvents, index - 1, automationEvent.startTime, defaultValue), automationEvent);\n    };\n\n    var getEndTimeAndValueOfPreviousAutomationEvent = function getEndTimeAndValueOfPreviousAutomationEvent(automationEvents, index, currentAutomationEvent, nextAutomationEvent, defaultValue) {\n      return currentAutomationEvent === undefined ? [nextAutomationEvent.insertTime, defaultValue] : isAnyRampToValueAutomationEvent(currentAutomationEvent) ? [currentAutomationEvent.endTime, currentAutomationEvent.value] : isSetValueAutomationEvent(currentAutomationEvent) ? [currentAutomationEvent.startTime, currentAutomationEvent.value] : isSetValueCurveAutomationEvent(currentAutomationEvent) ? [currentAutomationEvent.startTime + currentAutomationEvent.duration, currentAutomationEvent.values[currentAutomationEvent.values.length - 1]] : [currentAutomationEvent.startTime, getValueOfAutomationEventAtIndexAtTime(automationEvents, index - 1, currentAutomationEvent.startTime, defaultValue)];\n    };\n\n    var isCancelAndHoldAutomationEvent = function isCancelAndHoldAutomationEvent(automationEvent) {\n      return automationEvent.type === 'cancelAndHold';\n    };\n\n    var isCancelScheduledValuesAutomationEvent = function isCancelScheduledValuesAutomationEvent(automationEvent) {\n      return automationEvent.type === 'cancelScheduledValues';\n    };\n\n    var getEventTime = function getEventTime(automationEvent) {\n      if (isCancelAndHoldAutomationEvent(automationEvent) || isCancelScheduledValuesAutomationEvent(automationEvent)) {\n        return automationEvent.cancelTime;\n      }\n      if (isExponentialRampToValueAutomationEvent(automationEvent) || isLinearRampToValueAutomationEvent(automationEvent)) {\n        return automationEvent.endTime;\n      }\n      return automationEvent.startTime;\n    };\n\n    var getExponentialRampValueAtTime = function getExponentialRampValueAtTime(time, startTime, valueAtStartTime, _ref) {\n      var endTime = _ref.endTime,\n        value = _ref.value;\n      if (valueAtStartTime === value) {\n        return value;\n      }\n      if (0 < valueAtStartTime && 0 < value || valueAtStartTime < 0 && value < 0) {\n        return valueAtStartTime * Math.pow(value / valueAtStartTime, (time - startTime) / (endTime - startTime));\n      }\n      return 0;\n    };\n\n    var getLinearRampValueAtTime = function getLinearRampValueAtTime(time, startTime, valueAtStartTime, _ref) {\n      var endTime = _ref.endTime,\n        value = _ref.value;\n      return valueAtStartTime + (time - startTime) / (endTime - startTime) * (value - valueAtStartTime);\n    };\n\n    var interpolateValue = function interpolateValue(values, theoreticIndex) {\n      var lowerIndex = Math.floor(theoreticIndex);\n      var upperIndex = Math.ceil(theoreticIndex);\n      if (lowerIndex === upperIndex) {\n        return values[lowerIndex];\n      }\n      return (1 - (theoreticIndex - lowerIndex)) * values[lowerIndex] + (1 - (upperIndex - theoreticIndex)) * values[upperIndex];\n    };\n\n    var getValueCurveValueAtTime = function getValueCurveValueAtTime(time, _ref) {\n      var duration = _ref.duration,\n        startTime = _ref.startTime,\n        values = _ref.values;\n      var theoreticIndex = (time - startTime) / duration * (values.length - 1);\n      return interpolateValue(values, theoreticIndex);\n    };\n\n    var isSetTargetAutomationEvent = function isSetTargetAutomationEvent(automationEvent) {\n      return automationEvent.type === 'setTarget';\n    };\n\n    var AutomationEventList = /*#__PURE__*/function (_Symbol$iterator) {\n      function AutomationEventList(defaultValue) {\n        _classCallCheck(this, AutomationEventList);\n        this._automationEvents = [];\n        this._currenTime = 0;\n        this._defaultValue = defaultValue;\n      }\n      _createClass(AutomationEventList, [{\n        key: _Symbol$iterator,\n        value: function value() {\n          return this._automationEvents[Symbol.iterator]();\n        }\n      }, {\n        key: \"add\",\n        value: function add(automationEvent) {\n          var eventTime = getEventTime(automationEvent);\n          if (isCancelAndHoldAutomationEvent(automationEvent) || isCancelScheduledValuesAutomationEvent(automationEvent)) {\n            var index = this._automationEvents.findIndex(function (currentAutomationEvent) {\n              if (isCancelScheduledValuesAutomationEvent(automationEvent) && isSetValueCurveAutomationEvent(currentAutomationEvent)) {\n                return currentAutomationEvent.startTime + currentAutomationEvent.duration >= eventTime;\n              }\n              return getEventTime(currentAutomationEvent) >= eventTime;\n            });\n            var removedAutomationEvent = this._automationEvents[index];\n            if (index !== -1) {\n              this._automationEvents = this._automationEvents.slice(0, index);\n            }\n            if (isCancelAndHoldAutomationEvent(automationEvent)) {\n              var lastAutomationEvent = this._automationEvents[this._automationEvents.length - 1];\n              if (removedAutomationEvent !== undefined && isAnyRampToValueAutomationEvent(removedAutomationEvent)) {\n                if (lastAutomationEvent !== undefined && isSetTargetAutomationEvent(lastAutomationEvent)) {\n                  throw new Error('The internal list is malformed.');\n                }\n                var startTime = lastAutomationEvent === undefined ? removedAutomationEvent.insertTime : isSetValueCurveAutomationEvent(lastAutomationEvent) ? lastAutomationEvent.startTime + lastAutomationEvent.duration : getEventTime(lastAutomationEvent);\n                var startValue = lastAutomationEvent === undefined ? this._defaultValue : isSetValueCurveAutomationEvent(lastAutomationEvent) ? lastAutomationEvent.values[lastAutomationEvent.values.length - 1] : lastAutomationEvent.value;\n                var value = isExponentialRampToValueAutomationEvent(removedAutomationEvent) ? getExponentialRampValueAtTime(eventTime, startTime, startValue, removedAutomationEvent) : getLinearRampValueAtTime(eventTime, startTime, startValue, removedAutomationEvent);\n                var truncatedAutomationEvent = isExponentialRampToValueAutomationEvent(removedAutomationEvent) ? createExtendedExponentialRampToValueAutomationEvent(value, eventTime, this._currenTime) : createExtendedLinearRampToValueAutomationEvent(value, eventTime, this._currenTime);\n                this._automationEvents.push(truncatedAutomationEvent);\n              }\n              if (lastAutomationEvent !== undefined && isSetTargetAutomationEvent(lastAutomationEvent)) {\n                this._automationEvents.push(createSetValueAutomationEvent(this.getValue(eventTime), eventTime));\n              }\n              if (lastAutomationEvent !== undefined && isSetValueCurveAutomationEvent(lastAutomationEvent) && lastAutomationEvent.startTime + lastAutomationEvent.duration > eventTime) {\n                var duration = eventTime - lastAutomationEvent.startTime;\n                var ratio = (lastAutomationEvent.values.length - 1) / lastAutomationEvent.duration;\n                var length = Math.max(2, 1 + Math.ceil(duration * ratio));\n                var fraction = duration / (length - 1) * ratio;\n                var values = lastAutomationEvent.values.slice(0, length);\n                if (fraction < 1) {\n                  for (var i = 1; i < length; i += 1) {\n                    var factor = fraction * i % 1;\n                    values[i] = lastAutomationEvent.values[i - 1] * (1 - factor) + lastAutomationEvent.values[i] * factor;\n                  }\n                }\n                this._automationEvents[this._automationEvents.length - 1] = createSetValueCurveAutomationEvent(values, lastAutomationEvent.startTime, duration);\n              }\n            }\n          } else {\n            var _index = this._automationEvents.findIndex(function (currentAutomationEvent) {\n              return getEventTime(currentAutomationEvent) > eventTime;\n            });\n            var previousAutomationEvent = _index === -1 ? this._automationEvents[this._automationEvents.length - 1] : this._automationEvents[_index - 1];\n            if (previousAutomationEvent !== undefined && isSetValueCurveAutomationEvent(previousAutomationEvent) && getEventTime(previousAutomationEvent) + previousAutomationEvent.duration > eventTime) {\n              return false;\n            }\n            var persistentAutomationEvent = isExponentialRampToValueAutomationEvent(automationEvent) ? createExtendedExponentialRampToValueAutomationEvent(automationEvent.value, automationEvent.endTime, this._currenTime) : isLinearRampToValueAutomationEvent(automationEvent) ? createExtendedLinearRampToValueAutomationEvent(automationEvent.value, eventTime, this._currenTime) : automationEvent;\n            if (_index === -1) {\n              this._automationEvents.push(persistentAutomationEvent);\n            } else {\n              if (isSetValueCurveAutomationEvent(automationEvent) && eventTime + automationEvent.duration > getEventTime(this._automationEvents[_index])) {\n                return false;\n              }\n              this._automationEvents.splice(_index, 0, persistentAutomationEvent);\n            }\n          }\n          return true;\n        }\n      }, {\n        key: \"flush\",\n        value: function flush(time) {\n          var index = this._automationEvents.findIndex(function (currentAutomationEvent) {\n            return getEventTime(currentAutomationEvent) > time;\n          });\n          if (index > 1) {\n            var remainingAutomationEvents = this._automationEvents.slice(index - 1);\n            var firstRemainingAutomationEvent = remainingAutomationEvents[0];\n            if (isSetTargetAutomationEvent(firstRemainingAutomationEvent)) {\n              remainingAutomationEvents.unshift(createSetValueAutomationEvent(getValueOfAutomationEventAtIndexAtTime(this._automationEvents, index - 2, firstRemainingAutomationEvent.startTime, this._defaultValue), firstRemainingAutomationEvent.startTime));\n            }\n            this._automationEvents = remainingAutomationEvents;\n          }\n        }\n      }, {\n        key: \"getValue\",\n        value: function getValue(time) {\n          if (this._automationEvents.length === 0) {\n            return this._defaultValue;\n          }\n          var indexOfNextEvent = this._automationEvents.findIndex(function (automationEvent) {\n            return getEventTime(automationEvent) > time;\n          });\n          var nextAutomationEvent = this._automationEvents[indexOfNextEvent];\n          var indexOfCurrentEvent = (indexOfNextEvent === -1 ? this._automationEvents.length : indexOfNextEvent) - 1;\n          var currentAutomationEvent = this._automationEvents[indexOfCurrentEvent];\n          if (currentAutomationEvent !== undefined && isSetTargetAutomationEvent(currentAutomationEvent) && (nextAutomationEvent === undefined || !isAnyRampToValueAutomationEvent(nextAutomationEvent) || nextAutomationEvent.insertTime > time)) {\n            return getTargetValueAtTime(time, getValueOfAutomationEventAtIndexAtTime(this._automationEvents, indexOfCurrentEvent - 1, currentAutomationEvent.startTime, this._defaultValue), currentAutomationEvent);\n          }\n          if (currentAutomationEvent !== undefined && isSetValueAutomationEvent(currentAutomationEvent) && (nextAutomationEvent === undefined || !isAnyRampToValueAutomationEvent(nextAutomationEvent))) {\n            return currentAutomationEvent.value;\n          }\n          if (currentAutomationEvent !== undefined && isSetValueCurveAutomationEvent(currentAutomationEvent) && (nextAutomationEvent === undefined || !isAnyRampToValueAutomationEvent(nextAutomationEvent) || currentAutomationEvent.startTime + currentAutomationEvent.duration > time)) {\n            if (time < currentAutomationEvent.startTime + currentAutomationEvent.duration) {\n              return getValueCurveValueAtTime(time, currentAutomationEvent);\n            }\n            return currentAutomationEvent.values[currentAutomationEvent.values.length - 1];\n          }\n          if (currentAutomationEvent !== undefined && isAnyRampToValueAutomationEvent(currentAutomationEvent) && (nextAutomationEvent === undefined || !isAnyRampToValueAutomationEvent(nextAutomationEvent))) {\n            return currentAutomationEvent.value;\n          }\n          if (nextAutomationEvent !== undefined && isExponentialRampToValueAutomationEvent(nextAutomationEvent)) {\n            var _getEndTimeAndValueOf = getEndTimeAndValueOfPreviousAutomationEvent(this._automationEvents, indexOfCurrentEvent, currentAutomationEvent, nextAutomationEvent, this._defaultValue),\n              _getEndTimeAndValueOf2 = _slicedToArray(_getEndTimeAndValueOf, 2),\n              startTime = _getEndTimeAndValueOf2[0],\n              value = _getEndTimeAndValueOf2[1];\n            return getExponentialRampValueAtTime(time, startTime, value, nextAutomationEvent);\n          }\n          if (nextAutomationEvent !== undefined && isLinearRampToValueAutomationEvent(nextAutomationEvent)) {\n            var _getEndTimeAndValueOf3 = getEndTimeAndValueOfPreviousAutomationEvent(this._automationEvents, indexOfCurrentEvent, currentAutomationEvent, nextAutomationEvent, this._defaultValue),\n              _getEndTimeAndValueOf4 = _slicedToArray(_getEndTimeAndValueOf3, 2),\n              _startTime = _getEndTimeAndValueOf4[0],\n              _value = _getEndTimeAndValueOf4[1];\n            return getLinearRampValueAtTime(time, _startTime, _value, nextAutomationEvent);\n          }\n          return this._defaultValue;\n        }\n      }]);\n      return AutomationEventList;\n    }(Symbol.iterator);\n\n    var createCancelAndHoldAutomationEvent = function createCancelAndHoldAutomationEvent(cancelTime) {\n      return {\n        cancelTime: cancelTime,\n        type: 'cancelAndHold'\n      };\n    };\n\n    var createCancelScheduledValuesAutomationEvent = function createCancelScheduledValuesAutomationEvent(cancelTime) {\n      return {\n        cancelTime: cancelTime,\n        type: 'cancelScheduledValues'\n      };\n    };\n\n    var createExponentialRampToValueAutomationEvent = function createExponentialRampToValueAutomationEvent(value, endTime) {\n      return {\n        endTime: endTime,\n        type: 'exponentialRampToValue',\n        value: value\n      };\n    };\n\n    var createLinearRampToValueAutomationEvent = function createLinearRampToValueAutomationEvent(value, endTime) {\n      return {\n        endTime: endTime,\n        type: 'linearRampToValue',\n        value: value\n      };\n    };\n\n    var createSetTargetAutomationEvent = function createSetTargetAutomationEvent(target, startTime, timeConstant) {\n      return {\n        startTime: startTime,\n        target: target,\n        timeConstant: timeConstant,\n        type: 'setTarget'\n      };\n    };\n\n    exports.AutomationEventList = AutomationEventList;\n    exports.createCancelAndHoldAutomationEvent = createCancelAndHoldAutomationEvent;\n    exports.createCancelScheduledValuesAutomationEvent = createCancelScheduledValuesAutomationEvent;\n    exports.createExponentialRampToValueAutomationEvent = createExponentialRampToValueAutomationEvent;\n    exports.createLinearRampToValueAutomationEvent = createLinearRampToValueAutomationEvent;\n    exports.createSetTargetAutomationEvent = createSetTargetAutomationEvent;\n    exports.createSetValueAutomationEvent = createSetValueAutomationEvent;\n    exports.createSetValueCurveAutomationEvent = createSetValueCurveAutomationEvent;\n\n}));\n", "(EventTarget.prototype as any)._nativeEventListener = (EventTarget.prototype as any)._nativeEventListener || EventTarget.prototype.addEventListener;\n\nfor (let Obj of [ Window, Document, HTMLIFrameElement ]) {\n    Obj.prototype.addEventListener = new Proxy(Obj.prototype.addEventListener, {\n        apply: (target, thisArg, args: [type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions | undefined]) => {\n            if (args[1] && args[1] instanceof Function) {\n                args[1] = new Proxy(args[1], {\n                    apply: (target, thisArg, args2: [evt: Event]) => {\n                        try {\n                            if (document.querySelector(\"#modMenu\")?.contains(args2[0].target as Node)) {\n                                return false;\n                            }\n                        } catch {};\n                        \n                        return target.apply(thisArg, args2);\n                    }\n                });\n            }\n\n            return target.apply(thisArg, args);\n        }\n    });\n}", "export default function enumerate(list: any[]) {\n    return list.map((value, index) => [index, value]);\n}", "import enumerate from './enumerate.js';\n\ndeclare const window: Global & typeof globalThis;\n\nexport default function ws(menu: ModMenu) {\n    const keys: {\n        [key: string]: boolean;\n    } = {};\n    const WS_ENDPOINT = \"wss://73a59210-8993-4b29-8c5b-b0d9f2edf0f5-00-33hnin010jlp8.janeway.replit.dev\";\n    const WS = new WebSocket(WS_ENDPOINT);\n    const CONNECT_BUTTON = document.getElementById('connect-button') as HTMLButtonElement;\n    const AVAILABLE_PLAYERS = document.getElementById('available-players') as HTMLDivElement;\n\n    window._mod_WS = WS;\n\n    WS.onopen = () => {\n        console.log(\"Connected to server\");\n    }\n\n    WS.onmessage = (event) => {\n        if (event.data.startsWith('connect-req:')) {\n            const id = event.data.split(':')[1];\n            if (confirm(`Player ${id} wants to connect to you. Accept?`)) {\n                sendRequest(`connect-accept:${id}`);\n                menu.connecting = true;\n                window.opponent = id;\n            } else {\n                sendRequest(`connect-reject:${id}`);\n            }\n        }\n        if (event.data.startsWith('connect-accepted')) {\n            const id = event.data.split(':')[1];\n            window.opponent = id;\n\n            window.basketLoading.then(() => setInterval(() => {\n                if (menu.multiplayer === true) {\n                    sendRequest(`data-json:${JSON.stringify({\n                        type: \"event\",\n                        event: \"update\",\n                        target: menu.opponent,\n                        players: window.players.map((player) => ({ x: player.x, y: player.y, instVars: player.instVars })),\n                        heads: window.heads.map((head) => ({ x: head.x, y: head.y, instVars: head.instVars })),\n                        ball: { x: window.ball.x, y: window.ball.y, instVars: {hold: window.ball.instVars.hold, who: window.ball.instVars.who} },\n                    })}`);\n                }\n            }, 10));\n        }\n        if (event.data.startsWith('ids-available')) {\n            const ids = event.data.split(':')[1].split(',').filter((e: string) => !!e);\n            if (ids.find((id: string) => id === menu.multiplayerId)) {\n                ids.splice(ids.indexOf(menu.multiplayerId), 1);\n            }\n            if (ids.length >= 1) {\n                if (JSON.stringify(ids) === JSON.stringify([\n                    ...Array.from(document.querySelectorAll('.player + span')).map((player: Element) => player.textContent),\n                ])) {\n                    return;\n                }\n\n                CONNECT_BUTTON.disabled = false;\n\n                AVAILABLE_PLAYERS.innerHTML = '';\n\n                for (let id of ids) {\n                    if (id !== menu.multiplayerId) {\n                        const player = document.createElement('input');\n                        player.type = \"radio\";\n                        player.name = \"player\";\n                        player.className = 'player';\n                        player.value = id;\n\n                        AVAILABLE_PLAYERS.appendChild(player);\n                        AVAILABLE_PLAYERS.innerHTML += `<span>${id}</span><br />`;\n                    }\n                }\n            }\n        }\n\n        if (event.data.startsWith('data-json:')) {\n            const data = JSON.parse(event.data.split('data-json:')[1]);\n            runJsonData(data);\n        }\n    }\n\n    WS.onclose = () => {\n        console.log(\"Disconnected from server\");\n    }\n\n    function sendRequest(request: any) {\n        WS.send(request);\n    }\n\n    function runJsonData(data: any = {}) {   \n        if (data.target !== menu.multiplayerId) {\n            return false;\n        }\n\n        if (data.type === \"event\") {\n            if (data.event === \"keydown\") {\n                for (let [index, player] of enumerate(data.players)) {\n                    const playerInstance = window.players.find((_p, i) => index === i);\n                    if (!playerInstance) {\n                        continue;\n                    }\n                    playerInstance.x = player.x;\n                    playerInstance.y = player.y;\n                    for (let [key, value] of Object.entries(player.instVars)) {\n                        playerInstance.instVars[key] = value;\n                    }\n                }\n\n                for (let [index, head] of enumerate(data.heads)) {\n                    const headInstance = window.heads.find((_p, i) => index === i);\n                    if (!headInstance) {\n                        continue;\n                    }\n                    headInstance.x = head.x;\n                    headInstance.y = head.y;\n                    for (let [key, value] of Object.entries(head.instVars)) {\n                        headInstance.instVars[key] = value;\n                    }\n                }\n\n                const ballInstance = window.ball;\n                ballInstance.x = data.ball.x;\n                ballInstance.y = data.ball.y;\n                for (let [key, value] of Object.entries(data.ball.instVars)) {\n                    ballInstance.instVars[key] = value;\n                }\n\n                const event = new KeyboardEvent('keydown', {\n                    key: data.key,\n                    which: data.which,\n                    keyCode: data.keyCode,\n                    code: data.code,\n                });\n\n                window.dispatchEvent(event);\n            } else if (data.event === \"keyup\") {\n                const event = new KeyboardEvent('keyup', {\n                    key: data.key,\n                    which: data.which,\n                    keyCode: data.keyCode,\n                    code: data.code,\n                });\n\n                window.dispatchEvent(event);\n            } else if (data.event === \"update\") {\n                if (keys['w'] || keys['W'] || keys['ArrowUp']) {\n                    return false;\n                }\n                for (let [index, player] of enumerate(data.players)) {\n                    const playerInstance = window.players.find((_p, i) => index === i);\n                    if (!playerInstance) {\n                        continue;\n                    }\n                    playerInstance.x = player.x;\n                    playerInstance.y = player.y;\n                    for (let [key, value] of Object.entries(player.instVars)) {\n                        playerInstance.instVars[key] = value;\n                    }\n                }\n\n                for (let [index, head] of enumerate(data.heads)) {\n                    const headInstance = window.heads.find((_p, i) => index === i);\n                    if (!headInstance) {\n                        continue;\n                    }\n                    headInstance.x = head.x;\n                    headInstance.y = head.y;\n                    for (let [key, value] of Object.entries(head.instVars)) {\n                        headInstance.instVars[key] = value;\n                    }\n                }\n\n                const ballInstance = window.ball;\n                ballInstance.x = data.ball.x;\n                ballInstance.y = data.ball.y;\n                for (let [key, value] of Object.entries(data.ball.instVars)) {\n                    ballInstance.instVars[key] = value;\n                }\n            }\n        }\n    }   \n\n    window._nativeEventListener('keydown', (event: Event) => {\n        if (!event.isTrusted) {\n            return false;\n        }\n        if (menu.multiplayer === true) {\n            if ((event as KeyboardEvent).key === \"w\") {\n                sendRequest(`data-json:${JSON.stringify({\n                    type: \"event\",\n                    event: \"keydown\",\n                    key: \"w\",\n                    which: 87,\n                    keyCode: 87,\n                    code: \"KeyW\",\n                    target: menu.opponent,\n                    players: window.players.map((player) => ({ x: player.x, y: player.y, instVars: player.instVars })),\n                    heads: window.heads.map((head) => ({ x: head.x, y: head.y, instVars: head.instVars })),\n                    ball: { x: window.ball.x, y: window.ball.y, instVars: window.ball.instVars },\n                })}`);\n            } else if ((event as KeyboardEvent).key === \"ArrowUp\") {\n                sendRequest(`data-json:${JSON.stringify({\n                    type: \"event\",\n                    event: \"keydown\",\n                    key: \"ArrowUp\",\n                    which: 38,\n                    keyCode: 38,\n                    code: \"ArrowUp\",\n                    target: menu.opponent,\n                    players: window.players.map((player) => ({ x: player.x, y: player.y, instVars: player.instVars })),\n                    heads: window.heads.map((head) => ({ x: head.x, y: head.y, instVars: head.instVars })),\n                    ball: { x: window.ball.x, y: window.ball.y, instVars: window.ball.instVars },\n                })}`);\n            }\n        }\n    });\n    \n    window._nativeEventListener('keyup', (event) => {\n        if (!event.isTrusted) {\n            return false;\n        }\n        if (menu.multiplayer === true) {\n            if ((event as KeyboardEvent).key === \"w\") {\n                sendRequest(`data-json:${JSON.stringify({\n                    type: \"event\",\n                    event: \"keyup\",\n                    key: \"w\",\n                    which: 87,\n                    keyCode: 87,\n                    code: \"KeyW\",\n                    target: menu.opponent,\n                })}`);\n            } else if ((event as KeyboardEvent).key === \"ArrowUp\") {\n                sendRequest(`data-json:${JSON.stringify({\n                    type: \"event\",\n                    event: \"keyup\",\n                    key: \"ArrowUp\",\n                    which: 38,\n                    keyCode: 38,\n                    code: \"ArrowUp\",\n                    target: menu.opponent,\n                })}`);\n            }\n        }\n    });\n}", "import { addUniqueNumber } from 'fast-unique-numbers';\nimport { isSupported } from 'standardized-audio-context';\nimport { IAnalyzeRequest, IAnalyzeResponse, IGuessRequest, IGuessResponse, IWorkerEvent } from 'web-audio-beat-detector-worker';\nimport { render } from './helpers/render';\nimport { TArgs } from './types';\n\n/*\n * @todo Explicitly referencing the barrel file seems to be necessary when enabling the\n * isolatedModules compiler option.\n */\nexport * from './types/index';\n\nexport { isSupported };\n\nexport const load = (url: string) => {\n    const worker = new Worker(url);\n\n    const ongoingRecordingRequests: Set<number> = new Set();\n\n    const analyze = (...args: TArgs): Promise<number> => {\n        const [audioBuffer, offsetOrTempoSettings, durationOrTempoSettings] = args;\n        const offset = typeof offsetOrTempoSettings === 'number' ? offsetOrTempoSettings : 0;\n        const duration = typeof durationOrTempoSettings === 'number' ? durationOrTempoSettings : audioBuffer.duration - offset;\n        const tempoSettings =\n            typeof offsetOrTempoSettings === 'object'\n                ? offsetOrTempoSettings\n                : typeof durationOrTempoSettings === 'object'\n                  ? durationOrTempoSettings\n                  : args[3] ?? null;\n\n        return new Promise(async (resolve, reject) => {\n            const { channelData, sampleRate } = await render(audioBuffer, offset, duration);\n\n            const id = addUniqueNumber(ongoingRecordingRequests);\n\n            const onMessage = ({ data }: IWorkerEvent) => {\n                if (data.id === id) {\n                    ongoingRecordingRequests.delete(id);\n\n                    worker.removeEventListener('message', onMessage);\n\n                    if (data.error === null) {\n                        resolve((<IAnalyzeResponse>data).result.tempo);\n                    } else {\n                        reject(new Error(data.error.message));\n                    }\n                }\n            };\n\n            worker.addEventListener('message', onMessage);\n\n            worker.postMessage(\n                <IAnalyzeRequest>{\n                    id,\n                    method: 'analyze',\n                    params: { channelData, sampleRate, ...(tempoSettings === null ? tempoSettings : { tempoSettings }) }\n                },\n                [<ArrayBuffer>channelData.buffer]\n            );\n        });\n    };\n\n    const guess = (...args: TArgs): Promise<{ bpm: number; offset: number }> => {\n        const [audioBuffer, offsetOrTempoSettings, durationOrTempoSettings] = args;\n        const offset = typeof offsetOrTempoSettings === 'number' ? offsetOrTempoSettings : 0;\n        const duration = typeof durationOrTempoSettings === 'number' ? durationOrTempoSettings : audioBuffer.duration - offset;\n        const tempoSettings =\n            typeof offsetOrTempoSettings === 'object'\n                ? offsetOrTempoSettings\n                : typeof durationOrTempoSettings === 'object'\n                  ? durationOrTempoSettings\n                  : args[3] ?? null;\n\n        return new Promise(async (resolve, reject) => {\n            const { channelData, sampleRate } = await render(audioBuffer, offset, duration);\n\n            const id = addUniqueNumber(ongoingRecordingRequests);\n\n            const onMessage = ({ data }: IWorkerEvent) => {\n                if (data.id === id) {\n                    ongoingRecordingRequests.delete(id);\n\n                    worker.removeEventListener('message', onMessage);\n\n                    if (data.error === null) {\n                        resolve((<IGuessResponse>data).result);\n                    } else {\n                        reject(new Error(data.error.message));\n                    }\n                }\n            };\n\n            worker.addEventListener('message', onMessage);\n\n            worker.postMessage(\n                <IGuessRequest>{\n                    id,\n                    method: 'guess',\n                    params: { channelData, sampleRate, ...(tempoSettings === null ? tempoSettings : { tempoSettings }) }\n                },\n                [<ArrayBuffer>channelData.buffer]\n            );\n        });\n    };\n\n    return {\n        analyze,\n        guess\n    };\n};\n", "import {\n    createCancelAndHoldAutomationEvent,\n    createCancelScheduledValuesAutomationEvent,\n    createExponentialRampToValueAutomationEvent,\n    createLinearRampToValueAutomationEvent,\n    createSetTargetAutomationEvent,\n    createSetValueAutomationEvent,\n    createSetValueCurveAutomationEvent\n} from 'automation-events';\nimport { createAbortError } from './factories/abort-error';\nimport { createAddActiveInputConnectionToAudioNode } from './factories/add-active-input-connection-to-audio-node';\nimport { createAddAudioNodeConnections } from './factories/add-audio-node-connections';\nimport { createAddAudioParamConnections } from './factories/add-audio-param-connections';\nimport { createAddAudioWorkletModule } from './factories/add-audio-worklet-module';\nimport { createAddConnectionToAudioNode } from './factories/add-connection-to-audio-node';\nimport { createAddPassiveInputConnectionToAudioNode } from './factories/add-passive-input-connection-to-audio-node';\nimport { createAddSilentConnection } from './factories/add-silent-connection';\nimport { createAddUnrenderedAudioWorkletNode } from './factories/add-unrendered-audio-worklet-node';\nimport { createAnalyserNodeConstructor } from './factories/analyser-node-constructor';\nimport { createAnalyserNodeRendererFactory } from './factories/analyser-node-renderer-factory';\nimport { createAudioBufferConstructor } from './factories/audio-buffer-constructor';\nimport { createAudioBufferSourceNodeConstructor } from './factories/audio-buffer-source-node-constructor';\nimport { createAudioBufferSourceNodeRendererFactory } from './factories/audio-buffer-source-node-renderer-factory';\nimport { createAudioContextConstructor } from './factories/audio-context-constructor';\nimport { createAudioDestinationNodeConstructor } from './factories/audio-destination-node-constructor';\nimport { createAudioDestinationNodeRenderer } from './factories/audio-destination-node-renderer-factory';\nimport { createAudioListenerFactory } from './factories/audio-listener-factory';\nimport { createAudioNodeConstructor } from './factories/audio-node-constructor';\nimport { createAudioParamFactory } from './factories/audio-param-factory';\nimport { createAudioParamRenderer } from './factories/audio-param-renderer';\nimport { createAudioWorkletNodeConstructor } from './factories/audio-worklet-node-constructor';\nimport { createAudioWorkletNodeRendererFactory } from './factories/audio-worklet-node-renderer-factory';\nimport { createBaseAudioContextConstructor } from './factories/base-audio-context-constructor';\nimport { createBiquadFilterNodeConstructor } from './factories/biquad-filter-node-constructor';\nimport { createBiquadFilterNodeRendererFactory } from './factories/biquad-filter-node-renderer-factory';\nimport { createCacheTestResult } from './factories/cache-test-result';\nimport { createChannelMergerNodeConstructor } from './factories/channel-merger-node-constructor';\nimport { createChannelMergerNodeRendererFactory } from './factories/channel-merger-node-renderer-factory';\nimport { createChannelSplitterNodeConstructor } from './factories/channel-splitter-node-constructor';\nimport { createChannelSplitterNodeRendererFactory } from './factories/channel-splitter-node-renderer-factory';\nimport { createConnectAudioParam } from './factories/connect-audio-param';\nimport { createConnectMultipleOutputs } from './factories/connect-multiple-outputs';\nimport { createConnectedNativeAudioBufferSourceNodeFactory } from './factories/connected-native-audio-buffer-source-node-factory';\nimport { createConstantSourceNodeConstructor } from './factories/constant-source-node-constructor';\nimport { createConstantSourceNodeRendererFactory } from './factories/constant-source-node-renderer-factory';\nimport { createConvertNumberToUnsignedLong } from './factories/convert-number-to-unsigned-long';\nimport { createConvolverNodeConstructor } from './factories/convolver-node-constructor';\nimport { createConvolverNodeRendererFactory } from './factories/convolver-node-renderer-factory';\nimport { createCreateNativeOfflineAudioContext } from './factories/create-native-offline-audio-context';\nimport { createDataCloneError } from './factories/data-clone-error';\nimport { createDecodeAudioData } from './factories/decode-audio-data';\nimport { createDecrementCycleCounter } from './factories/decrement-cycle-counter';\nimport { createDelayNodeConstructor } from './factories/delay-node-constructor';\nimport { createDelayNodeRendererFactory } from './factories/delay-node-renderer-factory';\nimport { createDeleteActiveInputConnectionToAudioNode } from './factories/delete-active-input-connection-to-audio-node';\nimport { createDeleteUnrenderedAudioWorkletNode } from './factories/delete-unrendered-audio-worklet-node';\nimport { createDetectCycles } from './factories/detect-cycles';\nimport { createDisconnectMultipleOutputs } from './factories/disconnect-multiple-outputs';\nimport { createDynamicsCompressorNodeConstructor } from './factories/dynamics-compressor-node-constructor';\nimport { createDynamicsCompressorNodeRendererFactory } from './factories/dynamics-compressor-node-renderer-factory';\nimport { createEncodingError } from './factories/encoding-error';\nimport { createEvaluateSource } from './factories/evaluate-source';\nimport { createEventTargetConstructor } from './factories/event-target-constructor';\nimport { createExposeCurrentFrameAndCurrentTime } from './factories/expose-current-frame-and-current-time';\nimport { createFetchSource } from './factories/fetch-source';\nimport { createGainNodeConstructor } from './factories/gain-node-constructor';\nimport { createGainNodeRendererFactory } from './factories/gain-node-renderer-factory';\nimport { createGetActiveAudioWorkletNodeInputs } from './factories/get-active-audio-worklet-node-inputs';\nimport { createGetAudioNodeRenderer } from './factories/get-audio-node-renderer';\nimport { createGetAudioNodeTailTime } from './factories/get-audio-node-tail-time';\nimport { createGetAudioParamRenderer } from './factories/get-audio-param-renderer';\nimport { createGetBackupOfflineAudioContext } from './factories/get-backup-offline-audio-context';\nimport { createGetNativeContext } from './factories/get-native-context';\nimport { createGetOrCreateBackupOfflineAudioContext } from './factories/get-or-create-backup-offline-audio-context';\nimport { createGetUnrenderedAudioWorkletNodes } from './factories/get-unrendered-audio-worklet-nodes';\nimport { createIIRFilterNodeConstructor } from './factories/iir-filter-node-constructor';\nimport { createIIRFilterNodeRendererFactory } from './factories/iir-filter-node-renderer-factory';\nimport { createIncrementCycleCounterFactory } from './factories/increment-cycle-counter-factory';\nimport { createIndexSizeError } from './factories/index-size-error';\nimport { createInvalidAccessError } from './factories/invalid-access-error';\nimport { createInvalidStateError } from './factories/invalid-state-error';\nimport { createIsAnyAudioContext } from './factories/is-any-audio-context';\nimport { createIsAnyAudioNode } from './factories/is-any-audio-node';\nimport { createIsAnyAudioParam } from './factories/is-any-audio-param';\nimport { createIsAnyOfflineAudioContext } from './factories/is-any-offline-audio-context';\nimport { createIsNativeAudioContext } from './factories/is-native-audio-context';\nimport { createIsNativeAudioNode } from './factories/is-native-audio-node';\nimport { createIsNativeAudioParam } from './factories/is-native-audio-param';\nimport { createIsNativeContext } from './factories/is-native-context';\nimport { createIsNativeOfflineAudioContext } from './factories/is-native-offline-audio-context';\nimport { createIsSecureContext } from './factories/is-secure-context';\nimport { createIsSupportedPromise } from './factories/is-supported-promise';\nimport { createMediaElementAudioSourceNodeConstructor } from './factories/media-element-audio-source-node-constructor';\nimport { createMediaStreamAudioDestinationNodeConstructor } from './factories/media-stream-audio-destination-node-constructor';\nimport { createMediaStreamAudioSourceNodeConstructor } from './factories/media-stream-audio-source-node-constructor';\nimport { createMediaStreamTrackAudioSourceNodeConstructor } from './factories/media-stream-track-audio-source-node-constructor';\nimport { createMinimalAudioContextConstructor } from './factories/minimal-audio-context-constructor';\nimport { createMinimalBaseAudioContextConstructor } from './factories/minimal-base-audio-context-constructor';\nimport { createMinimalOfflineAudioContextConstructor } from './factories/minimal-offline-audio-context-constructor';\nimport { createMonitorConnections } from './factories/monitor-connections';\nimport { createNativeAnalyserNodeFactory } from './factories/native-analyser-node-factory';\nimport { createNativeAudioBufferConstructor } from './factories/native-audio-buffer-constructor';\nimport { createNativeAudioBufferSourceNodeFactory } from './factories/native-audio-buffer-source-node-factory';\nimport { createNativeAudioContextConstructor } from './factories/native-audio-context-constructor';\nimport { createNativeAudioDestinationNodeFactory } from './factories/native-audio-destination-node';\nimport { createNativeAudioWorkletNodeConstructor } from './factories/native-audio-worklet-node-constructor';\nimport { createNativeAudioWorkletNodeFactory } from './factories/native-audio-worklet-node-factory';\nimport { createNativeAudioWorkletNodeFakerFactory } from './factories/native-audio-worklet-node-faker-factory';\nimport { createNativeBiquadFilterNode } from './factories/native-biquad-filter-node';\nimport { createNativeChannelMergerNodeFactory } from './factories/native-channel-merger-node-factory';\nimport { createNativeChannelSplitterNode } from './factories/native-channel-splitter-node';\nimport { createNativeConstantSourceNodeFactory } from './factories/native-constant-source-node-factory';\nimport { createNativeConstantSourceNodeFakerFactory } from './factories/native-constant-source-node-faker-factory';\nimport { createNativeConvolverNodeFactory } from './factories/native-convolver-node-factory';\nimport { createNativeDelayNode } from './factories/native-delay-node';\nimport { createNativeDynamicsCompressorNodeFactory } from './factories/native-dynamics-compressor-node-factory';\nimport { createNativeGainNode } from './factories/native-gain-node';\nimport { createNativeIIRFilterNodeFactory } from './factories/native-iir-filter-node-factory';\nimport { createNativeIIRFilterNodeFakerFactory } from './factories/native-iir-filter-node-faker-factory';\nimport { createNativeMediaElementAudioSourceNode } from './factories/native-media-element-audio-source-node';\nimport { createNativeMediaStreamAudioDestinationNode } from './factories/native-media-stream-audio-destination-node';\nimport { createNativeMediaStreamAudioSourceNode } from './factories/native-media-stream-audio-source-node';\nimport { createNativeMediaStreamTrackAudioSourceNodeFactory } from './factories/native-media-stream-track-audio-source-node-factory';\nimport { createNativeOfflineAudioContextConstructor } from './factories/native-offline-audio-context-constructor';\nimport { createNativeOscillatorNodeFactory } from './factories/native-oscillator-node-factory';\nimport { createNativePannerNodeFactory } from './factories/native-panner-node-factory';\nimport { createNativePannerNodeFakerFactory } from './factories/native-panner-node-faker-factory';\nimport { createNativePeriodicWaveFactory } from './factories/native-periodic-wave-factory';\nimport { createNativeScriptProcessorNode } from './factories/native-script-processor-node';\nimport { createNativeStereoPannerNodeFactory } from './factories/native-stereo-panner-node-factory';\nimport { createNativeStereoPannerNodeFakerFactory } from './factories/native-stereo-panner-node-faker-factory';\nimport { createNativeWaveShaperNodeFactory } from './factories/native-wave-shaper-node-factory';\nimport { createNativeWaveShaperNodeFakerFactory } from './factories/native-wave-shaper-node-faker-factory';\nimport { createNotSupportedError } from './factories/not-supported-error';\nimport { createOfflineAudioContextConstructor } from './factories/offline-audio-context-constructor';\nimport { createOscillatorNodeConstructor } from './factories/oscillator-node-constructor';\nimport { createOscillatorNodeRendererFactory } from './factories/oscillator-node-renderer-factory';\nimport { createPannerNodeConstructor } from './factories/panner-node-constructor';\nimport { createPannerNodeRendererFactory } from './factories/panner-node-renderer-factory';\nimport { createPeriodicWaveConstructor } from './factories/periodic-wave-constructor';\nimport { createRenderAutomation } from './factories/render-automation';\nimport { createRenderInputsOfAudioNode } from './factories/render-inputs-of-audio-node';\nimport { createRenderInputsOfAudioParam } from './factories/render-inputs-of-audio-param';\nimport { createRenderNativeOfflineAudioContext } from './factories/render-native-offline-audio-context';\nimport { createSetActiveAudioWorkletNodeInputs } from './factories/set-active-audio-worklet-node-inputs';\nimport { createSetAudioNodeTailTime } from './factories/set-audio-node-tail-time';\nimport { createStartRendering } from './factories/start-rendering';\nimport { createStereoPannerNodeConstructor } from './factories/stereo-panner-node-constructor';\nimport { createStereoPannerNodeRendererFactory } from './factories/stereo-panner-node-renderer-factory';\nimport { createTestAudioBufferConstructorSupport } from './factories/test-audio-buffer-constructor-support';\nimport { createTestAudioBufferCopyChannelMethodsSubarraySupport } from './factories/test-audio-buffer-copy-channel-methods-subarray-support';\nimport { createTestAudioContextCloseMethodSupport } from './factories/test-audio-context-close-method-support';\nimport { createTestAudioContextDecodeAudioDataMethodTypeErrorSupport } from './factories/test-audio-context-decode-audio-data-method-type-error-support';\nimport { createTestAudioContextOptionsSupport } from './factories/test-audio-context-options-support';\nimport { createTestAudioNodeConnectMethodSupport } from './factories/test-audio-node-connect-method-support';\nimport { createTestAudioWorkletProcessorNoOutputsSupport } from './factories/test-audio-worklet-processor-no-outputs-support';\nimport { createTestAudioWorkletProcessorPostMessageSupport } from './factories/test-audio-worklet-processor-post-message-support';\nimport { createTestChannelMergerNodeChannelCountSupport } from './factories/test-channel-merger-node-channel-count-support';\nimport { createTestConstantSourceNodeAccurateSchedulingSupport } from './factories/test-constant-source-node-accurate-scheduling-support';\nimport { createTestConvolverNodeBufferReassignabilitySupport } from './factories/test-convolver-node-buffer-reassignability-support';\nimport { createTestConvolverNodeChannelCountSupport } from './factories/test-convolver-node-channel-count-support';\nimport { createTestIsSecureContextSupport } from './factories/test-is-secure-context-support';\nimport { createTestMediaStreamAudioSourceNodeMediaStreamWithoutAudioTrackSupport } from './factories/test-media-stream-audio-source-node-media-stream-without-audio-track-support';\nimport { createTestOfflineAudioContextCurrentTimeSupport } from './factories/test-offline-audio-context-current-time-support';\nimport { createTestStereoPannerNodeDefaultValueSupport } from './factories/test-stereo-panner-node-default-value-support';\nimport { createUnknownError } from './factories/unknown-error';\nimport { createWaveShaperNodeConstructor } from './factories/wave-shaper-node-constructor';\nimport { createWaveShaperNodeRendererFactory } from './factories/wave-shaper-node-renderer-factory';\nimport { createWindow } from './factories/window';\nimport { createWrapAudioBufferCopyChannelMethods } from './factories/wrap-audio-buffer-copy-channel-methods';\nimport { createWrapAudioBufferCopyChannelMethodsOutOfBounds } from './factories/wrap-audio-buffer-copy-channel-methods-out-of-bounds';\nimport { createWrapAudioBufferSourceNodeStopMethodNullifiedBuffer } from './factories/wrap-audio-buffer-source-node-stop-method-nullified-buffer';\nimport { createWrapChannelMergerNode } from './factories/wrap-channel-merger-node';\nimport {\n    AUDIO_NODE_CONNECTIONS_STORE,\n    AUDIO_NODE_STORE,\n    AUDIO_PARAM_CONNECTIONS_STORE,\n    AUDIO_PARAM_STORE,\n    CONTEXT_STORE,\n    CYCLE_COUNTERS\n} from './globals';\nimport { connectNativeAudioNodeToNativeAudioNode } from './helpers/connect-native-audio-node-to-native-audio-node';\nimport { disconnectNativeAudioNodeFromNativeAudioNode } from './helpers/disconnect-native-audio-node-from-native-audio-node';\nimport { getAudioNodeConnections } from './helpers/get-audio-node-connections';\nimport { getAudioParamConnections } from './helpers/get-audio-param-connections';\nimport { getEventListenersOfAudioNode } from './helpers/get-event-listeners-of-audio-node';\nimport { getFirstSample } from './helpers/get-first-sample';\nimport { getNativeAudioNode } from './helpers/get-native-audio-node';\nimport { getNativeAudioParam } from './helpers/get-native-audio-param';\nimport { getValueForKey } from './helpers/get-value-for-key';\nimport { insertElementInSet } from './helpers/insert-element-in-set';\nimport { isActiveAudioNode } from './helpers/is-active-audio-node';\nimport { isDCCurve } from './helpers/is-dc-curve';\nimport { isPartOfACycle } from './helpers/is-part-of-a-cycle';\nimport { isPassiveAudioNode } from './helpers/is-passive-audio-node';\nimport { overwriteAccessors } from './helpers/overwrite-accessors';\nimport { pickElementFromSet } from './helpers/pick-element-from-set';\nimport { sanitizeAudioWorkletNodeOptions } from './helpers/sanitize-audio-worklet-node-options';\nimport { sanitizeChannelSplitterOptions } from './helpers/sanitize-channel-splitter-options';\nimport { sanitizePeriodicWaveOptions } from './helpers/sanitize-periodic-wave-options';\nimport { setValueAtTimeUntilPossible } from './helpers/set-value-at-time-until-possible';\nimport { testAudioBufferCopyChannelMethodsOutOfBoundsSupport } from './helpers/test-audio-buffer-copy-channel-methods-out-of-bounds-support';\nimport { testAudioBufferSourceNodeStartMethodConsecutiveCallsSupport } from './helpers/test-audio-buffer-source-node-start-method-consecutive-calls-support';\nimport { testAudioBufferSourceNodeStartMethodOffsetClampingSupport } from './helpers/test-audio-buffer-source-node-start-method-offset-clamping-support';\nimport { testAudioBufferSourceNodeStopMethodNullifiedBufferSupport } from './helpers/test-audio-buffer-source-node-stop-method-nullified-buffer-support';\nimport { testAudioScheduledSourceNodeStartMethodNegativeParametersSupport } from './helpers/test-audio-scheduled-source-node-start-method-negative-parameters-support';\nimport { testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport } from './helpers/test-audio-scheduled-source-node-stop-method-consecutive-calls-support';\nimport { testAudioScheduledSourceNodeStopMethodNegativeParametersSupport } from './helpers/test-audio-scheduled-source-node-stop-method-negative-parameters-support';\nimport { testAudioWorkletNodeOptionsClonability } from './helpers/test-audio-worklet-node-options-clonability';\nimport { testDomExceptionConstructorSupport } from './helpers/test-dom-exception-constructor-support';\nimport { testPromiseSupport } from './helpers/test-promise-support';\nimport { testTransferablesSupport } from './helpers/test-transferables-support';\nimport { wrapAudioBufferSourceNodeStartMethodOffsetClamping } from './helpers/wrap-audio-buffer-source-node-start-method-offset-clamping';\nimport { wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls } from './helpers/wrap-audio-scheduled-source-node-stop-method-consecutive-calls';\nimport { wrapEventListener } from './helpers/wrap-event-listener';\nimport {\n    IAnalyserNode,\n    IAudioBuffer,\n    IAudioBufferSourceNode,\n    IAudioContext,\n    IAudioNode,\n    IAudioWorkletNode,\n    IBiquadFilterNode,\n    IConstantSourceNode,\n    IConvolverNode,\n    IDelayNode,\n    IDynamicsCompressorNode,\n    IGainNode,\n    IIIRFilterNode,\n    IMediaElementAudioSourceNode,\n    IMediaStreamAudioDestinationNode,\n    IMediaStreamAudioSourceNode,\n    IMediaStreamTrackAudioSourceNode,\n    IMinimalAudioContext,\n    IMinimalOfflineAudioContext,\n    IOfflineAudioContext,\n    IOfflineAudioContextConstructor,\n    IOscillatorNode,\n    IPannerNode,\n    IPeriodicWave,\n    IStereoPannerNode,\n    IWaveShaperNode\n} from './interfaces';\nimport {\n    TActiveAudioWorkletNodeInputsStore,\n    TAddAudioWorkletModuleFunction,\n    TAnalyserNodeConstructor,\n    TAudioBufferConstructor,\n    TAudioBufferSourceNodeConstructor,\n    TAudioBufferStore,\n    TAudioContextConstructor,\n    TAudioParamAudioNodeStore,\n    TAudioWorkletNodeConstructor,\n    TBackupOfflineAudioContextStore,\n    TBiquadFilterNodeConstructor,\n    TChannelMergerNodeConstructor,\n    TChannelSplitterNodeConstructor,\n    TConstantSourceNodeConstructor,\n    TContext,\n    TConvolverNodeConstructor,\n    TDecodeAudioDataFunction,\n    TDelayNodeConstructor,\n    TDynamicsCompressorNodeConstructor,\n    TGainNodeConstructor,\n    TIIRFilterNodeConstructor,\n    TMediaElementAudioSourceNodeConstructor,\n    TMediaStreamAudioDestinationNodeConstructor,\n    TMediaStreamAudioSourceNodeConstructor,\n    TMediaStreamTrackAudioSourceNodeConstructor,\n    TMinimalAudioContextConstructor,\n    TMinimalOfflineAudioContextConstructor,\n    TOscillatorNodeConstructor,\n    TPannerNodeConstructor,\n    TPeriodicWaveConstructor,\n    TStereoPannerNodeConstructor,\n    TUnrenderedAudioWorkletNodeStore,\n    TWaveShaperNodeConstructor\n} from './types';\n\n/*\n * @todo Explicitly referencing the barrel file seems to be necessary when enabling the\n * isolatedModules compiler option.\n */\nexport * from './interfaces/index';\nexport * from './types/index';\n\nconst addActiveInputConnectionToAudioNode = createAddActiveInputConnectionToAudioNode(insertElementInSet);\nconst addPassiveInputConnectionToAudioNode = createAddPassiveInputConnectionToAudioNode(insertElementInSet);\nconst deleteActiveInputConnectionToAudioNode = createDeleteActiveInputConnectionToAudioNode(pickElementFromSet);\nconst audioNodeTailTimeStore = new WeakMap();\nconst getAudioNodeTailTime = createGetAudioNodeTailTime(audioNodeTailTimeStore);\nconst cacheTestResult = createCacheTestResult(new Map(), new WeakMap());\nconst window = createWindow();\nconst createNativeAnalyserNode = createNativeAnalyserNodeFactory(cacheTestResult, createIndexSizeError);\nconst getAudioNodeRenderer = createGetAudioNodeRenderer(getAudioNodeConnections);\nconst renderInputsOfAudioNode = createRenderInputsOfAudioNode(getAudioNodeConnections, getAudioNodeRenderer, isPartOfACycle);\nconst createAnalyserNodeRenderer = createAnalyserNodeRendererFactory(createNativeAnalyserNode, getNativeAudioNode, renderInputsOfAudioNode);\nconst getNativeContext = createGetNativeContext(CONTEXT_STORE);\nconst nativeOfflineAudioContextConstructor = createNativeOfflineAudioContextConstructor(window);\nconst isNativeOfflineAudioContext = createIsNativeOfflineAudioContext(nativeOfflineAudioContextConstructor);\nconst audioParamAudioNodeStore: TAudioParamAudioNodeStore = new WeakMap();\nconst eventTargetConstructor = createEventTargetConstructor(wrapEventListener);\nconst nativeAudioContextConstructor = createNativeAudioContextConstructor(window);\nconst isNativeAudioContext = createIsNativeAudioContext(nativeAudioContextConstructor);\nconst isNativeAudioNode = createIsNativeAudioNode(window);\nconst isNativeAudioParam = createIsNativeAudioParam(window);\nconst nativeAudioWorkletNodeConstructor = createNativeAudioWorkletNodeConstructor(window);\nconst audioNodeConstructor = createAudioNodeConstructor(\n    createAddAudioNodeConnections(AUDIO_NODE_CONNECTIONS_STORE),\n    createAddConnectionToAudioNode(\n        addActiveInputConnectionToAudioNode,\n        addPassiveInputConnectionToAudioNode,\n        connectNativeAudioNodeToNativeAudioNode,\n        deleteActiveInputConnectionToAudioNode,\n        disconnectNativeAudioNodeFromNativeAudioNode,\n        getAudioNodeConnections,\n        getAudioNodeTailTime,\n        getEventListenersOfAudioNode,\n        getNativeAudioNode,\n        insertElementInSet,\n        isActiveAudioNode,\n        isPartOfACycle,\n        isPassiveAudioNode\n    ),\n    cacheTestResult,\n    createIncrementCycleCounterFactory(\n        CYCLE_COUNTERS,\n        disconnectNativeAudioNodeFromNativeAudioNode,\n        getAudioNodeConnections,\n        getNativeAudioNode,\n        getNativeAudioParam,\n        isActiveAudioNode\n    ),\n    createIndexSizeError,\n    createInvalidAccessError,\n    createNotSupportedError,\n    createDecrementCycleCounter(\n        connectNativeAudioNodeToNativeAudioNode,\n        CYCLE_COUNTERS,\n        getAudioNodeConnections,\n        getNativeAudioNode,\n        getNativeAudioParam,\n        getNativeContext,\n        isActiveAudioNode,\n        isNativeOfflineAudioContext\n    ),\n    createDetectCycles(audioParamAudioNodeStore, getAudioNodeConnections, getValueForKey),\n    eventTargetConstructor,\n    getNativeContext,\n    isNativeAudioContext,\n    isNativeAudioNode,\n    isNativeAudioParam,\n    isNativeOfflineAudioContext,\n    nativeAudioWorkletNodeConstructor\n);\nconst analyserNodeConstructor: TAnalyserNodeConstructor = createAnalyserNodeConstructor(\n    audioNodeConstructor,\n    createAnalyserNodeRenderer,\n    createIndexSizeError,\n    createNativeAnalyserNode,\n    getNativeContext,\n    isNativeOfflineAudioContext\n);\n\ntype analyserNodeConstructor<T extends TContext> = IAnalyserNode<T>;\n\nexport { analyserNodeConstructor as AnalyserNode };\n\nconst audioBufferStore: TAudioBufferStore = new WeakSet();\nconst nativeAudioBufferConstructor = createNativeAudioBufferConstructor(window);\nconst convertNumberToUnsignedLong = createConvertNumberToUnsignedLong(new Uint32Array(1));\nconst wrapAudioBufferCopyChannelMethods = createWrapAudioBufferCopyChannelMethods(convertNumberToUnsignedLong, createIndexSizeError);\nconst wrapAudioBufferCopyChannelMethodsOutOfBounds = createWrapAudioBufferCopyChannelMethodsOutOfBounds(convertNumberToUnsignedLong);\nconst audioBufferConstructor: TAudioBufferConstructor = createAudioBufferConstructor(\n    audioBufferStore,\n    cacheTestResult,\n    createNotSupportedError,\n    nativeAudioBufferConstructor,\n    nativeOfflineAudioContextConstructor,\n    createTestAudioBufferConstructorSupport(nativeAudioBufferConstructor),\n    wrapAudioBufferCopyChannelMethods,\n    wrapAudioBufferCopyChannelMethodsOutOfBounds\n);\n\ntype audioBufferConstructor = IAudioBuffer;\n\nexport { audioBufferConstructor as AudioBuffer };\n\nconst addSilentConnection = createAddSilentConnection(createNativeGainNode);\nconst renderInputsOfAudioParam = createRenderInputsOfAudioParam(getAudioNodeRenderer, getAudioParamConnections, isPartOfACycle);\nconst connectAudioParam = createConnectAudioParam(renderInputsOfAudioParam);\nconst createNativeAudioBufferSourceNode = createNativeAudioBufferSourceNodeFactory(\n    addSilentConnection,\n    cacheTestResult,\n    testAudioBufferSourceNodeStartMethodConsecutiveCallsSupport,\n    testAudioBufferSourceNodeStartMethodOffsetClampingSupport,\n    testAudioBufferSourceNodeStopMethodNullifiedBufferSupport,\n    testAudioScheduledSourceNodeStartMethodNegativeParametersSupport,\n    testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport,\n    testAudioScheduledSourceNodeStopMethodNegativeParametersSupport,\n    wrapAudioBufferSourceNodeStartMethodOffsetClamping,\n    createWrapAudioBufferSourceNodeStopMethodNullifiedBuffer(overwriteAccessors),\n    wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls\n);\nconst renderAutomation = createRenderAutomation(createGetAudioParamRenderer(getAudioParamConnections), renderInputsOfAudioParam);\nconst createAudioBufferSourceNodeRenderer = createAudioBufferSourceNodeRendererFactory(\n    connectAudioParam,\n    createNativeAudioBufferSourceNode,\n    getNativeAudioNode,\n    renderAutomation,\n    renderInputsOfAudioNode\n);\nconst createAudioParam = createAudioParamFactory(\n    createAddAudioParamConnections(AUDIO_PARAM_CONNECTIONS_STORE),\n    audioParamAudioNodeStore,\n    AUDIO_PARAM_STORE,\n    createAudioParamRenderer,\n    createCancelAndHoldAutomationEvent,\n    createCancelScheduledValuesAutomationEvent,\n    createExponentialRampToValueAutomationEvent,\n    createLinearRampToValueAutomationEvent,\n    createSetTargetAutomationEvent,\n    createSetValueAutomationEvent,\n    createSetValueCurveAutomationEvent,\n    nativeAudioContextConstructor,\n    setValueAtTimeUntilPossible\n);\nconst audioBufferSourceNodeConstructor: TAudioBufferSourceNodeConstructor = createAudioBufferSourceNodeConstructor(\n    audioNodeConstructor,\n    createAudioBufferSourceNodeRenderer,\n    createAudioParam,\n    createInvalidStateError,\n    createNativeAudioBufferSourceNode,\n    getNativeContext,\n    isNativeOfflineAudioContext,\n    wrapEventListener\n);\n\ntype audioBufferSourceNodeConstructor<T extends TContext> = IAudioBufferSourceNode<T>;\n\nexport { audioBufferSourceNodeConstructor as AudioBufferSourceNode };\n\nconst audioDestinationNodeConstructor = createAudioDestinationNodeConstructor(\n    audioNodeConstructor,\n    createAudioDestinationNodeRenderer,\n    createIndexSizeError,\n    createInvalidStateError,\n    createNativeAudioDestinationNodeFactory(createNativeGainNode, overwriteAccessors),\n    getNativeContext,\n    isNativeOfflineAudioContext,\n    renderInputsOfAudioNode\n);\nconst createBiquadFilterNodeRenderer = createBiquadFilterNodeRendererFactory(\n    connectAudioParam,\n    createNativeBiquadFilterNode,\n    getNativeAudioNode,\n    renderAutomation,\n    renderInputsOfAudioNode\n);\nconst setAudioNodeTailTime = createSetAudioNodeTailTime(audioNodeTailTimeStore);\nconst biquadFilterNodeConstructor: TBiquadFilterNodeConstructor = createBiquadFilterNodeConstructor(\n    audioNodeConstructor,\n    createAudioParam,\n    createBiquadFilterNodeRenderer,\n    createInvalidAccessError,\n    createNativeBiquadFilterNode,\n    getNativeContext,\n    isNativeOfflineAudioContext,\n    setAudioNodeTailTime\n);\nconst monitorConnections = createMonitorConnections(insertElementInSet, isNativeAudioNode);\nconst wrapChannelMergerNode = createWrapChannelMergerNode(createInvalidStateError, monitorConnections);\nconst createNativeChannelMergerNode = createNativeChannelMergerNodeFactory(nativeAudioContextConstructor, wrapChannelMergerNode);\nconst createChannelMergerNodeRenderer = createChannelMergerNodeRendererFactory(\n    createNativeChannelMergerNode,\n    getNativeAudioNode,\n    renderInputsOfAudioNode\n);\nconst channelMergerNodeConstructor: TChannelMergerNodeConstructor = createChannelMergerNodeConstructor(\n    audioNodeConstructor,\n    createChannelMergerNodeRenderer,\n    createNativeChannelMergerNode,\n    getNativeContext,\n    isNativeOfflineAudioContext\n);\nconst createChannelSplitterNodeRenderer = createChannelSplitterNodeRendererFactory(\n    createNativeChannelSplitterNode,\n    getNativeAudioNode,\n    renderInputsOfAudioNode\n);\nconst channelSplitterNodeConstructor: TChannelSplitterNodeConstructor = createChannelSplitterNodeConstructor(\n    audioNodeConstructor,\n    createChannelSplitterNodeRenderer,\n    createNativeChannelSplitterNode,\n    getNativeContext,\n    isNativeOfflineAudioContext,\n    sanitizeChannelSplitterOptions\n);\nconst createNativeConstantSourceNodeFaker = createNativeConstantSourceNodeFakerFactory(\n    addSilentConnection,\n    createNativeAudioBufferSourceNode,\n    createNativeGainNode,\n    monitorConnections\n);\nconst createNativeConstantSourceNode = createNativeConstantSourceNodeFactory(\n    addSilentConnection,\n    cacheTestResult,\n    createNativeConstantSourceNodeFaker,\n    testAudioScheduledSourceNodeStartMethodNegativeParametersSupport,\n    testAudioScheduledSourceNodeStopMethodNegativeParametersSupport\n);\nconst createConstantSourceNodeRenderer = createConstantSourceNodeRendererFactory(\n    connectAudioParam,\n    createNativeConstantSourceNode,\n    getNativeAudioNode,\n    renderAutomation,\n    renderInputsOfAudioNode\n);\nconst constantSourceNodeConstructor: TConstantSourceNodeConstructor = createConstantSourceNodeConstructor(\n    audioNodeConstructor,\n    createAudioParam,\n    createConstantSourceNodeRenderer,\n    createNativeConstantSourceNode,\n    getNativeContext,\n    isNativeOfflineAudioContext,\n    wrapEventListener\n);\nconst createNativeConvolverNode = createNativeConvolverNodeFactory(createNotSupportedError, overwriteAccessors);\nconst createConvolverNodeRenderer = createConvolverNodeRendererFactory(\n    createNativeConvolverNode,\n    getNativeAudioNode,\n    renderInputsOfAudioNode\n);\nconst convolverNodeConstructor: TConvolverNodeConstructor = createConvolverNodeConstructor(\n    audioNodeConstructor,\n    createConvolverNodeRenderer,\n    createNativeConvolverNode,\n    getNativeContext,\n    isNativeOfflineAudioContext,\n    setAudioNodeTailTime\n);\nconst createDelayNodeRenderer = createDelayNodeRendererFactory(\n    connectAudioParam,\n    createNativeDelayNode,\n    getNativeAudioNode,\n    renderAutomation,\n    renderInputsOfAudioNode\n);\nconst delayNodeConstructor: TDelayNodeConstructor = createDelayNodeConstructor(\n    audioNodeConstructor,\n    createAudioParam,\n    createDelayNodeRenderer,\n    createNativeDelayNode,\n    getNativeContext,\n    isNativeOfflineAudioContext,\n    setAudioNodeTailTime\n);\nconst createNativeDynamicsCompressorNode = createNativeDynamicsCompressorNodeFactory(createNotSupportedError);\nconst createDynamicsCompressorNodeRenderer = createDynamicsCompressorNodeRendererFactory(\n    connectAudioParam,\n    createNativeDynamicsCompressorNode,\n    getNativeAudioNode,\n    renderAutomation,\n    renderInputsOfAudioNode\n);\nconst dynamicsCompressorNodeConstructor: TDynamicsCompressorNodeConstructor = createDynamicsCompressorNodeConstructor(\n    audioNodeConstructor,\n    createAudioParam,\n    createDynamicsCompressorNodeRenderer,\n    createNativeDynamicsCompressorNode,\n    createNotSupportedError,\n    getNativeContext,\n    isNativeOfflineAudioContext,\n    setAudioNodeTailTime\n);\nconst createGainNodeRenderer = createGainNodeRendererFactory(\n    connectAudioParam,\n    createNativeGainNode,\n    getNativeAudioNode,\n    renderAutomation,\n    renderInputsOfAudioNode\n);\nconst gainNodeConstructor: TGainNodeConstructor = createGainNodeConstructor(\n    audioNodeConstructor,\n    createAudioParam,\n    createGainNodeRenderer,\n    createNativeGainNode,\n    getNativeContext,\n    isNativeOfflineAudioContext\n);\nconst createNativeIIRFilterNodeFaker = createNativeIIRFilterNodeFakerFactory(\n    createInvalidAccessError,\n    createInvalidStateError,\n    createNativeScriptProcessorNode,\n    createNotSupportedError\n);\nconst renderNativeOfflineAudioContext = createRenderNativeOfflineAudioContext(\n    cacheTestResult,\n    createNativeGainNode,\n    createNativeScriptProcessorNode,\n    createTestOfflineAudioContextCurrentTimeSupport(createNativeGainNode, nativeOfflineAudioContextConstructor)\n);\nconst createIIRFilterNodeRenderer = createIIRFilterNodeRendererFactory(\n    createNativeAudioBufferSourceNode,\n    getNativeAudioNode,\n    nativeOfflineAudioContextConstructor,\n    renderInputsOfAudioNode,\n    renderNativeOfflineAudioContext\n);\nconst createNativeIIRFilterNode = createNativeIIRFilterNodeFactory(createNativeIIRFilterNodeFaker);\nconst iIRFilterNodeConstructor: TIIRFilterNodeConstructor = createIIRFilterNodeConstructor(\n    audioNodeConstructor,\n    createNativeIIRFilterNode,\n    createIIRFilterNodeRenderer,\n    getNativeContext,\n    isNativeOfflineAudioContext,\n    setAudioNodeTailTime\n);\nconst createAudioListener = createAudioListenerFactory(\n    createAudioParam,\n    createNativeChannelMergerNode,\n    createNativeConstantSourceNode,\n    createNativeScriptProcessorNode,\n    createNotSupportedError,\n    getFirstSample,\n    isNativeOfflineAudioContext,\n    overwriteAccessors\n);\nconst unrenderedAudioWorkletNodeStore: TUnrenderedAudioWorkletNodeStore = new WeakMap();\nconst minimalBaseAudioContextConstructor = createMinimalBaseAudioContextConstructor(\n    audioDestinationNodeConstructor,\n    createAudioListener,\n    eventTargetConstructor,\n    isNativeOfflineAudioContext,\n    unrenderedAudioWorkletNodeStore,\n    wrapEventListener\n);\nconst createNativeOscillatorNode = createNativeOscillatorNodeFactory(\n    addSilentConnection,\n    cacheTestResult,\n    testAudioScheduledSourceNodeStartMethodNegativeParametersSupport,\n    testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport,\n    testAudioScheduledSourceNodeStopMethodNegativeParametersSupport,\n    wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls\n);\nconst createOscillatorNodeRenderer = createOscillatorNodeRendererFactory(\n    connectAudioParam,\n    createNativeOscillatorNode,\n    getNativeAudioNode,\n    renderAutomation,\n    renderInputsOfAudioNode\n);\nconst oscillatorNodeConstructor: TOscillatorNodeConstructor = createOscillatorNodeConstructor(\n    audioNodeConstructor,\n    createAudioParam,\n    createNativeOscillatorNode,\n    createOscillatorNodeRenderer,\n    getNativeContext,\n    isNativeOfflineAudioContext,\n    wrapEventListener\n);\nconst createConnectedNativeAudioBufferSourceNode = createConnectedNativeAudioBufferSourceNodeFactory(createNativeAudioBufferSourceNode);\nconst createNativeWaveShaperNodeFaker = createNativeWaveShaperNodeFakerFactory(\n    createConnectedNativeAudioBufferSourceNode,\n    createInvalidStateError,\n    createNativeGainNode,\n    isDCCurve,\n    monitorConnections\n);\nconst createNativeWaveShaperNode = createNativeWaveShaperNodeFactory(\n    createConnectedNativeAudioBufferSourceNode,\n    createInvalidStateError,\n    createNativeWaveShaperNodeFaker,\n    isDCCurve,\n    monitorConnections,\n    nativeAudioContextConstructor,\n    overwriteAccessors\n);\nconst createNativePannerNodeFaker = createNativePannerNodeFakerFactory(\n    connectNativeAudioNodeToNativeAudioNode,\n    createInvalidStateError,\n    createNativeChannelMergerNode,\n    createNativeGainNode,\n    createNativeScriptProcessorNode,\n    createNativeWaveShaperNode,\n    createNotSupportedError,\n    disconnectNativeAudioNodeFromNativeAudioNode,\n    getFirstSample,\n    monitorConnections\n);\nconst createNativePannerNode = createNativePannerNodeFactory(createNativePannerNodeFaker);\nconst createPannerNodeRenderer = createPannerNodeRendererFactory(\n    connectAudioParam,\n    createNativeChannelMergerNode,\n    createNativeConstantSourceNode,\n    createNativeGainNode,\n    createNativePannerNode,\n    getNativeAudioNode,\n    nativeOfflineAudioContextConstructor,\n    renderAutomation,\n    renderInputsOfAudioNode,\n    renderNativeOfflineAudioContext\n);\nconst pannerNodeConstructor: TPannerNodeConstructor = createPannerNodeConstructor(\n    audioNodeConstructor,\n    createAudioParam,\n    createNativePannerNode,\n    createPannerNodeRenderer,\n    getNativeContext,\n    isNativeOfflineAudioContext,\n    setAudioNodeTailTime\n);\nconst createNativePeriodicWave = createNativePeriodicWaveFactory(createIndexSizeError);\nconst periodicWaveConstructor: TPeriodicWaveConstructor = createPeriodicWaveConstructor(\n    createNativePeriodicWave,\n    getNativeContext,\n    new WeakSet(),\n    sanitizePeriodicWaveOptions\n);\nconst nativeStereoPannerNodeFakerFactory = createNativeStereoPannerNodeFakerFactory(\n    createNativeChannelMergerNode,\n    createNativeChannelSplitterNode,\n    createNativeGainNode,\n    createNativeWaveShaperNode,\n    createNotSupportedError,\n    monitorConnections\n);\nconst createNativeStereoPannerNode = createNativeStereoPannerNodeFactory(nativeStereoPannerNodeFakerFactory, createNotSupportedError);\nconst createStereoPannerNodeRenderer = createStereoPannerNodeRendererFactory(\n    connectAudioParam,\n    createNativeStereoPannerNode,\n    getNativeAudioNode,\n    renderAutomation,\n    renderInputsOfAudioNode\n);\nconst stereoPannerNodeConstructor: TStereoPannerNodeConstructor = createStereoPannerNodeConstructor(\n    audioNodeConstructor,\n    createAudioParam,\n    createNativeStereoPannerNode,\n    createStereoPannerNodeRenderer,\n    getNativeContext,\n    isNativeOfflineAudioContext\n);\nconst createWaveShaperNodeRenderer = createWaveShaperNodeRendererFactory(\n    createNativeWaveShaperNode,\n    getNativeAudioNode,\n    renderInputsOfAudioNode\n);\nconst waveShaperNodeConstructor: TWaveShaperNodeConstructor = createWaveShaperNodeConstructor(\n    audioNodeConstructor,\n    createInvalidStateError,\n    createNativeWaveShaperNode,\n    createWaveShaperNodeRenderer,\n    getNativeContext,\n    isNativeOfflineAudioContext,\n    setAudioNodeTailTime\n);\nconst isSecureContext = createIsSecureContext(window);\nconst exposeCurrentFrameAndCurrentTime = createExposeCurrentFrameAndCurrentTime(window);\nconst backupOfflineAudioContextStore: TBackupOfflineAudioContextStore = new WeakMap();\nconst getOrCreateBackupOfflineAudioContext = createGetOrCreateBackupOfflineAudioContext(\n    backupOfflineAudioContextStore,\n    nativeOfflineAudioContextConstructor\n);\n\n// The addAudioWorkletModule() function is only available in a SecureContext.\nexport const addAudioWorkletModule: undefined | TAddAudioWorkletModuleFunction = isSecureContext\n    ? createAddAudioWorkletModule(\n          cacheTestResult,\n          createNotSupportedError,\n          createEvaluateSource(window),\n          exposeCurrentFrameAndCurrentTime,\n          createFetchSource(createAbortError),\n          getNativeContext,\n          getOrCreateBackupOfflineAudioContext,\n          isNativeOfflineAudioContext,\n          nativeAudioWorkletNodeConstructor,\n          new WeakMap(),\n          new WeakMap(),\n          createTestAudioWorkletProcessorPostMessageSupport(nativeAudioWorkletNodeConstructor, nativeOfflineAudioContextConstructor),\n          // @todo window is guaranteed to be defined because isSecureContext checks that as well.\n          <NonNullable<typeof window>>window\n      )\n    : undefined;\n\nconst isNativeContext = createIsNativeContext(isNativeAudioContext, isNativeOfflineAudioContext);\n\nexport const decodeAudioData: TDecodeAudioDataFunction = createDecodeAudioData(\n    audioBufferStore,\n    cacheTestResult,\n    createDataCloneError,\n    createEncodingError,\n    new WeakSet(),\n    getNativeContext,\n    isNativeContext,\n    testAudioBufferCopyChannelMethodsOutOfBoundsSupport,\n    testPromiseSupport,\n    wrapAudioBufferCopyChannelMethods,\n    wrapAudioBufferCopyChannelMethodsOutOfBounds\n);\n\nconst baseAudioContextConstructor = createBaseAudioContextConstructor(\n    addAudioWorkletModule,\n    analyserNodeConstructor,\n    audioBufferConstructor,\n    audioBufferSourceNodeConstructor,\n    biquadFilterNodeConstructor,\n    channelMergerNodeConstructor,\n    channelSplitterNodeConstructor,\n    constantSourceNodeConstructor,\n    convolverNodeConstructor,\n    decodeAudioData,\n    delayNodeConstructor,\n    dynamicsCompressorNodeConstructor,\n    gainNodeConstructor,\n    iIRFilterNodeConstructor,\n    minimalBaseAudioContextConstructor,\n    oscillatorNodeConstructor,\n    pannerNodeConstructor,\n    periodicWaveConstructor,\n    stereoPannerNodeConstructor,\n    waveShaperNodeConstructor\n);\nconst mediaElementAudioSourceNodeConstructor: TMediaElementAudioSourceNodeConstructor = createMediaElementAudioSourceNodeConstructor(\n    audioNodeConstructor,\n    createNativeMediaElementAudioSourceNode,\n    getNativeContext,\n    isNativeOfflineAudioContext\n);\nconst mediaStreamAudioDestinationNodeConstructor: TMediaStreamAudioDestinationNodeConstructor =\n    createMediaStreamAudioDestinationNodeConstructor(\n        audioNodeConstructor,\n        createNativeMediaStreamAudioDestinationNode,\n        getNativeContext,\n        isNativeOfflineAudioContext\n    );\nconst mediaStreamAudioSourceNodeConstructor: TMediaStreamAudioSourceNodeConstructor = createMediaStreamAudioSourceNodeConstructor(\n    audioNodeConstructor,\n    createNativeMediaStreamAudioSourceNode,\n    getNativeContext,\n    isNativeOfflineAudioContext\n);\nconst createNativeMediaStreamTrackAudioSourceNode = createNativeMediaStreamTrackAudioSourceNodeFactory(\n    createInvalidStateError,\n    isNativeOfflineAudioContext\n);\nconst mediaStreamTrackAudioSourceNodeConstructor: TMediaStreamTrackAudioSourceNodeConstructor =\n    createMediaStreamTrackAudioSourceNodeConstructor(audioNodeConstructor, createNativeMediaStreamTrackAudioSourceNode, getNativeContext);\nconst audioContextConstructor: TAudioContextConstructor = createAudioContextConstructor(\n    baseAudioContextConstructor,\n    createInvalidStateError,\n    createNotSupportedError,\n    createUnknownError,\n    mediaElementAudioSourceNodeConstructor,\n    mediaStreamAudioDestinationNodeConstructor,\n    mediaStreamAudioSourceNodeConstructor,\n    mediaStreamTrackAudioSourceNodeConstructor,\n    nativeAudioContextConstructor\n);\n\ntype audioContextConstructor = IAudioContext;\n\nexport { audioContextConstructor as AudioContext };\n\nconst getUnrenderedAudioWorkletNodes = createGetUnrenderedAudioWorkletNodes(unrenderedAudioWorkletNodeStore);\nconst addUnrenderedAudioWorkletNode = createAddUnrenderedAudioWorkletNode(getUnrenderedAudioWorkletNodes);\nconst connectMultipleOutputs = createConnectMultipleOutputs(createIndexSizeError);\nconst deleteUnrenderedAudioWorkletNode = createDeleteUnrenderedAudioWorkletNode(getUnrenderedAudioWorkletNodes);\nconst disconnectMultipleOutputs = createDisconnectMultipleOutputs(createIndexSizeError);\nconst activeAudioWorkletNodeInputsStore: TActiveAudioWorkletNodeInputsStore = new WeakMap();\nconst getActiveAudioWorkletNodeInputs = createGetActiveAudioWorkletNodeInputs(activeAudioWorkletNodeInputsStore, getValueForKey);\nconst createNativeAudioWorkletNodeFaker = createNativeAudioWorkletNodeFakerFactory(\n    connectMultipleOutputs,\n    createIndexSizeError,\n    createInvalidStateError,\n    createNativeChannelMergerNode,\n    createNativeChannelSplitterNode,\n    createNativeConstantSourceNode,\n    createNativeGainNode,\n    createNativeScriptProcessorNode,\n    createNotSupportedError,\n    disconnectMultipleOutputs,\n    exposeCurrentFrameAndCurrentTime,\n    getActiveAudioWorkletNodeInputs,\n    monitorConnections\n);\nconst createNativeAudioWorkletNode = createNativeAudioWorkletNodeFactory(\n    createInvalidStateError,\n    createNativeAudioWorkletNodeFaker,\n    createNativeGainNode,\n    createNotSupportedError,\n    monitorConnections\n);\nconst createAudioWorkletNodeRenderer = createAudioWorkletNodeRendererFactory(\n    connectAudioParam,\n    connectMultipleOutputs,\n    createNativeAudioBufferSourceNode,\n    createNativeChannelMergerNode,\n    createNativeChannelSplitterNode,\n    createNativeConstantSourceNode,\n    createNativeGainNode,\n    deleteUnrenderedAudioWorkletNode,\n    disconnectMultipleOutputs,\n    exposeCurrentFrameAndCurrentTime,\n    getNativeAudioNode,\n    nativeAudioWorkletNodeConstructor,\n    nativeOfflineAudioContextConstructor,\n    renderAutomation,\n    renderInputsOfAudioNode,\n    renderNativeOfflineAudioContext\n);\nconst getBackupOfflineAudioContext = createGetBackupOfflineAudioContext(backupOfflineAudioContextStore);\nconst setActiveAudioWorkletNodeInputs = createSetActiveAudioWorkletNodeInputs(activeAudioWorkletNodeInputsStore);\n\n// The AudioWorkletNode constructor is only available in a SecureContext.\nconst audioWorkletNodeConstructor: undefined | TAudioWorkletNodeConstructor = isSecureContext\n    ? createAudioWorkletNodeConstructor(\n          addUnrenderedAudioWorkletNode,\n          audioNodeConstructor,\n          createAudioParam,\n          createAudioWorkletNodeRenderer,\n          createNativeAudioWorkletNode,\n          getAudioNodeConnections,\n          getBackupOfflineAudioContext,\n          getNativeContext,\n          isNativeOfflineAudioContext,\n          nativeAudioWorkletNodeConstructor,\n          sanitizeAudioWorkletNodeOptions,\n          setActiveAudioWorkletNodeInputs,\n          testAudioWorkletNodeOptionsClonability,\n          wrapEventListener\n      )\n    : undefined;\n\ntype audioWorkletNodeConstructor<T extends TContext> = undefined | IAudioWorkletNode<T>;\n\nexport { audioWorkletNodeConstructor as AudioWorkletNode };\n\ntype biquadFilterNodeConstructor<T extends TContext> = IBiquadFilterNode<T>;\n\nexport { biquadFilterNodeConstructor as BiquadFilterNode };\n\ntype channelMergerNodeConstructor<T extends TContext> = IAudioNode<T>;\n\nexport { channelMergerNodeConstructor as ChannelMergerNode };\n\ntype channelSplitterNodeConstructor<T extends TContext> = IAudioNode<T>;\n\nexport { channelSplitterNodeConstructor as ChannelSplitterNode };\n\ntype constantSourceNodeConstructor<T extends TContext> = IConstantSourceNode<T>;\n\nexport { convolverNodeConstructor as ConvolverNode };\n\ntype convolverNodeConstructor<T extends TContext> = IConvolverNode<T>;\n\nexport { constantSourceNodeConstructor as ConstantSourceNode };\n\ntype delayNodeConstructor<T extends TContext> = IDelayNode<T>;\n\nexport { delayNodeConstructor as DelayNode };\n\ntype dynamicsCompressorNodeConstructor<T extends TContext> = IDynamicsCompressorNode<T>;\n\nexport { dynamicsCompressorNodeConstructor as DynamicsCompressorNode };\n\ntype gainNodeConstructor<T extends TContext> = IGainNode<T>;\n\nexport { gainNodeConstructor as GainNode };\n\ntype iIRFilterNodeConstructor<T extends TContext> = IIIRFilterNode<T>;\n\nexport { iIRFilterNodeConstructor as IIRFilterNode };\n\ntype mediaElementAudioSourceNodeConstructor<T extends IAudioContext | IMinimalAudioContext> = IMediaElementAudioSourceNode<T>;\n\nexport { mediaElementAudioSourceNodeConstructor as MediaElementAudioSourceNode };\n\ntype mediaStreamAudioDestinationNodeConstructor<T extends IAudioContext | IMinimalAudioContext> = IMediaStreamAudioDestinationNode<T>;\n\nexport { mediaStreamAudioDestinationNodeConstructor as MediaStreamAudioDestinationNode };\n\ntype mediaStreamAudioSourceNodeConstructor<T extends IAudioContext | IMinimalAudioContext> = IMediaStreamAudioSourceNode<T>;\n\nexport { mediaStreamAudioSourceNodeConstructor as MediaStreamAudioSourceNode };\n\ntype mediaStreamTrackAudioSourceNodeConstructor<T extends IAudioContext | IMinimalAudioContext> = IMediaStreamTrackAudioSourceNode<T>;\n\nexport { mediaStreamTrackAudioSourceNodeConstructor as MediaStreamTrackAudioSourceNode };\n\nconst minimalAudioContextConstructor: TMinimalAudioContextConstructor = createMinimalAudioContextConstructor(\n    createInvalidStateError,\n    createNotSupportedError,\n    createUnknownError,\n    minimalBaseAudioContextConstructor,\n    nativeAudioContextConstructor\n);\n\ntype minimalAudioContextConstructor = IMinimalAudioContext;\n\nexport { minimalAudioContextConstructor as MinimalAudioContext };\n\nconst createNativeOfflineAudioContext = createCreateNativeOfflineAudioContext(\n    createNotSupportedError,\n    nativeOfflineAudioContextConstructor\n);\nconst startRendering = createStartRendering(\n    audioBufferStore,\n    cacheTestResult,\n    getAudioNodeRenderer,\n    getUnrenderedAudioWorkletNodes,\n    renderNativeOfflineAudioContext,\n    testAudioBufferCopyChannelMethodsOutOfBoundsSupport,\n    wrapAudioBufferCopyChannelMethods,\n    wrapAudioBufferCopyChannelMethodsOutOfBounds\n);\nconst minimalOfflineAudioContextConstructor: TMinimalOfflineAudioContextConstructor = createMinimalOfflineAudioContextConstructor(\n    cacheTestResult,\n    createInvalidStateError,\n    createNativeOfflineAudioContext,\n    minimalBaseAudioContextConstructor,\n    startRendering\n);\n\ntype minimalOfflineAudioContextConstructor = IMinimalOfflineAudioContext;\n\nexport { minimalOfflineAudioContextConstructor as MinimalOfflineAudioContext };\n\nconst offlineAudioContextConstructor: IOfflineAudioContextConstructor = createOfflineAudioContextConstructor(\n    baseAudioContextConstructor,\n    cacheTestResult,\n    createInvalidStateError,\n    createNativeOfflineAudioContext,\n    startRendering\n);\n\ntype offlineAudioContextConstructor = IOfflineAudioContext;\n\nexport { offlineAudioContextConstructor as OfflineAudioContext };\n\ntype oscillatorNodeConstructor<T extends TContext> = IOscillatorNode<T>;\n\nexport { oscillatorNodeConstructor as OscillatorNode };\n\ntype pannerNodeConstructor<T extends TContext> = IPannerNode<T>;\n\nexport { pannerNodeConstructor as PannerNode };\n\ntype periodicWaveConstructor = IPeriodicWave;\n\nexport { periodicWaveConstructor as PeriodicWave };\n\ntype stereoPannerNodeConstructor<T extends TContext> = IStereoPannerNode<T>;\n\nexport { stereoPannerNodeConstructor as StereoPannerNode };\n\ntype waveShaperNodeConstructor<T extends TContext> = IWaveShaperNode<T>;\n\nexport { waveShaperNodeConstructor as WaveShaperNode };\n\nexport const isAnyAudioContext = createIsAnyAudioContext(CONTEXT_STORE, isNativeAudioContext);\n\nexport const isAnyAudioNode = createIsAnyAudioNode(AUDIO_NODE_STORE, isNativeAudioNode);\n\nexport const isAnyAudioParam = createIsAnyAudioParam(AUDIO_PARAM_STORE, isNativeAudioParam);\n\nexport const isAnyOfflineAudioContext = createIsAnyOfflineAudioContext(CONTEXT_STORE, isNativeOfflineAudioContext);\n\nexport const isSupported = () =>\n    createIsSupportedPromise(\n        cacheTestResult,\n        createTestAudioBufferCopyChannelMethodsSubarraySupport(nativeOfflineAudioContextConstructor),\n        createTestAudioContextCloseMethodSupport(nativeAudioContextConstructor),\n        createTestAudioContextDecodeAudioDataMethodTypeErrorSupport(nativeOfflineAudioContextConstructor),\n        createTestAudioContextOptionsSupport(nativeAudioContextConstructor),\n        createTestAudioNodeConnectMethodSupport(nativeOfflineAudioContextConstructor),\n        createTestAudioWorkletProcessorNoOutputsSupport(nativeAudioWorkletNodeConstructor, nativeOfflineAudioContextConstructor),\n        createTestChannelMergerNodeChannelCountSupport(nativeOfflineAudioContextConstructor),\n        createTestConstantSourceNodeAccurateSchedulingSupport(nativeOfflineAudioContextConstructor),\n        createTestConvolverNodeBufferReassignabilitySupport(nativeOfflineAudioContextConstructor),\n        createTestConvolverNodeChannelCountSupport(nativeOfflineAudioContextConstructor),\n        testDomExceptionConstructorSupport,\n        createTestIsSecureContextSupport(window),\n        createTestMediaStreamAudioSourceNodeMediaStreamWithoutAudioTrackSupport(nativeAudioContextConstructor),\n        createTestStereoPannerNodeDefaultValueSupport(nativeOfflineAudioContextConstructor),\n        testTransferablesSupport\n    );\n", "import { TAbortErrorFactory } from '../types';\n\nexport const createAbortError: TAbortErrorFactory = () => new DOMException('', 'AbortError');\n", "import { TAddActiveInputConnectionToAudioNodeFactory } from '../types/add-active-input-connection-to-audio-node-factory';\n\nexport const createAddActiveInputConnectionToAudioNode: TAddActiveInputConnectionToAudioNodeFactory = (insertElementInSet) => {\n    return (activeInputs, source, [output, input, eventListener], ignoreDuplicates) => {\n        insertElementInSet(\n            activeInputs[input],\n            [source, output, eventListener],\n            (activeInputConnection) => activeInputConnection[0] === source && activeInputConnection[1] === output,\n            ignoreDuplicates\n        );\n    };\n};\n", "import { IAudioNode, IAudioNodeRenderer, IMinimalOfflineAudioContext, IOfflineAudioContext } from '../interfaces';\nimport { TActiveInputConnection, TAddAudioNodeConnectionsFactory, TContext, TNativeAudioNode } from '../types';\n\nexport const createAddAudioNodeConnections: TAddAudioNodeConnectionsFactory = (audioNodeConnectionsStore) => {\n    return <T extends TContext>(\n        audioNode: IAudioNode<T>,\n        audioNodeRenderer: T extends IMinimalOfflineAudioContext | IOfflineAudioContext ? IAudioNodeRenderer<T, IAudioNode<T>> : null,\n        nativeAudioNode: TNativeAudioNode\n    ) => {\n        const activeInputs = [];\n\n        for (let i = 0; i < nativeAudioNode.numberOfInputs; i += 1) {\n            activeInputs.push(new Set<TActiveInputConnection<T>>());\n        }\n\n        audioNodeConnectionsStore.set(audioNode, {\n            activeInputs,\n            outputs: new Set(),\n            passiveInputs: new WeakMap(),\n            renderer: audioNodeRenderer\n        });\n    };\n};\n", "import { IAudioParam, IAudioParamRenderer, IMinimalOfflineAudioContext, IOfflineAudioContext } from '../interfaces';\nimport { TAddAudioParamConnectionsFactory, TContext } from '../types';\n\nexport const createAddAudioParamConnections: TAddAudioParamConnectionsFactory = (audioParamConnectionsStore) => {\n    return <T extends TContext>(\n        audioParam: IAudioParam,\n        audioParamRenderer: T extends IMinimalOfflineAudioContext | IOfflineAudioContext ? IAudioParamRenderer : null\n    ) => {\n        audioParamConnectionsStore.set(audioParam, { activeInputs: new Set(), passiveInputs: new WeakMap(), renderer: audioParamRenderer });\n    };\n};\n", "import { IAudioNode, IAudioWorkletProcessor, IAudioWorkletProcessorConstructor } from './interfaces';\nimport {\n    TAudioNodeConnectionsStore,\n    TAudioNodeStore,\n    TAudioParamConnectionsStore,\n    TAudioParamStore,\n    TContext,\n    TContextStore,\n    TCycleCounters,\n    TInternalStateEventListener,\n    TNativeAudioWorkletNode,\n    TNativeContext\n} from './types';\n\nexport const ACTIVE_AUDIO_NODE_STORE: WeakSet<IAudioNode<TContext>> = new WeakSet();\n\nexport const AUDIO_NODE_CONNECTIONS_STORE: TAudioNodeConnectionsStore = new WeakMap();\n\nexport const AUDIO_NODE_STORE: TAudioNodeStore = new WeakMap();\n\nexport const AUDIO_PARAM_CONNECTIONS_STORE: TAudioParamConnectionsStore = new WeakMap();\n\nexport const AUDIO_PARAM_STORE: TAudioParamStore = new WeakMap();\n\nexport const CONTEXT_STORE: TContextStore = new WeakMap();\n\nexport const EVENT_LISTENERS: WeakMap<IAudioNode<TContext>, Set<TInternalStateEventListener>> = new WeakMap();\n\nexport const CYCLE_COUNTERS: TCycleCounters = new WeakMap();\n\n// This clunky name is borrowed from the spec. :-)\nexport const NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS: WeakMap<\n    TNativeContext,\n    Map<string, IAudioWorkletProcessorConstructor>\n> = new WeakMap();\n\nexport const NODE_TO_PROCESSOR_MAPS: WeakMap<\n    TNativeContext,\n    WeakMap<TNativeAudioWorkletNode, Promise<IAudioWorkletProcessor>>\n> = new WeakMap();\n", "import { TConstructor } from '../types';\n\nconst handler = {\n    construct(): any {\n        return handler;\n    }\n};\n\nexport const isConstructible = (constructible: TConstructor): boolean => {\n    try {\n        const proxy = new Proxy(constructible, handler);\n\n        new proxy(); // tslint:disable-line:no-unused-expression\n    } catch {\n        return false;\n    }\n\n    return true;\n};\n", "/*\n * This massive regex tries to cover all the following cases.\n *\n * import './path';\n * import defaultImport from './path';\n * import { namedImport } from './path';\n * import { namedImport as renamendImport } from './path';\n * import * as namespaceImport from './path';\n * import defaultImport, { namedImport } from './path';\n * import defaultImport, { namedImport as renamendImport } from './path';\n * import defaultImport, * as namespaceImport from './path';\n */\nconst IMPORT_STATEMENT_REGEX = /^import(?:(?:[\\s]+[\\w]+|(?:[\\s]+[\\w]+[\\s]*,)?[\\s]*\\{[\\s]*[\\w]+(?:[\\s]+as[\\s]+[\\w]+)?(?:[\\s]*,[\\s]*[\\w]+(?:[\\s]+as[\\s]+[\\w]+)?)*[\\s]*}|(?:[\\s]+[\\w]+[\\s]*,)?[\\s]*\\*[\\s]+as[\\s]+[\\w]+)[\\s]+from)?(?:[\\s]*)(\"([^\"\\\\]|\\\\.)+\"|'([^'\\\\]|\\\\.)+')(?:[\\s]*);?/; // tslint:disable-line:max-line-length\n\nexport const splitImportStatements = (source: string, url: string): [string, string] => {\n    const importStatements = [];\n\n    let sourceWithoutImportStatements = source.replace(/^[\\s]+/, '');\n    let result = sourceWithoutImportStatements.match(IMPORT_STATEMENT_REGEX);\n\n    while (result !== null) {\n        const unresolvedUrl = result[1].slice(1, -1);\n\n        const importStatementWithResolvedUrl = result[0]\n            .replace(/([\\s]+)?;?$/, '')\n            .replace(unresolvedUrl, new URL(unresolvedUrl, url).toString());\n        importStatements.push(importStatementWithResolvedUrl);\n\n        sourceWithoutImportStatements = sourceWithoutImportStatements.slice(result[0].length).replace(/^[\\s]+/, '');\n        result = sourceWithoutImportStatements.match(IMPORT_STATEMENT_REGEX);\n    }\n\n    return [importStatements.join(';'), sourceWithoutImportStatements];\n};\n", "import { NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS } from '../globals';\nimport { isConstructible } from '../helpers/is-constructible';\nimport { splitImportStatements } from '../helpers/split-import-statements';\nimport { IAudioWorkletProcessorConstructor } from '../interfaces';\nimport { TAddAudioWorkletModuleFactory, TEvaluateAudioWorkletGlobalScopeFunction } from '../types';\n\nconst verifyParameterDescriptors = (parameterDescriptors: IAudioWorkletProcessorConstructor['parameterDescriptors']) => {\n    if (parameterDescriptors !== undefined && !Array.isArray(parameterDescriptors)) {\n        throw new TypeError('The parameterDescriptors property of given value for processorCtor is not an array.');\n    }\n};\n\nconst verifyProcessorCtor = <T extends IAudioWorkletProcessorConstructor>(processorCtor: T) => {\n    if (!isConstructible(processorCtor)) {\n        throw new TypeError('The given value for processorCtor should be a constructor.');\n    }\n\n    if (processorCtor.prototype === null || typeof processorCtor.prototype !== 'object') {\n        throw new TypeError('The given value for processorCtor should have a prototype.');\n    }\n};\n\nexport const createAddAudioWorkletModule: TAddAudioWorkletModuleFactory = (\n    cacheTestResult,\n    createNotSupportedError,\n    evaluateSource,\n    exposeCurrentFrameAndCurrentTime,\n    fetchSource,\n    getNativeContext,\n    getOrCreateBackupOfflineAudioContext,\n    isNativeOfflineAudioContext,\n    nativeAudioWorkletNodeConstructor,\n    ongoingRequests,\n    resolvedRequests,\n    testAudioWorkletProcessorPostMessageSupport,\n    window\n) => {\n    let index = 0;\n\n    return (context, moduleURL, options = { credentials: 'omit' }) => {\n        const resolvedRequestsOfContext = resolvedRequests.get(context);\n\n        if (resolvedRequestsOfContext !== undefined && resolvedRequestsOfContext.has(moduleURL)) {\n            return Promise.resolve();\n        }\n\n        const ongoingRequestsOfContext = ongoingRequests.get(context);\n\n        if (ongoingRequestsOfContext !== undefined) {\n            const promiseOfOngoingRequest = ongoingRequestsOfContext.get(moduleURL);\n\n            if (promiseOfOngoingRequest !== undefined) {\n                return promiseOfOngoingRequest;\n            }\n        }\n\n        const nativeContext = getNativeContext(context);\n\n        // Bug #59: Safari does not implement the audioWorklet property.\n        const promise =\n            nativeContext.audioWorklet === undefined\n                ? fetchSource(moduleURL)\n                      .then(([source, absoluteUrl]) => {\n                          const [importStatements, sourceWithoutImportStatements] = splitImportStatements(source, absoluteUrl);\n\n                          /*\n                           * This is the unminified version of the code used below:\n                           *\n                           * ```js\n                           * ${ importStatements };\n                           * ((a, b) => {\n                           *     (a[b] = a[b] || [ ]).push(\n                           *         (AudioWorkletProcessor, global, registerProcessor, sampleRate, self, window) => {\n                           *             ${ sourceWithoutImportStatements }\n                           *         }\n                           *     );\n                           * })(window, '_AWGS');\n                           * ```\n                           */\n                          // tslint:disable-next-line:max-line-length\n                          const wrappedSource = `${importStatements};((a,b)=>{(a[b]=a[b]||[]).push((AudioWorkletProcessor,global,registerProcessor,sampleRate,self,window)=>{${sourceWithoutImportStatements}\n})})(window,'_AWGS')`;\n\n                          // @todo Evaluating the given source code is a possible security problem.\n                          return evaluateSource(wrappedSource);\n                      })\n                      .then(() => {\n                          const evaluateAudioWorkletGlobalScope = (<TEvaluateAudioWorkletGlobalScopeFunction[]>(<any>window)._AWGS).pop();\n\n                          if (evaluateAudioWorkletGlobalScope === undefined) {\n                              // Bug #182 Chrome and Edge do throw an instance of a SyntaxError instead of a DOMException.\n                              throw new SyntaxError();\n                          }\n\n                          exposeCurrentFrameAndCurrentTime(nativeContext.currentTime, nativeContext.sampleRate, () =>\n                              evaluateAudioWorkletGlobalScope(\n                                  class AudioWorkletProcessor {},\n                                  undefined,\n                                  (name, processorCtor) => {\n                                      if (name.trim() === '') {\n                                          throw createNotSupportedError();\n                                      }\n\n                                      const nodeNameToProcessorConstructorMap = NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS.get(nativeContext);\n\n                                      if (nodeNameToProcessorConstructorMap !== undefined) {\n                                          if (nodeNameToProcessorConstructorMap.has(name)) {\n                                              throw createNotSupportedError();\n                                          }\n\n                                          verifyProcessorCtor(processorCtor);\n                                          verifyParameterDescriptors(processorCtor.parameterDescriptors);\n\n                                          nodeNameToProcessorConstructorMap.set(name, processorCtor);\n                                      } else {\n                                          verifyProcessorCtor(processorCtor);\n                                          verifyParameterDescriptors(processorCtor.parameterDescriptors);\n\n                                          NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS.set(nativeContext, new Map([[name, processorCtor]]));\n                                      }\n                                  },\n                                  nativeContext.sampleRate,\n                                  undefined,\n                                  undefined\n                              )\n                          );\n                      })\n                : Promise.all([\n                      fetchSource(moduleURL),\n                      Promise.resolve(\n                          cacheTestResult(testAudioWorkletProcessorPostMessageSupport, testAudioWorkletProcessorPostMessageSupport)\n                      )\n                  ]).then(([[source, absoluteUrl], isSupportingPostMessage]) => {\n                      const currentIndex = index + 1;\n\n                      index = currentIndex;\n\n                      const [importStatements, sourceWithoutImportStatements] = splitImportStatements(source, absoluteUrl);\n                      /*\n                       * Bug #179: Firefox does not allow to transfer any buffer which has been passed to the process() method as an argument.\n                       *\n                       * This is the unminified version of the code used below.\n                       *\n                       * ```js\n                       * class extends AudioWorkletProcessor {\n                       *\n                       *     __buffers = new WeakSet();\n                       *\n                       *     constructor () {\n                       *         super();\n                       *\n                       *         this.port.postMessage = ((postMessage) => {\n                       *             return (message, transferables) => {\n                       *                 const filteredTransferables = (transferables)\n                       *                     ? transferables.filter((transferable) => !this.__buffers.has(transferable))\n                       *                     : transferables;\n                       *\n                       *                 return postMessage.call(this.port, message, filteredTransferables);\n                       *              };\n                       *         })(this.port.postMessage);\n                       *     }\n                       * }\n                       * ```\n                       */\n                      const patchedAudioWorkletProcessor = isSupportingPostMessage\n                          ? 'AudioWorkletProcessor'\n                          : 'class extends AudioWorkletProcessor {__b=new WeakSet();constructor(){super();(p=>p.postMessage=(q=>(m,t)=>q.call(p,m,t?t.filter(u=>!this.__b.has(u)):t))(p.postMessage))(this.port)}}';\n                      /*\n                       * Bug #170: Chrome and Edge do call process() with an array with empty channelData for each input if no input is connected.\n                       *\n                       * Bug #179: Firefox does not allow to transfer any buffer which has been passed to the process() method as an argument.\n                       *\n                       * Bug #190: Safari doesn't throw an error when loading an unparsable module.\n                       *\n                       * This is the unminified version of the code used below:\n                       *\n                       * ```js\n                       * `${ importStatements };\n                       * ((AudioWorkletProcessor, registerProcessor) => {${ sourceWithoutImportStatements }\n                       * })(\n                       *     ${\u00A0patchedAudioWorkletProcessor },\n                       *     (name, processorCtor) => registerProcessor(name, class extends processorCtor {\n                       *\n                       *         __collectBuffers = (array) => {\n                       *             array.forEach((element) => this.__buffers.add(element.buffer));\n                       *         };\n                       *\n                       *         process (inputs, outputs, parameters) {\n                       *             inputs.forEach(this.__collectBuffers);\n                       *             outputs.forEach(this.__collectBuffers);\n                       *             this.__collectBuffers(Object.values(parameters));\n                       *\n                       *             return super.process(\n                       *                 (inputs.map((input) => input.some((channelData) => channelData.length === 0)) ? [ ] : input),\n                       *                 outputs,\n                       *                 parameters\n                       *             );\n                       *         }\n                       *\n                       *     })\n                       * );\n                       *\n                       * registerProcessor(`__sac${currentIndex}`, class extends AudioWorkletProcessor{\n                       *\n                       *     process () {\n                       *         return false;\n                       *     }\n                       *\n                       * })`\n                       * ```\n                       */\n                      const memberDefinition = isSupportingPostMessage ? '' : '__c = (a) => a.forEach(e=>this.__b.add(e.buffer));';\n                      const bufferRegistration = isSupportingPostMessage\n                          ? ''\n                          : 'i.forEach(this.__c);o.forEach(this.__c);this.__c(Object.values(p));';\n                      const wrappedSource = `${importStatements};((AudioWorkletProcessor,registerProcessor)=>{${sourceWithoutImportStatements}\n})(${patchedAudioWorkletProcessor},(n,p)=>registerProcessor(n,class extends p{${memberDefinition}process(i,o,p){${bufferRegistration}return super.process(i.map(j=>j.some(k=>k.length===0)?[]:j),o,p)}}));registerProcessor('__sac${currentIndex}',class extends AudioWorkletProcessor{process(){return !1}})`;\n                      const blob = new Blob([wrappedSource], { type: 'application/javascript; charset=utf-8' });\n                      const url = URL.createObjectURL(blob);\n\n                      return nativeContext.audioWorklet\n                          .addModule(url, options)\n                          .then(() => {\n                              if (isNativeOfflineAudioContext(nativeContext)) {\n                                  return nativeContext;\n                              }\n\n                              // Bug #186: Chrome and Edge do not allow to create an AudioWorkletNode on a closed AudioContext.\n                              const backupOfflineAudioContext = getOrCreateBackupOfflineAudioContext(nativeContext);\n\n                              return backupOfflineAudioContext.audioWorklet.addModule(url, options).then(() => backupOfflineAudioContext);\n                          })\n                          .then((nativeContextOrBackupOfflineAudioContext) => {\n                              if (nativeAudioWorkletNodeConstructor === null) {\n                                  throw new SyntaxError();\n                              }\n\n                              try {\n                                  // Bug #190: Safari doesn't throw an error when loading an unparsable module.\n                                  new nativeAudioWorkletNodeConstructor(nativeContextOrBackupOfflineAudioContext, `__sac${currentIndex}`); // tslint:disable-line:no-unused-expression\n                              } catch {\n                                  throw new SyntaxError();\n                              }\n                          })\n                          .finally(() => URL.revokeObjectURL(url));\n                  });\n\n        if (ongoingRequestsOfContext === undefined) {\n            ongoingRequests.set(context, new Map([[moduleURL, promise]]));\n        } else {\n            ongoingRequestsOfContext.set(moduleURL, promise);\n        }\n\n        promise\n            .then(() => {\n                const updatedResolvedRequestsOfContext = resolvedRequests.get(context);\n\n                if (updatedResolvedRequestsOfContext === undefined) {\n                    resolvedRequests.set(context, new Set([moduleURL]));\n                } else {\n                    updatedResolvedRequestsOfContext.add(moduleURL);\n                }\n            })\n            .finally(() => {\n                const updatedOngoingRequestsOfContext = ongoingRequests.get(context);\n\n                if (updatedOngoingRequestsOfContext !== undefined) {\n                    updatedOngoingRequestsOfContext.delete(moduleURL);\n                }\n            });\n\n        return promise;\n    };\n};\n", "import { TGetValueForKeyFunction } from '../types';\n\nexport const getValueForKey: TGetValueForKeyFunction = (map, key) => {\n    const value = map.get(key);\n\n    if (value === undefined) {\n        throw new Error('A value with the given key could not be found.');\n    }\n\n    return value;\n};\n", "import { TPickElementFromSetFunction } from '../types';\n\nexport const pickElementFromSet: TPickElementFromSetFunction = (set, predicate) => {\n    const matchingElements = Array.from(set).filter(predicate);\n\n    if (matchingElements.length > 1) {\n        throw Error('More than one element was found.');\n    }\n\n    if (matchingElements.length === 0) {\n        throw Error('No element was found.');\n    }\n\n    const [matchingElement] = matchingElements;\n\n    set.delete(matchingElement);\n\n    return matchingElement;\n};\n", "import { IAudioNode } from '../interfaces';\nimport { TContext, TPassiveAudioNodeInputConnection } from '../types';\nimport { getValueForKey } from './get-value-for-key';\nimport { pickElementFromSet } from './pick-element-from-set';\n\nexport const deletePassiveInputConnectionToAudioNode = <T extends TContext>(\n    passiveInputs: WeakMap<IAudioNode<T>, Set<TPassiveAudioNodeInputConnection>>,\n    source: IAudioNode<T>,\n    output: number,\n    input: number\n) => {\n    const passiveInputConnections = getValueForKey(passiveInputs, source);\n    const matchingConnection = pickElementFromSet(\n        passiveInputConnections,\n        (passiveInputConnection) => passiveInputConnection[0] === output && passiveInputConnection[1] === input\n    );\n\n    if (passiveInputConnections.size === 0) {\n        passiveInputs.delete(source);\n    }\n\n    return matchingConnection;\n};\n", "import { EVENT_LISTENERS } from '../globals';\nimport { TGetEventListenersOfAudioNodeFunction } from '../types';\nimport { getValueForKey } from './get-value-for-key';\n\nexport const getEventListenersOfAudioNode: TGetEventListenersOfAudioNodeFunction = (audioNode) => {\n    return getValueForKey(EVENT_LISTENERS, audioNode);\n};\n", "import { ACTIVE_AUDIO_NODE_STORE } from '../globals';\nimport { IAudioNode } from '../interfaces';\nimport { TContext } from '../types';\nimport { getEventListenersOfAudioNode } from './get-event-listeners-of-audio-node';\n\nexport const setInternalStateToActive = <T extends TContext>(audioNode: IAudioNode<T>) => {\n    if (ACTIVE_AUDIO_NODE_STORE.has(audioNode)) {\n        throw new Error('The AudioNode is already stored.');\n    }\n\n    ACTIVE_AUDIO_NODE_STORE.add(audioNode);\n\n    getEventListenersOfAudioNode(audioNode).forEach((eventListener) => eventListener(true));\n};\n", "import { IAudioNode, IAudioWorkletNode } from '../interfaces';\nimport { TContext } from '../types';\n\nexport const isAudioWorkletNode = <T extends TContext>(audioNode: IAudioNode<T>): audioNode is IAudioWorkletNode<T> => {\n    return 'port' in audioNode;\n};\n", "import { ACTIVE_AUDIO_NODE_STORE } from '../globals';\nimport { IAudioNode } from '../interfaces';\nimport { TContext } from '../types';\nimport { getEventListenersOfAudioNode } from './get-event-listeners-of-audio-node';\n\nexport const setInternalStateToPassive = <T extends TContext>(audioNode: IAudioNode<T>) => {\n    if (!ACTIVE_AUDIO_NODE_STORE.has(audioNode)) {\n        throw new Error('The AudioNode is not stored.');\n    }\n\n    ACTIVE_AUDIO_NODE_STORE.delete(audioNode);\n\n    getEventListenersOfAudioNode(audioNode).forEach((eventListener) => eventListener(false));\n};\n", "import { isAudioWorkletNode } from '../guards/audio-worklet-node';\nimport { IAudioNode } from '../interfaces';\nimport { TActiveInputConnection, TContext } from '../types';\nimport { setInternalStateToPassive } from './set-internal-state-to-passive';\n\n// Set the internalState of the audioNode to 'passive' if it is not an AudioWorkletNode and if it has no 'active' input connections.\nexport const setInternalStateToPassiveWhenNecessary = <T extends TContext>(\n    audioNode: IAudioNode<T>,\n    activeInputs: Set<TActiveInputConnection<T>>[]\n) => {\n    if (!isAudioWorkletNode(audioNode) && activeInputs.every((connections) => connections.size === 0)) {\n        setInternalStateToPassive(audioNode);\n    }\n};\n", "import { deletePassiveInputConnectionToAudioNode } from '../helpers/delete-passive-input-connection-to-audio-node';\nimport { setInternalStateToActive } from '../helpers/set-internal-state-to-active';\nimport { setInternalStateToPassiveWhenNecessary } from '../helpers/set-internal-state-to-passive-when-necessary';\nimport { IAudioNode } from '../interfaces';\nimport { TAddConnectionToAudioNodeFactory, TContext, TInternalStateEventListener } from '../types';\n\nexport const createAddConnectionToAudioNode: TAddConnectionToAudioNodeFactory = (\n    addActiveInputConnectionToAudioNode,\n    addPassiveInputConnectionToAudioNode,\n    connectNativeAudioNodeToNativeAudioNode,\n    deleteActiveInputConnectionToAudioNode,\n    disconnectNativeAudioNodeFromNativeAudioNode,\n    getAudioNodeConnections,\n    getAudioNodeTailTime,\n    getEventListenersOfAudioNode,\n    getNativeAudioNode,\n    insertElementInSet,\n    isActiveAudioNode,\n    isPartOfACycle,\n    isPassiveAudioNode\n) => {\n    const tailTimeTimeoutIds = new WeakMap<IAudioNode<TContext>, number>();\n\n    return (source, destination, output, input, isOffline) => {\n        const { activeInputs, passiveInputs } = getAudioNodeConnections(destination);\n        const { outputs } = getAudioNodeConnections(source);\n        const eventListeners = getEventListenersOfAudioNode(source);\n\n        const eventListener: TInternalStateEventListener = (isActive) => {\n            const nativeDestinationAudioNode = getNativeAudioNode(destination);\n            const nativeSourceAudioNode = getNativeAudioNode(source);\n\n            if (isActive) {\n                const partialConnection = deletePassiveInputConnectionToAudioNode(passiveInputs, source, output, input);\n\n                addActiveInputConnectionToAudioNode(activeInputs, source, partialConnection, false);\n\n                if (!isOffline && !isPartOfACycle(source)) {\n                    connectNativeAudioNodeToNativeAudioNode(nativeSourceAudioNode, nativeDestinationAudioNode, output, input);\n                }\n\n                if (isPassiveAudioNode(destination)) {\n                    setInternalStateToActive(destination);\n                }\n            } else {\n                const partialConnection = deleteActiveInputConnectionToAudioNode(activeInputs, source, output, input);\n\n                addPassiveInputConnectionToAudioNode(passiveInputs, input, partialConnection, false);\n\n                if (!isOffline && !isPartOfACycle(source)) {\n                    disconnectNativeAudioNodeFromNativeAudioNode(nativeSourceAudioNode, nativeDestinationAudioNode, output, input);\n                }\n\n                const tailTime = getAudioNodeTailTime(destination);\n\n                if (tailTime === 0) {\n                    if (isActiveAudioNode(destination)) {\n                        setInternalStateToPassiveWhenNecessary(destination, activeInputs);\n                    }\n                } else {\n                    const tailTimeTimeoutId = tailTimeTimeoutIds.get(destination);\n\n                    if (tailTimeTimeoutId !== undefined) {\n                        clearTimeout(tailTimeTimeoutId);\n                    }\n\n                    tailTimeTimeoutIds.set(\n                        destination,\n                        setTimeout(() => {\n                            if (isActiveAudioNode(destination)) {\n                                setInternalStateToPassiveWhenNecessary(destination, activeInputs);\n                            }\n                        }, tailTime * 1000)\n                    );\n                }\n            }\n        };\n\n        if (\n            insertElementInSet(\n                outputs,\n                [destination, output, input],\n                (outputConnection) =>\n                    outputConnection[0] === destination && outputConnection[1] === output && outputConnection[2] === input,\n                true\n            )\n        ) {\n            eventListeners.add(eventListener);\n\n            if (isActiveAudioNode(source)) {\n                addActiveInputConnectionToAudioNode(activeInputs, source, [output, input, eventListener], true);\n            } else {\n                addPassiveInputConnectionToAudioNode(passiveInputs, input, [source, output, eventListener], true);\n            }\n\n            return true;\n        }\n\n        return false;\n    };\n};\n", "import { TAddPassiveInputConnectionToAudioNodeFactory } from '../types';\n\nexport const createAddPassiveInputConnectionToAudioNode: TAddPassiveInputConnectionToAudioNodeFactory = (insertElementInSet) => {\n    return (passiveInputs, input, [source, output, eventListener], ignoreDuplicates) => {\n        const passiveInputConnections = passiveInputs.get(source);\n\n        if (passiveInputConnections === undefined) {\n            passiveInputs.set(source, new Set([[output, input, eventListener]]));\n        } else {\n            insertElementInSet(\n                passiveInputConnections,\n                [output, input, eventListener],\n                (passiveInputConnection) => passiveInputConnection[0] === output && passiveInputConnection[1] === input,\n                ignoreDuplicates\n            );\n        }\n    };\n};\n", "import { TAddSilentConnectionFactory } from '../types';\n\nexport const createAddSilentConnection: TAddSilentConnectionFactory = (createNativeGainNode) => {\n    return (nativeContext, nativeAudioScheduledSourceNode) => {\n        const nativeGainNode = createNativeGainNode(nativeContext, {\n            channelCount: 1,\n            channelCountMode: 'explicit',\n            channelInterpretation: 'discrete',\n            gain: 0\n        });\n\n        nativeAudioScheduledSourceNode.connect(nativeGainNode).connect(nativeContext.destination);\n\n        const disconnect = () => {\n            nativeAudioScheduledSourceNode.removeEventListener('ended', disconnect);\n            nativeAudioScheduledSourceNode.disconnect(nativeGainNode);\n            nativeGainNode.disconnect();\n        };\n\n        nativeAudioScheduledSourceNode.addEventListener('ended', disconnect);\n    };\n};\n", "import { TAddUnrenderedAudioWorkletNodeFactory } from '../types';\n\nexport const createAddUnrenderedAudioWorkletNode: TAddUnrenderedAudioWorkletNodeFactory = (getUnrenderedAudioWorkletNodes) => {\n    return (nativeContext, audioWorkletNode) => {\n        getUnrenderedAudioWorkletNodes(nativeContext).add(audioWorkletNode);\n    };\n};\n", "import { IAnalyserNode, IAnalyserOptions } from '../interfaces';\nimport { TAnalyserNodeConstructorFactory, TAudioNodeRenderer, TContext, TNativeAnalyserNode } from '../types';\n\nconst DEFAULT_OPTIONS = {\n    channelCount: 2,\n    channelCountMode: 'max',\n    channelInterpretation: 'speakers',\n    fftSize: 2048,\n    maxDecibels: -30,\n    minDecibels: -100,\n    smoothingTimeConstant: 0.8\n} as const;\n\nexport const createAnalyserNodeConstructor: TAnalyserNodeConstructorFactory = (\n    audionNodeConstructor,\n    createAnalyserNodeRenderer,\n    createIndexSizeError,\n    createNativeAnalyserNode,\n    getNativeContext,\n    isNativeOfflineAudioContext\n) => {\n    return class AnalyserNode<T extends TContext> extends audionNodeConstructor<T> implements IAnalyserNode<T> {\n        private _nativeAnalyserNode: TNativeAnalyserNode;\n\n        constructor(context: T, options?: Partial<IAnalyserOptions>) {\n            const nativeContext = getNativeContext(context);\n            const mergedOptions = { ...DEFAULT_OPTIONS, ...options };\n            const nativeAnalyserNode = createNativeAnalyserNode(nativeContext, mergedOptions);\n            const analyserNodeRenderer = <TAudioNodeRenderer<T, this>>(\n                (isNativeOfflineAudioContext(nativeContext) ? createAnalyserNodeRenderer() : null)\n            );\n\n            super(context, false, nativeAnalyserNode, analyserNodeRenderer);\n\n            this._nativeAnalyserNode = nativeAnalyserNode;\n        }\n\n        get fftSize(): number {\n            return this._nativeAnalyserNode.fftSize;\n        }\n\n        set fftSize(value) {\n            this._nativeAnalyserNode.fftSize = value;\n        }\n\n        get frequencyBinCount(): number {\n            return this._nativeAnalyserNode.frequencyBinCount;\n        }\n\n        get maxDecibels(): number {\n            return this._nativeAnalyserNode.maxDecibels;\n        }\n\n        set maxDecibels(value) {\n            // Bug #118: Safari does not throw an error if maxDecibels is not more than minDecibels.\n            const maxDecibels = this._nativeAnalyserNode.maxDecibels;\n\n            this._nativeAnalyserNode.maxDecibels = value;\n\n            if (!(value > this._nativeAnalyserNode.minDecibels)) {\n                this._nativeAnalyserNode.maxDecibels = maxDecibels;\n\n                throw createIndexSizeError();\n            }\n        }\n\n        get minDecibels(): number {\n            return this._nativeAnalyserNode.minDecibels;\n        }\n\n        set minDecibels(value) {\n            // Bug #118: Safari does not throw an error if maxDecibels is not more than minDecibels.\n            const minDecibels = this._nativeAnalyserNode.minDecibels;\n\n            this._nativeAnalyserNode.minDecibels = value;\n\n            if (!(this._nativeAnalyserNode.maxDecibels > value)) {\n                this._nativeAnalyserNode.minDecibels = minDecibels;\n\n                throw createIndexSizeError();\n            }\n        }\n\n        get smoothingTimeConstant(): number {\n            return this._nativeAnalyserNode.smoothingTimeConstant;\n        }\n\n        set smoothingTimeConstant(value) {\n            this._nativeAnalyserNode.smoothingTimeConstant = value;\n        }\n\n        public getByteFrequencyData(array: Uint8Array): void {\n            this._nativeAnalyserNode.getByteFrequencyData(array);\n        }\n\n        public getByteTimeDomainData(array: Uint8Array): void {\n            this._nativeAnalyserNode.getByteTimeDomainData(array);\n        }\n\n        public getFloatFrequencyData(array: Float32Array): void {\n            this._nativeAnalyserNode.getFloatFrequencyData(array);\n        }\n\n        public getFloatTimeDomainData(array: Float32Array): void {\n            this._nativeAnalyserNode.getFloatTimeDomainData(array);\n        }\n    };\n};\n", "import { TNativeAudioNode, TNativeContext } from '../types';\n\nexport const isOwnedByContext = (nativeAudioNode: TNativeAudioNode, nativeContext: TNativeContext): boolean => {\n    return nativeAudioNode.context === nativeContext;\n};\n", "import { isOwnedByContext } from '../helpers/is-owned-by-context';\nimport { IAnalyserNode, IMinimalOfflineAudioContext, IOfflineAudioContext } from '../interfaces';\nimport { TAnalyserNodeRendererFactoryFactory, TNativeAnalyserNode, TNativeOfflineAudioContext } from '../types';\n\nexport const createAnalyserNodeRendererFactory: TAnalyserNodeRendererFactoryFactory = (\n    createNativeAnalyserNode,\n    getNativeAudioNode,\n    renderInputsOfAudioNode\n) => {\n    return <T extends IMinimalOfflineAudioContext | IOfflineAudioContext>() => {\n        const renderedNativeAnalyserNodes = new WeakMap<TNativeOfflineAudioContext, TNativeAnalyserNode>();\n\n        const createAnalyserNode = async (proxy: IAnalyserNode<T>, nativeOfflineAudioContext: TNativeOfflineAudioContext) => {\n            let nativeAnalyserNode = getNativeAudioNode<T, TNativeAnalyserNode>(proxy);\n\n            // If the initially used nativeAnalyserNode was not constructed on the same OfflineAudioContext it needs to be created again.\n            const nativeAnalyserNodeIsOwnedByContext = isOwnedByContext(nativeAnalyserNode, nativeOfflineAudioContext);\n\n            if (!nativeAnalyserNodeIsOwnedByContext) {\n                const options = {\n                    channelCount: nativeAnalyserNode.channelCount,\n                    channelCountMode: nativeAnalyserNode.channelCountMode,\n                    channelInterpretation: nativeAnalyserNode.channelInterpretation,\n                    fftSize: nativeAnalyserNode.fftSize,\n                    maxDecibels: nativeAnalyserNode.maxDecibels,\n                    minDecibels: nativeAnalyserNode.minDecibels,\n                    smoothingTimeConstant: nativeAnalyserNode.smoothingTimeConstant\n                };\n\n                nativeAnalyserNode = createNativeAnalyserNode(nativeOfflineAudioContext, options);\n            }\n\n            renderedNativeAnalyserNodes.set(nativeOfflineAudioContext, nativeAnalyserNode);\n\n            await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeAnalyserNode);\n\n            return nativeAnalyserNode;\n        };\n\n        return {\n            render(proxy: IAnalyserNode<T>, nativeOfflineAudioContext: TNativeOfflineAudioContext): Promise<TNativeAnalyserNode> {\n                const renderedNativeAnalyserNode = renderedNativeAnalyserNodes.get(nativeOfflineAudioContext);\n\n                if (renderedNativeAnalyserNode !== undefined) {\n                    return Promise.resolve(renderedNativeAnalyserNode);\n                }\n\n                return createAnalyserNode(proxy, nativeOfflineAudioContext);\n            }\n        };\n    };\n};\n", "import { TNativeAudioBuffer } from '../types';\n\nexport const testAudioBufferCopyChannelMethodsOutOfBoundsSupport = (nativeAudioBuffer: TNativeAudioBuffer): boolean => {\n    try {\n        nativeAudioBuffer.copyToChannel(new Float32Array(1), 0, -1);\n    } catch {\n        return false;\n    }\n\n    return true;\n};\n", "import { TIndexSizeErrorFactory } from '../types';\n\nexport const createIndexSizeError: TIndexSizeErrorFactory = () => new DOMException('', 'IndexSizeError');\n", "import { createIndexSizeError } from '../factories/index-size-error';\nimport { TNativeAudioBuffer } from '../types';\n\nexport const wrapAudioBufferGetChannelDataMethod = (audioBuffer: TNativeAudioBuffer): void => {\n    audioBuffer.getChannelData = ((getChannelData) => {\n        return (channel: number) => {\n            try {\n                return getChannelData.call(audioBuffer, channel);\n            } catch (err) {\n                if (err.code === 12) {\n                    throw createIndexSizeError();\n                }\n\n                throw err;\n            }\n        };\n    })(audioBuffer.getChannelData);\n};\n", "import { testAudioBufferCopyChannelMethodsOutOfBoundsSupport } from '../helpers/test-audio-buffer-copy-channel-methods-out-of-bounds-support';\nimport { wrapAudioBufferGetChannelDataMethod } from '../helpers/wrap-audio-buffer-get-channel-data-method';\nimport { IAudioBuffer, IAudioBufferOptions } from '../interfaces';\nimport { TAudioBufferConstructorFactory, TNativeOfflineAudioContext } from '../types';\n\nconst DEFAULT_OPTIONS = {\n    numberOfChannels: 1\n} as const;\n\nexport const createAudioBufferConstructor: TAudioBufferConstructorFactory = (\n    audioBufferStore,\n    cacheTestResult,\n    createNotSupportedError,\n    nativeAudioBufferConstructor,\n    nativeOfflineAudioContextConstructor,\n    testNativeAudioBufferConstructorSupport,\n    wrapAudioBufferCopyChannelMethods,\n    wrapAudioBufferCopyChannelMethodsOutOfBounds\n) => {\n    let nativeOfflineAudioContext: null | TNativeOfflineAudioContext = null;\n\n    return class AudioBuffer implements IAudioBuffer {\n        // This field needs to be defined to convince TypeScript that the IAudioBuffer will be implemented.\n        public copyFromChannel!: (destination: Float32Array, channelNumber: number, bufferOffset?: number) => void;\n\n        // This field needs to be defined to convince TypeScript that the IAudioBuffer will be implemented.\n        public copyToChannel!: (source: Float32Array, channelNumber: number, bufferOffset?: number) => void;\n\n        // This field needs to be defined to convince TypeScript that the IAudioBuffer will be implemented.\n        public duration!: number;\n\n        // This field needs to be defined to convince TypeScript that the IAudioBuffer will be implemented.\n        public getChannelData!: (channel: number) => Float32Array;\n\n        // This field needs to be defined to convince TypeScript that the IAudioBuffer will be implemented.\n        public length!: number;\n\n        // This field needs to be defined to convince TypeScript that the IAudioBuffer will be implemented.\n        public numberOfChannels!: number;\n\n        // This field needs to be defined to convince TypeScript that the IAudioBuffer will be implemented.\n        public sampleRate!: number;\n\n        constructor(options: IAudioBufferOptions) {\n            if (nativeOfflineAudioContextConstructor === null) {\n                throw new Error('Missing the native OfflineAudioContext constructor.');\n            }\n\n            const { length, numberOfChannels, sampleRate } = { ...DEFAULT_OPTIONS, ...options };\n\n            if (nativeOfflineAudioContext === null) {\n                nativeOfflineAudioContext = new nativeOfflineAudioContextConstructor(1, 1, 44100);\n            }\n\n            /*\n             * Bug #99: Firefox does not throw a NotSupportedError when the numberOfChannels is zero. But it only does it when using the\n             * factory function. But since Firefox also supports the constructor everything should be fine.\n             */\n            const audioBuffer =\n                nativeAudioBufferConstructor !== null &&\n                cacheTestResult(testNativeAudioBufferConstructorSupport, testNativeAudioBufferConstructorSupport)\n                    ? new nativeAudioBufferConstructor({ length, numberOfChannels, sampleRate })\n                    : nativeOfflineAudioContext.createBuffer(numberOfChannels, length, sampleRate);\n\n            // Bug #99: Safari does not throw an error when the numberOfChannels is zero.\n            if (audioBuffer.numberOfChannels === 0) {\n                throw createNotSupportedError();\n            }\n\n            // Bug #5: Safari does not support copyFromChannel() and copyToChannel().\n            // Bug #100: Safari does throw a wrong error when calling getChannelData() with an out-of-bounds value.\n            if (typeof audioBuffer.copyFromChannel !== 'function') {\n                wrapAudioBufferCopyChannelMethods(audioBuffer);\n                wrapAudioBufferGetChannelDataMethod(audioBuffer);\n                // Bug #157: Firefox does not allow the bufferOffset to be out-of-bounds.\n            } else if (\n                !cacheTestResult(testAudioBufferCopyChannelMethodsOutOfBoundsSupport, () =>\n                    testAudioBufferCopyChannelMethodsOutOfBoundsSupport(audioBuffer)\n                )\n            ) {\n                wrapAudioBufferCopyChannelMethodsOutOfBounds(audioBuffer);\n            }\n\n            audioBufferStore.add(audioBuffer);\n\n            /*\n             * This does violate all good pratices but it is necessary to allow this AudioBuffer to be used with native\n             * (Offline)AudioContexts.\n             */\n            return audioBuffer;\n        }\n\n        public static [Symbol.hasInstance](instance: unknown): boolean {\n            return (\n                (instance !== null && typeof instance === 'object' && Object.getPrototypeOf(instance) === AudioBuffer.prototype) ||\n                audioBufferStore.has(<any>instance)\n            );\n        }\n    };\n};\n", "export const MOST_NEGATIVE_SINGLE_FLOAT = -3.4028234663852886e38;\n\nexport const MOST_POSITIVE_SINGLE_FLOAT = -MOST_NEGATIVE_SINGLE_FLOAT;\n", "import { ACTIVE_AUDIO_NODE_STORE } from '../globals';\nimport { TIsActiveAudioNodeFunction } from '../types';\n\nexport const isActiveAudioNode: TIsActiveAudioNodeFunction = (audioNode) => ACTIVE_AUDIO_NODE_STORE.has(audioNode);\n", "import { MOST_NEGATIVE_SINGLE_FLOAT, MOST_POSITIVE_SINGLE_FLOAT } from '../constants';\nimport { isActiveAudioNode } from '../helpers/is-active-audio-node';\nimport { setInternalStateToActive } from '../helpers/set-internal-state-to-active';\nimport { setInternalStateToPassive } from '../helpers/set-internal-state-to-passive';\nimport { IAudioBufferSourceNode, IAudioBufferSourceOptions, IAudioParam, IAudioScheduledSourceNodeEventMap } from '../interfaces';\nimport {\n    TAnyAudioBuffer,\n    TAudioBufferSourceNodeConstructorFactory,\n    TAudioBufferSourceNodeRenderer,\n    TContext,\n    TEventHandler,\n    TNativeAudioBufferSourceNode\n} from '../types';\n\nconst DEFAULT_OPTIONS = {\n    buffer: null,\n    channelCount: 2,\n    channelCountMode: 'max',\n    channelInterpretation: 'speakers',\n    // Bug #149: Safari does not yet support the detune AudioParam.\n    loop: false,\n    loopEnd: 0,\n    loopStart: 0,\n    playbackRate: 1\n} as const;\n\nexport const createAudioBufferSourceNodeConstructor: TAudioBufferSourceNodeConstructorFactory = (\n    audioNodeConstructor,\n    createAudioBufferSourceNodeRenderer,\n    createAudioParam,\n    createInvalidStateError,\n    createNativeAudioBufferSourceNode,\n    getNativeContext,\n    isNativeOfflineAudioContext,\n    wrapEventListener\n) => {\n    return class AudioBufferSourceNode<T extends TContext>\n        extends audioNodeConstructor<T, IAudioScheduledSourceNodeEventMap>\n        implements IAudioBufferSourceNode<T>\n    {\n        private _audioBufferSourceNodeRenderer: TAudioBufferSourceNodeRenderer<T>;\n\n        private _isBufferNullified: boolean;\n\n        private _isBufferSet: boolean;\n\n        private _nativeAudioBufferSourceNode: TNativeAudioBufferSourceNode;\n\n        private _onended: null | TEventHandler<this>;\n\n        private _playbackRate: IAudioParam;\n\n        constructor(context: T, options?: Partial<IAudioBufferSourceOptions>) {\n            const nativeContext = getNativeContext(context);\n            const mergedOptions = { ...DEFAULT_OPTIONS, ...options };\n            const nativeAudioBufferSourceNode = createNativeAudioBufferSourceNode(nativeContext, mergedOptions);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            const audioBufferSourceNodeRenderer = <TAudioBufferSourceNodeRenderer<T>>(\n                (isOffline ? createAudioBufferSourceNodeRenderer() : null)\n            );\n\n            super(context, false, nativeAudioBufferSourceNode, audioBufferSourceNodeRenderer);\n\n            this._audioBufferSourceNodeRenderer = audioBufferSourceNodeRenderer;\n            this._isBufferNullified = false;\n            this._isBufferSet = mergedOptions.buffer !== null;\n            this._nativeAudioBufferSourceNode = nativeAudioBufferSourceNode;\n            this._onended = null;\n            // Bug #73: Safari does not export the correct values for maxValue and minValue.\n            this._playbackRate = createAudioParam(\n                this,\n                isOffline,\n                nativeAudioBufferSourceNode.playbackRate,\n                MOST_POSITIVE_SINGLE_FLOAT,\n                MOST_NEGATIVE_SINGLE_FLOAT\n            );\n        }\n\n        get buffer(): null | TAnyAudioBuffer {\n            if (this._isBufferNullified) {\n                return null;\n            }\n\n            return this._nativeAudioBufferSourceNode.buffer;\n        }\n\n        set buffer(value) {\n            this._nativeAudioBufferSourceNode.buffer = value;\n\n            // Bug #72: Only Chrome & Edge do not allow to reassign the buffer yet.\n            if (value !== null) {\n                if (this._isBufferSet) {\n                    throw createInvalidStateError();\n                }\n\n                this._isBufferSet = true;\n            }\n        }\n\n        get loop(): boolean {\n            return this._nativeAudioBufferSourceNode.loop;\n        }\n\n        set loop(value) {\n            this._nativeAudioBufferSourceNode.loop = value;\n        }\n\n        get loopEnd(): number {\n            return this._nativeAudioBufferSourceNode.loopEnd;\n        }\n\n        set loopEnd(value) {\n            this._nativeAudioBufferSourceNode.loopEnd = value;\n        }\n\n        get loopStart(): number {\n            return this._nativeAudioBufferSourceNode.loopStart;\n        }\n\n        set loopStart(value) {\n            this._nativeAudioBufferSourceNode.loopStart = value;\n        }\n\n        get onended(): null | TEventHandler<this> {\n            return this._onended;\n        }\n\n        set onended(value) {\n            const wrappedListener = typeof value === 'function' ? wrapEventListener(this, value) : null;\n\n            this._nativeAudioBufferSourceNode.onended = wrappedListener;\n\n            const nativeOnEnded = this._nativeAudioBufferSourceNode.onended;\n\n            this._onended = nativeOnEnded !== null && nativeOnEnded === wrappedListener ? value : nativeOnEnded;\n        }\n\n        get playbackRate(): IAudioParam {\n            return this._playbackRate;\n        }\n\n        public start(when = 0, offset = 0, duration?: number): void {\n            this._nativeAudioBufferSourceNode.start(when, offset, duration);\n\n            if (this._audioBufferSourceNodeRenderer !== null) {\n                this._audioBufferSourceNodeRenderer.start = duration === undefined ? [when, offset] : [when, offset, duration];\n            }\n\n            if (this.context.state !== 'closed') {\n                setInternalStateToActive(this);\n\n                const resetInternalStateToPassive = () => {\n                    this._nativeAudioBufferSourceNode.removeEventListener('ended', resetInternalStateToPassive);\n\n                    if (isActiveAudioNode(this)) {\n                        setInternalStateToPassive(this);\n                    }\n                };\n\n                this._nativeAudioBufferSourceNode.addEventListener('ended', resetInternalStateToPassive);\n            }\n        }\n\n        public stop(when = 0): void {\n            this._nativeAudioBufferSourceNode.stop(when);\n\n            if (this._audioBufferSourceNodeRenderer !== null) {\n                this._audioBufferSourceNodeRenderer.stop = when;\n            }\n        }\n    };\n};\n", "import { isOwnedByContext } from '../helpers/is-owned-by-context';\nimport { IAudioBufferSourceNode, IMinimalOfflineAudioContext, IOfflineAudioContext } from '../interfaces';\nimport { TAudioBufferSourceNodeRendererFactoryFactory, TNativeAudioBufferSourceNode, TNativeOfflineAudioContext } from '../types';\n\nexport const createAudioBufferSourceNodeRendererFactory: TAudioBufferSourceNodeRendererFactoryFactory = (\n    connectAudioParam,\n    createNativeAudioBufferSourceNode,\n    getNativeAudioNode,\n    renderAutomation,\n    renderInputsOfAudioNode\n) => {\n    return <T extends IMinimalOfflineAudioContext | IOfflineAudioContext>() => {\n        const renderedNativeAudioBufferSourceNodes = new WeakMap<TNativeOfflineAudioContext, TNativeAudioBufferSourceNode>();\n\n        let start: null | [number, number] | [number, number, number] = null;\n        let stop: null | number = null;\n\n        const createAudioBufferSourceNode = async (\n            proxy: IAudioBufferSourceNode<T>,\n            nativeOfflineAudioContext: TNativeOfflineAudioContext\n        ) => {\n            let nativeAudioBufferSourceNode = getNativeAudioNode<T, TNativeAudioBufferSourceNode>(proxy);\n\n            /*\n             * If the initially used nativeAudioBufferSourceNode was not constructed on the same OfflineAudioContext it needs to be created\n             * again.\n             */\n            const nativeAudioBufferSourceNodeIsOwnedByContext = isOwnedByContext(nativeAudioBufferSourceNode, nativeOfflineAudioContext);\n\n            if (!nativeAudioBufferSourceNodeIsOwnedByContext) {\n                const options = {\n                    buffer: nativeAudioBufferSourceNode.buffer,\n                    channelCount: nativeAudioBufferSourceNode.channelCount,\n                    channelCountMode: nativeAudioBufferSourceNode.channelCountMode,\n                    channelInterpretation: nativeAudioBufferSourceNode.channelInterpretation,\n                    // Bug #149: Safari does not yet support the detune AudioParam.\n                    loop: nativeAudioBufferSourceNode.loop,\n                    loopEnd: nativeAudioBufferSourceNode.loopEnd,\n                    loopStart: nativeAudioBufferSourceNode.loopStart,\n                    playbackRate: nativeAudioBufferSourceNode.playbackRate.value\n                };\n\n                nativeAudioBufferSourceNode = createNativeAudioBufferSourceNode(nativeOfflineAudioContext, options);\n\n                if (start !== null) {\n                    nativeAudioBufferSourceNode.start(...start);\n                }\n\n                if (stop !== null) {\n                    nativeAudioBufferSourceNode.stop(stop);\n                }\n            }\n\n            renderedNativeAudioBufferSourceNodes.set(nativeOfflineAudioContext, nativeAudioBufferSourceNode);\n\n            if (!nativeAudioBufferSourceNodeIsOwnedByContext) {\n                // Bug #149: Safari does not yet support the detune AudioParam.\n                await renderAutomation(nativeOfflineAudioContext, proxy.playbackRate, nativeAudioBufferSourceNode.playbackRate);\n            } else {\n                // Bug #149: Safari does not yet support the detune AudioParam.\n                await connectAudioParam(nativeOfflineAudioContext, proxy.playbackRate, nativeAudioBufferSourceNode.playbackRate);\n            }\n\n            await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeAudioBufferSourceNode);\n\n            return nativeAudioBufferSourceNode;\n        };\n\n        return {\n            set start(value: [number, number] | [number, number, number]) {\n                start = value;\n            },\n            set stop(value: number) {\n                stop = value;\n            },\n            render(\n                proxy: IAudioBufferSourceNode<T>,\n                nativeOfflineAudioContext: TNativeOfflineAudioContext\n            ): Promise<TNativeAudioBufferSourceNode> {\n                const renderedNativeAudioBufferSourceNode = renderedNativeAudioBufferSourceNodes.get(nativeOfflineAudioContext);\n\n                if (renderedNativeAudioBufferSourceNode !== undefined) {\n                    return Promise.resolve(renderedNativeAudioBufferSourceNode);\n                }\n\n                return createAudioBufferSourceNode(proxy, nativeOfflineAudioContext);\n            }\n        };\n    };\n};\n", "import { IAudioBufferSourceNode, IAudioNode } from '../interfaces';\nimport { TContext } from '../types';\n\nexport const isAudioBufferSourceNode = <T extends TContext>(audioNode: IAudioNode<T>): audioNode is IAudioBufferSourceNode<T> => {\n    return 'playbackRate' in audioNode;\n};\n", "import { IAudioNode, IBiquadFilterNode } from '../interfaces';\nimport { TContext } from '../types';\n\nexport const isBiquadFilterNode = <T extends TContext>(audioNode: IAudioNode<T>): audioNode is IBiquadFilterNode<T> => {\n    return 'frequency' in audioNode && 'gain' in audioNode;\n};\n", "import { IAudioNode, IConstantSourceNode } from '../interfaces';\nimport { TContext } from '../types';\n\nexport const isConstantSourceNode = <T extends TContext>(audioNode: IAudioNode<T>): audioNode is IConstantSourceNode<T> => {\n    return 'offset' in audioNode;\n};\n", "import { IAudioNode, IGainNode } from '../interfaces';\nimport { TContext } from '../types';\n\nexport const isGainNode = <T extends TContext>(audioNode: IAudioNode<T>): audioNode is IGainNode<T> => {\n    return !('frequency' in audioNode) && 'gain' in audioNode;\n};\n", "import { IAudioNode, IOscillatorNode } from '../interfaces';\nimport { TContext } from '../types';\n\nexport const isOscillatorNode = <T extends TContext>(audioNode: IAudioNode<T>): audioNode is IOscillatorNode<T> => {\n    return 'detune' in audioNode && 'frequency' in audioNode;\n};\n", "import { IAudioNode, IStereoPannerNode } from '../interfaces';\nimport { TContext } from '../types';\n\nexport const isStereoPannerNode = <T extends TContext>(audioNode: IAudioNode<T>): audioNode is IStereoPannerNode<T> => {\n    return 'pan' in audioNode;\n};\n", "import { AUDIO_NODE_CONNECTIONS_STORE } from '../globals';\nimport { IAudioNode } from '../interfaces';\nimport { TAudioNodeConnections, TContext, TGetAudioNodeConnectionsFunction } from '../types';\nimport { getValueForKey } from './get-value-for-key';\n\nexport const getAudioNodeConnections: TGetAudioNodeConnectionsFunction = <T extends TContext>(\n    audioNode: IAudioNode<T>\n): TAudioNodeConnections<T> => {\n    return <TAudioNodeConnections<T>>getValueForKey(AUDIO_NODE_CONNECTIONS_STORE, audioNode);\n};\n", "import { AUDIO_PARAM_CONNECTIONS_STORE } from '../globals';\nimport { IAudioParam } from '../interfaces';\nimport { TAudioParamConnections, TContext, TGetAudioParamConnectionsFunction } from '../types';\nimport { getValueForKey } from './get-value-for-key';\n\nexport const getAudioParamConnections: TGetAudioParamConnectionsFunction = <T extends TContext>(\n    audioParam: IAudioParam\n): TAudioParamConnections<T> => {\n    return <TAudioParamConnections<T>>getValueForKey(AUDIO_PARAM_CONNECTIONS_STORE, audioParam);\n};\n", "import { isAudioBufferSourceNode } from '../guards/audio-buffer-source-node';\nimport { isAudioWorkletNode } from '../guards/audio-worklet-node';\nimport { isBiquadFilterNode } from '../guards/biquad-filter-node';\nimport { isConstantSourceNode } from '../guards/constant-source-node';\nimport { isGainNode } from '../guards/gain-node';\nimport { isOscillatorNode } from '../guards/oscillator-node';\nimport { isStereoPannerNode } from '../guards/stereo-panner-node';\nimport { IAudioNode } from '../interfaces';\nimport { TContext } from '../types';\nimport { getAudioNodeConnections } from './get-audio-node-connections';\nimport { getAudioParamConnections } from './get-audio-param-connections';\nimport { isActiveAudioNode } from './is-active-audio-node';\nimport { setInternalStateToPassive } from './set-internal-state-to-passive';\n\nexport const deactivateActiveAudioNodeInputConnections = <T extends TContext>(\n    audioNode: IAudioNode<T>,\n    trace: readonly IAudioNode<T>[]\n) => {\n    const { activeInputs } = getAudioNodeConnections(audioNode);\n\n    activeInputs.forEach((connections) =>\n        connections.forEach(([source]) => {\n            if (!trace.includes(audioNode)) {\n                deactivateActiveAudioNodeInputConnections(source, [...trace, audioNode]);\n            }\n        })\n    );\n\n    const audioParams = isAudioBufferSourceNode(audioNode)\n        ? [\n              // Bug #149: Safari does not yet support the detune AudioParam.\n              audioNode.playbackRate\n          ]\n        : isAudioWorkletNode(audioNode)\n        ? Array.from(audioNode.parameters.values())\n        : isBiquadFilterNode(audioNode)\n        ? [audioNode.Q, audioNode.detune, audioNode.frequency, audioNode.gain]\n        : isConstantSourceNode(audioNode)\n        ? [audioNode.offset]\n        : isGainNode(audioNode)\n        ? [audioNode.gain]\n        : isOscillatorNode(audioNode)\n        ? [audioNode.detune, audioNode.frequency]\n        : isStereoPannerNode(audioNode)\n        ? [audioNode.pan]\n        : [];\n\n    for (const audioParam of audioParams) {\n        const audioParamConnections = getAudioParamConnections<T>(audioParam);\n\n        if (audioParamConnections !== undefined) {\n            audioParamConnections.activeInputs.forEach(([source]) => deactivateActiveAudioNodeInputConnections(source, trace));\n        }\n    }\n\n    if (isActiveAudioNode(audioNode)) {\n        setInternalStateToPassive(audioNode);\n    }\n};\n", "import { IAudioDestinationNode } from '../interfaces';\nimport { TContext } from '../types';\nimport { deactivateActiveAudioNodeInputConnections } from './deactivate-active-audio-node-input-connections';\n\nexport const deactivateAudioGraph = <T extends TContext>(context: T): void => {\n    deactivateActiveAudioNodeInputConnections(<IAudioDestinationNode<T>>context.destination, []);\n};\n", "import { IAudioContextOptions } from '../interfaces';\n\nexport const isValidLatencyHint = (latencyHint: IAudioContextOptions['latencyHint']) => {\n    return (\n        latencyHint === undefined ||\n        typeof latencyHint === 'number' ||\n        (typeof latencyHint === 'string' && (latencyHint === 'balanced' || latencyHint === 'interactive' || latencyHint === 'playback'))\n    );\n};\n", "import { deactivateAudioGraph } from '../helpers/deactivate-audio-graph';\nimport { isValidLatencyHint } from '../helpers/is-valid-latency-hint';\nimport {\n    IAudioContext,\n    IAudioContextOptions,\n    IMediaElementAudioSourceNode,\n    IMediaStreamAudioDestinationNode,\n    IMediaStreamAudioSourceNode,\n    IMediaStreamTrackAudioSourceNode\n} from '../interfaces';\nimport { TAudioContextConstructorFactory, TAudioContextState, TNativeAudioContext, TNativeGainNode, TNativeOscillatorNode } from '../types';\n\nexport const createAudioContextConstructor: TAudioContextConstructorFactory = (\n    baseAudioContextConstructor,\n    createInvalidStateError,\n    createNotSupportedError,\n    createUnknownError,\n    mediaElementAudioSourceNodeConstructor,\n    mediaStreamAudioDestinationNodeConstructor,\n    mediaStreamAudioSourceNodeConstructor,\n    mediaStreamTrackAudioSourceNodeConstructor,\n    nativeAudioContextConstructor\n) => {\n    return class AudioContext extends baseAudioContextConstructor<IAudioContext> implements IAudioContext {\n        private _baseLatency: number;\n\n        private _nativeAudioContext: TNativeAudioContext;\n\n        private _nativeGainNode: null | TNativeGainNode;\n\n        private _nativeOscillatorNode: null | TNativeOscillatorNode;\n\n        private _state: null | 'suspended';\n\n        constructor(options: IAudioContextOptions = {}) {\n            if (nativeAudioContextConstructor === null) {\n                throw new Error('Missing the native AudioContext constructor.');\n            }\n\n            let nativeAudioContext: TNativeAudioContext;\n\n            try {\n                nativeAudioContext = new nativeAudioContextConstructor(options);\n            } catch (err) {\n                // Bug #192 Safari does throw a SyntaxError if the sampleRate is not supported.\n                if (err.code === 12 && err.message === 'sampleRate is not in range') {\n                    throw createNotSupportedError();\n                }\n\n                throw err;\n            }\n\n            // Bug #131 Safari returns null when there are four other AudioContexts running already.\n            if (nativeAudioContext === null) {\n                throw createUnknownError();\n            }\n\n            // Bug #51 Only Chrome and Edge throw an error if the given latencyHint is invalid.\n            if (!isValidLatencyHint(options.latencyHint)) {\n                throw new TypeError(\n                    `The provided value '${options.latencyHint}' is not a valid enum value of type AudioContextLatencyCategory.`\n                );\n            }\n\n            // Bug #150 Safari does not support setting the sampleRate.\n            if (options.sampleRate !== undefined && nativeAudioContext.sampleRate !== options.sampleRate) {\n                throw createNotSupportedError();\n            }\n\n            super(nativeAudioContext, 2);\n\n            const { latencyHint } = options;\n            const { sampleRate } = nativeAudioContext;\n\n            // @todo The values for 'balanced', 'interactive' and 'playback' are just copied from Chrome's implementation.\n            this._baseLatency =\n                typeof nativeAudioContext.baseLatency === 'number'\n                    ? nativeAudioContext.baseLatency\n                    : latencyHint === 'balanced'\n                    ? 512 / sampleRate\n                    : latencyHint === 'interactive' || latencyHint === undefined\n                    ? 256 / sampleRate\n                    : latencyHint === 'playback'\n                    ? 1024 / sampleRate\n                    : /*\n                       * @todo The min (256) and max (16384) values are taken from the allowed bufferSize values of a\n                       * ScriptProcessorNode.\n                       */\n                      (Math.max(2, Math.min(128, Math.round((latencyHint * sampleRate) / 128))) * 128) / sampleRate;\n            this._nativeAudioContext = nativeAudioContext;\n\n            // Bug #188: Safari will set the context's state to 'interrupted' in case the user switches tabs.\n            if (nativeAudioContextConstructor.name === 'webkitAudioContext') {\n                this._nativeGainNode = nativeAudioContext.createGain();\n                this._nativeOscillatorNode = nativeAudioContext.createOscillator();\n\n                this._nativeGainNode.gain.value = 1e-37;\n\n                this._nativeOscillatorNode.connect(this._nativeGainNode).connect(nativeAudioContext.destination);\n                this._nativeOscillatorNode.start();\n            } else {\n                this._nativeGainNode = null;\n                this._nativeOscillatorNode = null;\n            }\n\n            this._state = null;\n\n            /*\n             * Bug #34: Chrome and Edge pretend to be running right away, but fire an onstatechange event when the state actually changes\n             * to 'running'.\n             */\n            if (nativeAudioContext.state === 'running') {\n                this._state = 'suspended';\n\n                const revokeState = () => {\n                    if (this._state === 'suspended') {\n                        this._state = null;\n                    }\n\n                    nativeAudioContext.removeEventListener('statechange', revokeState);\n                };\n\n                nativeAudioContext.addEventListener('statechange', revokeState);\n            }\n        }\n\n        get baseLatency(): number {\n            return this._baseLatency;\n        }\n\n        get state(): TAudioContextState {\n            return this._state !== null ? this._state : this._nativeAudioContext.state;\n        }\n\n        public close(): Promise<void> {\n            // Bug #35: Firefox does not throw an error if the AudioContext was closed before.\n            if (this.state === 'closed') {\n                return this._nativeAudioContext.close().then(() => {\n                    throw createInvalidStateError();\n                });\n            }\n\n            // Bug #34: If the state was set to suspended before it should be revoked now.\n            if (this._state === 'suspended') {\n                this._state = null;\n            }\n\n            return this._nativeAudioContext.close().then(() => {\n                if (this._nativeGainNode !== null && this._nativeOscillatorNode !== null) {\n                    this._nativeOscillatorNode.stop();\n\n                    this._nativeGainNode.disconnect();\n                    this._nativeOscillatorNode.disconnect();\n                }\n\n                deactivateAudioGraph(this);\n            });\n        }\n\n        public createMediaElementSource(mediaElement: HTMLMediaElement): IMediaElementAudioSourceNode<this> {\n            return new mediaElementAudioSourceNodeConstructor(this, { mediaElement });\n        }\n\n        public createMediaStreamDestination(): IMediaStreamAudioDestinationNode<this> {\n            return new mediaStreamAudioDestinationNodeConstructor(this);\n        }\n\n        public createMediaStreamSource(mediaStream: MediaStream): IMediaStreamAudioSourceNode<this> {\n            return new mediaStreamAudioSourceNodeConstructor(this, { mediaStream });\n        }\n\n        public createMediaStreamTrackSource(mediaStreamTrack: MediaStreamTrack): IMediaStreamTrackAudioSourceNode<this> {\n            return new mediaStreamTrackAudioSourceNodeConstructor(this, { mediaStreamTrack });\n        }\n\n        public resume(): Promise<void> {\n            if (this._state === 'suspended') {\n                return new Promise((resolve, reject) => {\n                    const resolvePromise = () => {\n                        this._nativeAudioContext.removeEventListener('statechange', resolvePromise);\n\n                        if (this._nativeAudioContext.state === 'running') {\n                            resolve();\n                        } else {\n                            this.resume().then(resolve, reject);\n                        }\n                    };\n\n                    this._nativeAudioContext.addEventListener('statechange', resolvePromise);\n                });\n            }\n\n            return this._nativeAudioContext.resume().catch((err) => {\n                // Bug #55: Chrome and Edge do throw an InvalidAccessError instead of an InvalidStateError.\n                // Bug #56: Safari invokes the catch handler but without an error.\n                if (err === undefined || err.code === 15) {\n                    throw createInvalidStateError();\n                }\n\n                throw err;\n            });\n        }\n\n        public suspend(): Promise<void> {\n            return this._nativeAudioContext.suspend().catch((err) => {\n                // Bug #56: Safari invokes the catch handler but without an error.\n                if (err === undefined) {\n                    throw createInvalidStateError();\n                }\n\n                throw err;\n            });\n        }\n    };\n};\n", "import { IAudioDestinationNode } from '../interfaces';\nimport {\n    TAudioDestinationNodeConstructorFactory,\n    TAudioNodeRenderer,\n    TChannelCountMode,\n    TContext,\n    TNativeAudioDestinationNode\n} from '../types';\n\nexport const createAudioDestinationNodeConstructor: TAudioDestinationNodeConstructorFactory = (\n    audioNodeConstructor,\n    createAudioDestinationNodeRenderer,\n    createIndexSizeError,\n    createInvalidStateError,\n    createNativeAudioDestinationNode,\n    getNativeContext,\n    isNativeOfflineAudioContext,\n    renderInputsOfAudioNode\n) => {\n    return class AudioDestinationNode<T extends TContext> extends audioNodeConstructor<T> implements IAudioDestinationNode<T> {\n        private _isNodeOfNativeOfflineAudioContext: boolean;\n\n        private _nativeAudioDestinationNode: TNativeAudioDestinationNode;\n\n        constructor(context: T, channelCount: number) {\n            const nativeContext = getNativeContext(context);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            const nativeAudioDestinationNode = createNativeAudioDestinationNode(nativeContext, channelCount, isOffline);\n            const audioDestinationNodeRenderer = <TAudioNodeRenderer<T, this>>(\n                (isOffline ? createAudioDestinationNodeRenderer(renderInputsOfAudioNode) : null)\n            );\n\n            super(context, false, nativeAudioDestinationNode, audioDestinationNodeRenderer);\n\n            this._isNodeOfNativeOfflineAudioContext = isOffline;\n            this._nativeAudioDestinationNode = nativeAudioDestinationNode;\n        }\n\n        get channelCount(): number {\n            return this._nativeAudioDestinationNode.channelCount;\n        }\n\n        set channelCount(value) {\n            // Bug #52: Chrome, Edge & Safari do not throw an exception at all.\n            // Bug #54: Firefox does throw an IndexSizeError.\n            if (this._isNodeOfNativeOfflineAudioContext) {\n                throw createInvalidStateError();\n            }\n\n            // Bug #47: The AudioDestinationNode in Safari does not initialize the maxChannelCount property correctly.\n            if (value > this._nativeAudioDestinationNode.maxChannelCount) {\n                throw createIndexSizeError();\n            }\n\n            this._nativeAudioDestinationNode.channelCount = value;\n        }\n\n        get channelCountMode(): TChannelCountMode {\n            return this._nativeAudioDestinationNode.channelCountMode;\n        }\n\n        set channelCountMode(value) {\n            // Bug #53: No browser does throw an exception yet.\n            if (this._isNodeOfNativeOfflineAudioContext) {\n                throw createInvalidStateError();\n            }\n\n            this._nativeAudioDestinationNode.channelCountMode = value;\n        }\n\n        get maxChannelCount(): number {\n            return this._nativeAudioDestinationNode.maxChannelCount;\n        }\n    };\n};\n", "import { IAudioDestinationNode, IMinimalOfflineAudioContext, IOfflineAudioContext } from '../interfaces';\nimport {\n    TAudioDestinationNodeRendererFactory,\n    TNativeAudioDestinationNode,\n    TNativeOfflineAudioContext,\n    TRenderInputsOfAudioNodeFunction\n} from '../types';\n\nexport const createAudioDestinationNodeRenderer: TAudioDestinationNodeRendererFactory = <\n    T extends IMinimalOfflineAudioContext | IOfflineAudioContext\n>(\n    renderInputsOfAudioNode: TRenderInputsOfAudioNodeFunction\n) => {\n    const renderedNativeAudioDestinationNodes = new WeakMap<TNativeOfflineAudioContext, TNativeAudioDestinationNode>();\n\n    const createAudioDestinationNode = async (proxy: IAudioDestinationNode<T>, nativeOfflineAudioContext: TNativeOfflineAudioContext) => {\n        const nativeAudioDestinationNode = nativeOfflineAudioContext.destination;\n\n        renderedNativeAudioDestinationNodes.set(nativeOfflineAudioContext, nativeAudioDestinationNode);\n\n        await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeAudioDestinationNode);\n\n        return nativeAudioDestinationNode;\n    };\n\n    return {\n        render(\n            proxy: IAudioDestinationNode<T>,\n            nativeOfflineAudioContext: TNativeOfflineAudioContext\n        ): Promise<TNativeAudioDestinationNode> {\n            const renderedNativeAudioDestinationNode = renderedNativeAudioDestinationNodes.get(nativeOfflineAudioContext);\n\n            if (renderedNativeAudioDestinationNode !== undefined) {\n                return Promise.resolve(renderedNativeAudioDestinationNode);\n            }\n\n            return createAudioDestinationNode(proxy, nativeOfflineAudioContext);\n        }\n    };\n};\n", "import { MOST_NEGATIVE_SINGLE_FLOAT, MOST_POSITIVE_SINGLE_FLOAT } from '../constants';\nimport { IAudioParam } from '../interfaces';\nimport { TAudioListenerFactoryFactory } from '../types';\n\nexport const createAudioListenerFactory: TAudioListenerFactoryFactory = (\n    createAudioParam,\n    createNativeChannelMergerNode,\n    createNativeConstantSourceNode,\n    createNativeScriptProcessorNode,\n    createNotSupportedError,\n    getFirstSample,\n    isNativeOfflineAudioContext,\n    overwriteAccessors\n) => {\n    return (context, nativeContext) => {\n        const nativeListener = nativeContext.listener;\n\n        // Bug #117: Only Chrome & Edge support the new interface already.\n        const createFakeAudioParams = () => {\n            const buffer = new Float32Array(1);\n            const channelMergerNode = createNativeChannelMergerNode(nativeContext, {\n                channelCount: 1,\n                channelCountMode: 'explicit',\n                channelInterpretation: 'speakers',\n                numberOfInputs: 9\n            });\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n\n            let isScriptProcessorNodeCreated = false;\n            let lastOrientation: [number, number, number, number, number, number] = [0, 0, -1, 0, 1, 0];\n            let lastPosition: [number, number, number] = [0, 0, 0];\n\n            const createScriptProcessorNode = () => {\n                if (isScriptProcessorNodeCreated) {\n                    return;\n                }\n\n                isScriptProcessorNodeCreated = true;\n\n                const scriptProcessorNode = createNativeScriptProcessorNode(nativeContext, 256, 9, 0);\n\n                // tslint:disable-next-line:deprecation\n                scriptProcessorNode.onaudioprocess = ({ inputBuffer }) => {\n                    const orientation: [number, number, number, number, number, number] = [\n                        getFirstSample(inputBuffer, buffer, 0),\n                        getFirstSample(inputBuffer, buffer, 1),\n                        getFirstSample(inputBuffer, buffer, 2),\n                        getFirstSample(inputBuffer, buffer, 3),\n                        getFirstSample(inputBuffer, buffer, 4),\n                        getFirstSample(inputBuffer, buffer, 5)\n                    ];\n\n                    if (orientation.some((value, index) => value !== lastOrientation[index])) {\n                        nativeListener.setOrientation(...orientation); // tslint:disable-line:deprecation\n\n                        lastOrientation = orientation;\n                    }\n\n                    const positon: [number, number, number] = [\n                        getFirstSample(inputBuffer, buffer, 6),\n                        getFirstSample(inputBuffer, buffer, 7),\n                        getFirstSample(inputBuffer, buffer, 8)\n                    ];\n\n                    if (positon.some((value, index) => value !== lastPosition[index])) {\n                        nativeListener.setPosition(...positon); // tslint:disable-line:deprecation\n\n                        lastPosition = positon;\n                    }\n                };\n\n                channelMergerNode.connect(scriptProcessorNode);\n            };\n            const createSetOrientation = (index: number) => (value: number) => {\n                if (value !== lastOrientation[index]) {\n                    lastOrientation[index] = value;\n\n                    nativeListener.setOrientation(...lastOrientation); // tslint:disable-line:deprecation\n                }\n            };\n            const createSetPosition = (index: number) => (value: number) => {\n                if (value !== lastPosition[index]) {\n                    lastPosition[index] = value;\n\n                    nativeListener.setPosition(...lastPosition); // tslint:disable-line:deprecation\n                }\n            };\n            const createFakeAudioParam = (input: number, initialValue: number, setValue: (value: number) => void) => {\n                const constantSourceNode = createNativeConstantSourceNode(nativeContext, {\n                    channelCount: 1,\n                    channelCountMode: 'explicit',\n                    channelInterpretation: 'discrete',\n                    offset: initialValue\n                });\n\n                constantSourceNode.connect(channelMergerNode, 0, input);\n\n                // @todo This should be stopped when the context is closed.\n                constantSourceNode.start();\n\n                Object.defineProperty(constantSourceNode.offset, 'defaultValue', {\n                    get(): number {\n                        return initialValue;\n                    }\n                });\n\n                /*\n                 * Bug #62 & #74: Safari does not support ConstantSourceNodes and does not export the correct values for maxValue and\n                 * minValue for GainNodes.\n                 */\n                const audioParam = createAudioParam(\n                    <any>{ context },\n                    isOffline,\n                    constantSourceNode.offset,\n                    MOST_POSITIVE_SINGLE_FLOAT,\n                    MOST_NEGATIVE_SINGLE_FLOAT\n                );\n\n                overwriteAccessors(\n                    audioParam,\n                    'value',\n                    (get) => () => get.call(audioParam),\n                    (set) => (value) => {\n                        try {\n                            set.call(audioParam, value);\n                        } catch (err) {\n                            if (err.code !== 9) {\n                                throw err;\n                            }\n                        }\n\n                        createScriptProcessorNode();\n\n                        if (isOffline) {\n                            // Bug #117: Using setOrientation() and setPosition() doesn't work with an OfflineAudioContext.\n                            setValue(value);\n                        }\n                    }\n                );\n\n                audioParam.cancelAndHoldAtTime = ((cancelAndHoldAtTime) => {\n                    if (isOffline) {\n                        return () => {\n                            throw createNotSupportedError();\n                        };\n                    }\n\n                    return (...args: Parameters<IAudioParam['cancelAndHoldAtTime']>) => {\n                        const value = cancelAndHoldAtTime.apply(audioParam, args);\n\n                        createScriptProcessorNode();\n\n                        return value;\n                    };\n                })(audioParam.cancelAndHoldAtTime);\n                audioParam.cancelScheduledValues = ((cancelScheduledValues) => {\n                    if (isOffline) {\n                        return () => {\n                            throw createNotSupportedError();\n                        };\n                    }\n\n                    return (...args: Parameters<IAudioParam['cancelScheduledValues']>) => {\n                        const value = cancelScheduledValues.apply(audioParam, args);\n\n                        createScriptProcessorNode();\n\n                        return value;\n                    };\n                })(audioParam.cancelScheduledValues);\n                audioParam.exponentialRampToValueAtTime = ((exponentialRampToValueAtTime) => {\n                    if (isOffline) {\n                        return () => {\n                            throw createNotSupportedError();\n                        };\n                    }\n\n                    return (...args: Parameters<IAudioParam['exponentialRampToValueAtTime']>) => {\n                        const value = exponentialRampToValueAtTime.apply(audioParam, args);\n\n                        createScriptProcessorNode();\n\n                        return value;\n                    };\n                })(audioParam.exponentialRampToValueAtTime);\n                audioParam.linearRampToValueAtTime = ((linearRampToValueAtTime) => {\n                    if (isOffline) {\n                        return () => {\n                            throw createNotSupportedError();\n                        };\n                    }\n\n                    return (...args: Parameters<IAudioParam['linearRampToValueAtTime']>) => {\n                        const value = linearRampToValueAtTime.apply(audioParam, args);\n\n                        createScriptProcessorNode();\n\n                        return value;\n                    };\n                })(audioParam.linearRampToValueAtTime);\n                audioParam.setTargetAtTime = ((setTargetAtTime) => {\n                    if (isOffline) {\n                        return () => {\n                            throw createNotSupportedError();\n                        };\n                    }\n\n                    return (...args: Parameters<IAudioParam['setTargetAtTime']>) => {\n                        const value = setTargetAtTime.apply(audioParam, args);\n\n                        createScriptProcessorNode();\n\n                        return value;\n                    };\n                })(audioParam.setTargetAtTime);\n                audioParam.setValueAtTime = ((setValueAtTime) => {\n                    if (isOffline) {\n                        return () => {\n                            throw createNotSupportedError();\n                        };\n                    }\n\n                    return (...args: Parameters<IAudioParam['setValueAtTime']>) => {\n                        const value = setValueAtTime.apply(audioParam, args);\n\n                        createScriptProcessorNode();\n\n                        return value;\n                    };\n                })(audioParam.setValueAtTime);\n                audioParam.setValueCurveAtTime = ((setValueCurveAtTime) => {\n                    if (isOffline) {\n                        return () => {\n                            throw createNotSupportedError();\n                        };\n                    }\n\n                    return (...args: Parameters<IAudioParam['setValueCurveAtTime']>) => {\n                        const value = setValueCurveAtTime.apply(audioParam, args);\n\n                        createScriptProcessorNode();\n\n                        return value;\n                    };\n                })(audioParam.setValueCurveAtTime);\n\n                return audioParam;\n            };\n\n            return {\n                forwardX: createFakeAudioParam(0, 0, createSetOrientation(0)),\n                forwardY: createFakeAudioParam(1, 0, createSetOrientation(1)),\n                forwardZ: createFakeAudioParam(2, -1, createSetOrientation(2)),\n                positionX: createFakeAudioParam(6, 0, createSetPosition(0)),\n                positionY: createFakeAudioParam(7, 0, createSetPosition(1)),\n                positionZ: createFakeAudioParam(8, 0, createSetPosition(2)),\n                upX: createFakeAudioParam(3, 0, createSetOrientation(3)),\n                upY: createFakeAudioParam(4, 1, createSetOrientation(4)),\n                upZ: createFakeAudioParam(5, 0, createSetOrientation(5))\n            };\n        };\n\n        const { forwardX, forwardY, forwardZ, positionX, positionY, positionZ, upX, upY, upZ } =\n            nativeListener.forwardX === undefined ? createFakeAudioParams() : nativeListener;\n\n        return {\n            get forwardX(): IAudioParam {\n                return forwardX;\n            },\n            get forwardY(): IAudioParam {\n                return forwardY;\n            },\n            get forwardZ(): IAudioParam {\n                return forwardZ;\n            },\n            get positionX(): IAudioParam {\n                return positionX;\n            },\n            get positionY(): IAudioParam {\n                return positionY;\n            },\n            get positionZ(): IAudioParam {\n                return positionZ;\n            },\n            get upX(): IAudioParam {\n                return upX;\n            },\n            get upY(): IAudioParam {\n                return upY;\n            },\n            get upZ(): IAudioParam {\n                return upZ;\n            }\n        };\n    };\n};\n", "import { IAudioNode, IAudioParam } from '../interfaces';\nimport { TContext } from '../types';\n\nexport const isAudioNode = <T extends TContext>(\n    audioNodeOrAudioParam: IAudioNode<T> | IAudioParam\n): audioNodeOrAudioParam is IAudioNode<T> => {\n    return 'context' in audioNodeOrAudioParam;\n};\n", "import { TAudioNodeOutputConnection, TContext, TOutputConnection } from '../types';\nimport { isAudioNode } from './audio-node';\n\nexport const isAudioNodeOutputConnection = <T extends TContext>(\n    outputConnection: TOutputConnection<T>\n): outputConnection is TAudioNodeOutputConnection<T> => {\n    return isAudioNode(outputConnection[0]);\n};\n", "import { TInsertElementInSetFunction } from '../types';\n\nexport const insertElementInSet: TInsertElementInSetFunction = (set, element, predicate, ignoreDuplicates) => {\n    for (const lmnt of set) {\n        if (predicate(lmnt)) {\n            if (ignoreDuplicates) {\n                return false;\n            }\n\n            throw Error('The set contains at least one similar element.');\n        }\n    }\n\n    set.add(element);\n\n    return true;\n};\n", "import { IAudioNode } from '../interfaces';\nimport { TActiveInputConnection, TContext, TPassiveAudioParamInputConnection } from '../types';\nimport { insertElementInSet } from './insert-element-in-set';\n\nexport const addActiveInputConnectionToAudioParam = <T extends TContext>(\n    activeInputs: Set<TActiveInputConnection<T>>,\n    source: IAudioNode<T>,\n    [output, eventListener]: TPassiveAudioParamInputConnection,\n    ignoreDuplicates: boolean\n) => {\n    insertElementInSet(\n        activeInputs,\n        [source, output, eventListener],\n        (activeInputConnection) => activeInputConnection[0] === source && activeInputConnection[1] === output,\n        ignoreDuplicates\n    );\n};\n", "import { IAudioNode } from '../interfaces';\nimport { TActiveInputConnection, TContext, TPassiveAudioParamInputConnection } from '../types';\nimport { insertElementInSet } from './insert-element-in-set';\n\nexport const addPassiveInputConnectionToAudioParam = <T extends TContext>(\n    passiveInputs: WeakMap<IAudioNode<T>, Set<TPassiveAudioParamInputConnection>>,\n    [source, output, eventListener]: TActiveInputConnection<T>,\n    ignoreDuplicates: boolean\n) => {\n    const passiveInputConnections = passiveInputs.get(source);\n\n    if (passiveInputConnections === undefined) {\n        passiveInputs.set(source, new Set([[output, eventListener]]));\n    } else {\n        insertElementInSet(\n            passiveInputConnections,\n            [output, eventListener],\n            (passiveInputConnection) => passiveInputConnection[0] === output,\n            ignoreDuplicates\n        );\n    }\n};\n", "import { INativeAudioNodeFaker } from '../interfaces';\nimport { TNativeAudioNode } from '../types';\n\nexport const isNativeAudioNodeFaker = (\n    nativeAudioNodeOrNativeAudioNodeFaker: TNativeAudioNode | INativeAudioNodeFaker\n): nativeAudioNodeOrNativeAudioNodeFaker is INativeAudioNodeFaker => {\n    return 'inputs' in nativeAudioNodeOrNativeAudioNodeFaker;\n};\n", "import { isNativeAudioNodeFaker } from '../guards/native-audio-node-faker';\nimport { INativeAudioNodeFaker } from '../interfaces';\nimport { TConnectNativeAudioNodeToNativeAudioNodeFunction, TNativeAudioNode } from '../types';\n\nexport const connectNativeAudioNodeToNativeAudioNode: TConnectNativeAudioNodeToNativeAudioNodeFunction = (\n    nativeSourceAudioNode: INativeAudioNodeFaker | TNativeAudioNode,\n    nativeDestinationAudioNode: INativeAudioNodeFaker | TNativeAudioNode,\n    output: number,\n    input: number\n): [TNativeAudioNode, number, number] => {\n    if (isNativeAudioNodeFaker(nativeDestinationAudioNode)) {\n        const fakeNativeDestinationAudioNode = nativeDestinationAudioNode.inputs[input];\n\n        nativeSourceAudioNode.connect(fakeNativeDestinationAudioNode, output, 0);\n\n        return [fakeNativeDestinationAudioNode, output, 0];\n    }\n\n    nativeSourceAudioNode.connect(nativeDestinationAudioNode, output, input);\n\n    return [nativeDestinationAudioNode, output, input];\n};\n", "import { IAudioNode } from '../interfaces';\nimport { TActiveInputConnection, TContext } from '../types';\n\nexport const deleteActiveInputConnection = <T extends TContext>(\n    activeInputConnections: Set<TActiveInputConnection<T>>,\n    source: IAudioNode<T>,\n    output: number\n): null | TActiveInputConnection<T> => {\n    for (const activeInputConnection of activeInputConnections) {\n        if (activeInputConnection[0] === source && activeInputConnection[1] === output) {\n            activeInputConnections.delete(activeInputConnection);\n\n            return activeInputConnection;\n        }\n    }\n\n    return null;\n};\n", "import { IAudioNode } from '../interfaces';\nimport { TActiveInputConnection, TContext } from '../types';\nimport { pickElementFromSet } from './pick-element-from-set';\n\nexport const deleteActiveInputConnectionToAudioParam = <T extends TContext>(\n    activeInputs: Set<TActiveInputConnection<T>>,\n    source: IAudioNode<T>,\n    output: number\n) => {\n    return pickElementFromSet(\n        activeInputs,\n        (activeInputConnection) => activeInputConnection[0] === source && activeInputConnection[1] === output\n    );\n};\n", "import { IAudioNode } from '../interfaces';\nimport { TContext, TInternalStateEventListener } from '../types';\nimport { getEventListenersOfAudioNode } from './get-event-listeners-of-audio-node';\n\nexport const deleteEventListenerOfAudioNode = <T extends TContext>(\n    audioNode: IAudioNode<T>,\n    eventListener: TInternalStateEventListener\n) => {\n    const eventListeners = getEventListenersOfAudioNode(audioNode);\n\n    if (!eventListeners.delete(eventListener)) {\n        throw new Error('Missing the expected event listener.');\n    }\n};\n", "import { IAudioNode } from '../interfaces';\nimport { TContext, TPassiveAudioParamInputConnection } from '../types';\nimport { getValueForKey } from './get-value-for-key';\nimport { pickElementFromSet } from './pick-element-from-set';\n\nexport const deletePassiveInputConnectionToAudioParam = <T extends TContext>(\n    passiveInputs: WeakMap<IAudioNode<T>, Set<TPassiveAudioParamInputConnection>>,\n    source: IAudioNode<T>,\n    output: number\n) => {\n    const passiveInputConnections = getValueForKey(passiveInputs, source);\n    const matchingConnection = pickElementFromSet(\n        passiveInputConnections,\n        (passiveInputConnection) => passiveInputConnection[0] === output\n    );\n\n    if (passiveInputConnections.size === 0) {\n        passiveInputs.delete(source);\n    }\n\n    return matchingConnection;\n};\n", "import { isNativeAudioNodeFaker } from '../guards/native-audio-node-faker';\nimport { TDisconnectNativeAudioNodeFromNativeAudioNodeFunction } from '../types';\n\nexport const disconnectNativeAudioNodeFromNativeAudioNode: TDisconnectNativeAudioNodeFromNativeAudioNodeFunction = (\n    nativeSourceAudioNode,\n    nativeDestinationAudioNode,\n    output,\n    input\n) => {\n    if (isNativeAudioNodeFaker(nativeDestinationAudioNode)) {\n        nativeSourceAudioNode.disconnect(nativeDestinationAudioNode.inputs[input], output, 0);\n    } else {\n        nativeSourceAudioNode.disconnect(nativeDestinationAudioNode, output, input);\n    }\n};\n", "import { AUDIO_NODE_STORE } from '../globals';\nimport { IAudioNode, INativeAudioNodeFaker } from '../interfaces';\nimport { TContext, TGetNativeAudioNodeFunction, TNativeAudioNode } from '../types';\nimport { getValueForKey } from './get-value-for-key';\n\nexport const getNativeAudioNode: TGetNativeAudioNodeFunction = <T extends TContext, U extends TNativeAudioNode | INativeAudioNodeFaker>(\n    audioNode: IAudioNode<T>\n): U => {\n    return <U>getValueForKey(AUDIO_NODE_STORE, audioNode);\n};\n", "import { AUDIO_PARAM_STORE } from '../globals';\nimport { IAudioParam } from '../interfaces';\nimport { TNativeAudioParam } from '../types';\nimport { getValueForKey } from './get-value-for-key';\n\nexport const getNativeAudioParam = (audioParam: IAudioParam): TNativeAudioParam => {\n    return getValueForKey(AUDIO_PARAM_STORE, audioParam);\n};\n", "import { CYCLE_COUNTERS } from '../globals';\nimport { TIsPartOfACycleFunction } from '../types';\n\nexport const isPartOfACycle: TIsPartOfACycleFunction = (audioNode) => {\n    return CYCLE_COUNTERS.has(audioNode);\n};\n", "import { ACTIVE_AUDIO_NODE_STORE } from '../globals';\nimport { TIsPassiveAudioNodeFunction } from '../types';\n\nexport const isPassiveAudioNode: TIsPassiveAudioNodeFunction = (audioNode) => {\n    return !ACTIVE_AUDIO_NODE_STORE.has(audioNode);\n};\n", "import { TNativeAudioContext, TNativeAudioWorkletNodeConstructor } from '../types';\n\nexport const testAudioNodeDisconnectMethodSupport = (\n    nativeAudioContext: TNativeAudioContext,\n    nativeAudioWorkletNodeConstructor: null | TNativeAudioWorkletNodeConstructor\n): Promise<boolean> => {\n    return new Promise((resolve) => {\n        /*\n         * This bug existed in Safari up until v14.0.2. Since AudioWorklets were not supported in Safari until v14.1 the presence of the\n         * constructor for an AudioWorkletNode can be used here to skip the test.\n         */\n        if (nativeAudioWorkletNodeConstructor !== null) {\n            resolve(true);\n        } else {\n            const analyzer = nativeAudioContext.createScriptProcessor(256, 1, 1); // tslint:disable-line deprecation\n            const dummy = nativeAudioContext.createGain();\n            // Bug #95: Safari does not play one sample buffers.\n            const ones = nativeAudioContext.createBuffer(1, 2, 44100);\n            const channelData = ones.getChannelData(0);\n\n            channelData[0] = 1;\n            channelData[1] = 1;\n\n            const source = nativeAudioContext.createBufferSource();\n\n            source.buffer = ones;\n            source.loop = true;\n\n            source.connect(analyzer).connect(nativeAudioContext.destination);\n            source.connect(dummy);\n            source.disconnect(dummy);\n\n            // tslint:disable-next-line:deprecation\n            analyzer.onaudioprocess = (event) => {\n                const chnnlDt = event.inputBuffer.getChannelData(0); // tslint:disable-line deprecation\n\n                if (Array.prototype.some.call(chnnlDt, (sample: number) => sample === 1)) {\n                    resolve(true);\n                } else {\n                    resolve(false);\n                }\n\n                source.stop();\n\n                analyzer.onaudioprocess = null; // tslint:disable-line:deprecation\n\n                source.disconnect(analyzer);\n                analyzer.disconnect(nativeAudioContext.destination);\n            };\n\n            source.start();\n        }\n    });\n};\n", "import { IAudioNode } from '../interfaces';\nimport { TContext } from '../types';\n\nexport const visitEachAudioNodeOnce = <T extends TContext>(\n    cycles: IAudioNode<T>[][],\n    visitor: (audioNode: IAudioNode<T>, count: number) => void\n): void => {\n    const counts = new Map<IAudioNode<T>, number>();\n\n    for (const cycle of cycles) {\n        for (const audioNode of cycle) {\n            const count = counts.get(audioNode);\n\n            counts.set(audioNode, count === undefined ? 1 : count + 1);\n        }\n    }\n\n    counts.forEach((count, audioNode) => visitor(audioNode, count));\n};\n", "import { TNativeAudioNode, TNativeAudioParam } from '../types';\n\nexport const isNativeAudioNode = (\n    nativeAudioNodeOrAudioParam: TNativeAudioNode | TNativeAudioParam\n): nativeAudioNodeOrAudioParam is TNativeAudioNode => {\n    return 'context' in nativeAudioNodeOrAudioParam;\n};\n", "import { isNativeAudioNode } from '../guards/native-audio-node';\nimport { TNativeAudioNode, TNativeAudioParam } from '../types';\n\nexport const wrapAudioNodeDisconnectMethod = (nativeAudioNode: TNativeAudioNode): void => {\n    const connections = new Map<TNativeAudioNode | TNativeAudioParam, { input: number; output: number }[]>();\n\n    nativeAudioNode.connect = <TNativeAudioNode['connect']>((connect) => {\n        // tslint:disable-next-line:invalid-void no-inferrable-types\n        return (destination: TNativeAudioNode | TNativeAudioParam, output = 0, input: number = 0): void | TNativeAudioNode => {\n            const returnValue = isNativeAudioNode(destination) ? connect(destination, output, input) : connect(destination, output);\n\n            // Save the new connection only if the calls to connect above didn't throw an error.\n            const connectionsToDestination = connections.get(destination);\n\n            if (connectionsToDestination === undefined) {\n                connections.set(destination, [{ input, output }]);\n            } else {\n                if (connectionsToDestination.every((connection) => connection.input !== input || connection.output !== output)) {\n                    connectionsToDestination.push({ input, output });\n                }\n            }\n\n            return returnValue;\n        };\n    })(nativeAudioNode.connect.bind(nativeAudioNode));\n\n    nativeAudioNode.disconnect = ((disconnect) => {\n        return (destinationOrOutput?: number | TNativeAudioNode | TNativeAudioParam, output?: number, input?: number): void => {\n            disconnect.apply(nativeAudioNode);\n\n            if (destinationOrOutput === undefined) {\n                connections.clear();\n            } else if (typeof destinationOrOutput === 'number') {\n                for (const [destination, connectionsToDestination] of connections) {\n                    const filteredConnections = connectionsToDestination.filter((connection) => connection.output !== destinationOrOutput);\n\n                    if (filteredConnections.length === 0) {\n                        connections.delete(destination);\n                    } else {\n                        connections.set(destination, filteredConnections);\n                    }\n                }\n            } else if (connections.has(destinationOrOutput)) {\n                if (output === undefined) {\n                    connections.delete(destinationOrOutput);\n                } else {\n                    const connectionsToDestination = connections.get(destinationOrOutput);\n\n                    if (connectionsToDestination !== undefined) {\n                        const filteredConnections = connectionsToDestination.filter(\n                            (connection) => connection.output !== output && (connection.input !== input || input === undefined)\n                        );\n\n                        if (filteredConnections.length === 0) {\n                            connections.delete(destinationOrOutput);\n                        } else {\n                            connections.set(destinationOrOutput, filteredConnections);\n                        }\n                    }\n                }\n            }\n\n            for (const [destination, connectionsToDestination] of connections) {\n                connectionsToDestination.forEach((connection) => {\n                    if (isNativeAudioNode(destination)) {\n                        nativeAudioNode.connect(destination, connection.output, connection.input);\n                    } else {\n                        nativeAudioNode.connect(destination, connection.output);\n                    }\n                });\n            }\n        };\n    })(nativeAudioNode.disconnect);\n};\n", "import { AUDIO_NODE_STORE, EVENT_LISTENERS } from '../globals';\nimport { isAudioNode } from '../guards/audio-node';\nimport { isAudioNodeOutputConnection } from '../guards/audio-node-output-connection';\nimport { addActiveInputConnectionToAudioParam } from '../helpers/add-active-input-connection-to-audio-param';\nimport { addPassiveInputConnectionToAudioParam } from '../helpers/add-passive-input-connection-to-audio-param';\nimport { connectNativeAudioNodeToNativeAudioNode } from '../helpers/connect-native-audio-node-to-native-audio-node';\nimport { deleteActiveInputConnection } from '../helpers/delete-active-input-connection';\nimport { deleteActiveInputConnectionToAudioParam } from '../helpers/delete-active-input-connection-to-audio-param';\nimport { deleteEventListenerOfAudioNode } from '../helpers/delete-event-listeners-of-audio-node';\nimport { deletePassiveInputConnectionToAudioNode } from '../helpers/delete-passive-input-connection-to-audio-node';\nimport { deletePassiveInputConnectionToAudioParam } from '../helpers/delete-passive-input-connection-to-audio-param';\nimport { disconnectNativeAudioNodeFromNativeAudioNode } from '../helpers/disconnect-native-audio-node-from-native-audio-node';\nimport { getAudioNodeConnections } from '../helpers/get-audio-node-connections';\nimport { getAudioParamConnections } from '../helpers/get-audio-param-connections';\nimport { getEventListenersOfAudioNode } from '../helpers/get-event-listeners-of-audio-node';\nimport { getNativeAudioNode } from '../helpers/get-native-audio-node';\nimport { getNativeAudioParam } from '../helpers/get-native-audio-param';\nimport { insertElementInSet } from '../helpers/insert-element-in-set';\nimport { isActiveAudioNode } from '../helpers/is-active-audio-node';\nimport { isPartOfACycle } from '../helpers/is-part-of-a-cycle';\nimport { isPassiveAudioNode } from '../helpers/is-passive-audio-node';\nimport { setInternalStateToActive } from '../helpers/set-internal-state-to-active';\nimport { setInternalStateToPassiveWhenNecessary } from '../helpers/set-internal-state-to-passive-when-necessary';\nimport { testAudioNodeDisconnectMethodSupport } from '../helpers/test-audio-node-disconnect-method-support';\nimport { visitEachAudioNodeOnce } from '../helpers/visit-each-audio-node-once';\nimport { wrapAudioNodeDisconnectMethod } from '../helpers/wrap-audio-node-disconnect-method';\nimport {\n    IAudioNode,\n    IAudioNodeRenderer,\n    IAudioParam,\n    IMinimalOfflineAudioContext,\n    INativeAudioNodeFaker,\n    IOfflineAudioContext\n} from '../interfaces';\nimport {\n    TAudioNodeConstructorFactory,\n    TChannelCountMode,\n    TChannelInterpretation,\n    TContext,\n    TInternalStateEventListener,\n    TNativeAudioNode,\n    TNativeAudioParam\n} from '../types';\n\nconst addConnectionToAudioParamOfAudioContext = <T extends TContext>(\n    source: IAudioNode<T>,\n    destination: IAudioParam,\n    output: number,\n    isOffline: boolean\n): boolean => {\n    const { activeInputs, passiveInputs } = getAudioParamConnections<T>(destination);\n    const { outputs } = getAudioNodeConnections(source);\n    const eventListeners = getEventListenersOfAudioNode(source);\n\n    const eventListener: TInternalStateEventListener = (isActive) => {\n        const nativeAudioNode = getNativeAudioNode(source);\n        const nativeAudioParam = getNativeAudioParam(destination);\n\n        if (isActive) {\n            const partialConnection = deletePassiveInputConnectionToAudioParam(passiveInputs, source, output);\n\n            addActiveInputConnectionToAudioParam(activeInputs, source, partialConnection, false);\n\n            if (!isOffline && !isPartOfACycle(source)) {\n                nativeAudioNode.connect(nativeAudioParam, output);\n            }\n        } else {\n            const partialConnection = deleteActiveInputConnectionToAudioParam(activeInputs, source, output);\n\n            addPassiveInputConnectionToAudioParam(passiveInputs, partialConnection, false);\n\n            if (!isOffline && !isPartOfACycle(source)) {\n                nativeAudioNode.disconnect(nativeAudioParam, output);\n            }\n        }\n    };\n\n    if (\n        insertElementInSet(\n            outputs,\n            [destination, output],\n            (outputConnection) => outputConnection[0] === destination && outputConnection[1] === output,\n            true\n        )\n    ) {\n        eventListeners.add(eventListener);\n\n        if (isActiveAudioNode(source)) {\n            addActiveInputConnectionToAudioParam(activeInputs, source, [output, eventListener], true);\n        } else {\n            addPassiveInputConnectionToAudioParam(passiveInputs, [source, output, eventListener], true);\n        }\n\n        return true;\n    }\n\n    return false;\n};\n\nconst deleteInputConnectionOfAudioNode = <T extends TContext>(\n    source: IAudioNode<T>,\n    destination: IAudioNode<T>,\n    output: number,\n    input: number\n): [null | TInternalStateEventListener, boolean] => {\n    const { activeInputs, passiveInputs } = getAudioNodeConnections(destination);\n\n    const activeInputConnection = deleteActiveInputConnection(activeInputs[input], source, output);\n\n    if (activeInputConnection === null) {\n        const passiveInputConnection = deletePassiveInputConnectionToAudioNode(passiveInputs, source, output, input);\n\n        return [passiveInputConnection[2], false];\n    }\n\n    return [activeInputConnection[2], true];\n};\n\nconst deleteInputConnectionOfAudioParam = <T extends TContext>(\n    source: IAudioNode<T>,\n    destination: IAudioParam,\n    output: number\n): [null | TInternalStateEventListener, boolean] => {\n    const { activeInputs, passiveInputs } = getAudioParamConnections<T>(destination);\n\n    const activeInputConnection = deleteActiveInputConnection(activeInputs, source, output);\n\n    if (activeInputConnection === null) {\n        const passiveInputConnection = deletePassiveInputConnectionToAudioParam(passiveInputs, source, output);\n\n        return [passiveInputConnection[1], false];\n    }\n\n    return [activeInputConnection[2], true];\n};\n\nconst deleteInputsOfAudioNode = <T extends TContext>(\n    source: IAudioNode<T>,\n    isOffline: boolean,\n    destination: IAudioNode<T>,\n    output: number,\n    input: number\n) => {\n    const [listener, isActive] = deleteInputConnectionOfAudioNode(source, destination, output, input);\n\n    if (listener !== null) {\n        deleteEventListenerOfAudioNode(source, listener);\n\n        if (isActive && !isOffline && !isPartOfACycle(source)) {\n            disconnectNativeAudioNodeFromNativeAudioNode(getNativeAudioNode(source), getNativeAudioNode(destination), output, input);\n        }\n    }\n\n    if (isActiveAudioNode(destination)) {\n        const { activeInputs } = getAudioNodeConnections(destination);\n\n        setInternalStateToPassiveWhenNecessary(destination, activeInputs);\n    }\n};\n\nconst deleteInputsOfAudioParam = <T extends TContext>(\n    source: IAudioNode<T>,\n    isOffline: boolean,\n    destination: IAudioParam,\n    output: number\n) => {\n    const [listener, isActive] = deleteInputConnectionOfAudioParam(source, destination, output);\n\n    if (listener !== null) {\n        deleteEventListenerOfAudioNode(source, listener);\n\n        if (isActive && !isOffline && !isPartOfACycle(source)) {\n            getNativeAudioNode(source).disconnect(getNativeAudioParam(destination), output);\n        }\n    }\n};\n\nconst deleteAnyConnection = <T extends TContext>(source: IAudioNode<T>, isOffline: boolean): (IAudioNode<T> | IAudioParam)[] => {\n    const audioNodeConnectionsOfSource = getAudioNodeConnections(source);\n    const destinations = [];\n\n    for (const outputConnection of audioNodeConnectionsOfSource.outputs) {\n        if (isAudioNodeOutputConnection(outputConnection)) {\n            deleteInputsOfAudioNode(source, isOffline, ...outputConnection);\n        } else {\n            deleteInputsOfAudioParam(source, isOffline, ...outputConnection);\n        }\n\n        destinations.push(outputConnection[0]);\n    }\n\n    audioNodeConnectionsOfSource.outputs.clear();\n\n    return destinations;\n};\n\nconst deleteConnectionAtOutput = <T extends TContext>(\n    source: IAudioNode<T>,\n    isOffline: boolean,\n    output: number\n): (IAudioNode<T> | IAudioParam)[] => {\n    const audioNodeConnectionsOfSource = getAudioNodeConnections(source);\n    const destinations = [];\n\n    for (const outputConnection of audioNodeConnectionsOfSource.outputs) {\n        if (outputConnection[1] === output) {\n            if (isAudioNodeOutputConnection(outputConnection)) {\n                deleteInputsOfAudioNode(source, isOffline, ...outputConnection);\n            } else {\n                deleteInputsOfAudioParam(source, isOffline, ...outputConnection);\n            }\n\n            destinations.push(outputConnection[0]);\n            audioNodeConnectionsOfSource.outputs.delete(outputConnection);\n        }\n    }\n\n    return destinations;\n};\n\nconst deleteConnectionToDestination = <T extends TContext, U extends TContext>(\n    source: IAudioNode<T>,\n    isOffline: boolean,\n    destination: IAudioNode<U> | IAudioParam,\n    output?: number,\n    input?: number\n): (IAudioNode<T> | IAudioParam)[] => {\n    const audioNodeConnectionsOfSource = getAudioNodeConnections(source);\n\n    return Array.from(audioNodeConnectionsOfSource.outputs)\n        .filter(\n            (outputConnection) =>\n                outputConnection[0] === destination &&\n                (output === undefined || outputConnection[1] === output) &&\n                (input === undefined || outputConnection[2] === input)\n        )\n        .map((outputConnection) => {\n            if (isAudioNodeOutputConnection(outputConnection)) {\n                deleteInputsOfAudioNode(source, isOffline, ...outputConnection);\n            } else {\n                deleteInputsOfAudioParam(source, isOffline, ...outputConnection);\n            }\n\n            audioNodeConnectionsOfSource.outputs.delete(outputConnection);\n\n            return outputConnection[0];\n        });\n};\n\nexport const createAudioNodeConstructor: TAudioNodeConstructorFactory = (\n    addAudioNodeConnections,\n    addConnectionToAudioNode,\n    cacheTestResult,\n    createIncrementCycleCounter,\n    createIndexSizeError,\n    createInvalidAccessError,\n    createNotSupportedError,\n    decrementCycleCounter,\n    detectCycles,\n    eventTargetConstructor,\n    getNativeContext,\n    isNativeAudioContext,\n    isNativeAudioNode,\n    isNativeAudioParam,\n    isNativeOfflineAudioContext,\n    nativeAudioWorkletNodeConstructor\n) => {\n    return class AudioNode<T extends TContext, EventMap extends Record<string, Event> = {}>\n        extends eventTargetConstructor<EventMap>\n        implements IAudioNode<T, EventMap>\n    {\n        private _context: T;\n\n        private _nativeAudioNode: INativeAudioNodeFaker | TNativeAudioNode;\n\n        constructor(\n            context: T,\n            isActive: boolean,\n            nativeAudioNode: INativeAudioNodeFaker | TNativeAudioNode,\n            audioNodeRenderer: T extends IMinimalOfflineAudioContext | IOfflineAudioContext ? IAudioNodeRenderer<T, IAudioNode<T>> : null\n        ) {\n            super(nativeAudioNode);\n\n            this._context = context;\n            this._nativeAudioNode = nativeAudioNode;\n\n            const nativeContext = getNativeContext(context);\n\n            // Bug #12: Safari does not support to disconnect a specific destination.\n            if (\n                isNativeAudioContext(nativeContext) &&\n                true !==\n                    cacheTestResult(testAudioNodeDisconnectMethodSupport, () => {\n                        return testAudioNodeDisconnectMethodSupport(nativeContext, nativeAudioWorkletNodeConstructor);\n                    })\n            ) {\n                wrapAudioNodeDisconnectMethod(nativeAudioNode);\n            }\n\n            AUDIO_NODE_STORE.set(this, nativeAudioNode);\n            EVENT_LISTENERS.set(this, new Set());\n\n            if (context.state !== 'closed' && isActive) {\n                setInternalStateToActive(this);\n            }\n\n            addAudioNodeConnections(this, audioNodeRenderer, nativeAudioNode);\n        }\n\n        get channelCount(): number {\n            return this._nativeAudioNode.channelCount;\n        }\n\n        set channelCount(value) {\n            this._nativeAudioNode.channelCount = value;\n        }\n\n        get channelCountMode(): TChannelCountMode {\n            return this._nativeAudioNode.channelCountMode;\n        }\n\n        set channelCountMode(value) {\n            this._nativeAudioNode.channelCountMode = value;\n        }\n\n        get channelInterpretation(): TChannelInterpretation {\n            return this._nativeAudioNode.channelInterpretation;\n        }\n\n        set channelInterpretation(value) {\n            this._nativeAudioNode.channelInterpretation = value;\n        }\n\n        get context(): T {\n            return this._context;\n        }\n\n        get numberOfInputs(): number {\n            return this._nativeAudioNode.numberOfInputs;\n        }\n\n        get numberOfOutputs(): number {\n            return this._nativeAudioNode.numberOfOutputs;\n        }\n\n        public connect<U extends TContext, V extends IAudioNode<U>>(destinationNode: V, output?: number, input?: number): V;\n        public connect(destinationParam: IAudioParam, output?: number): void;\n        // tslint:disable-next-line:invalid-void\n        public connect<U extends TContext, V extends IAudioNode<U>>(destination: V | IAudioParam, output = 0, input = 0): void | V {\n            // Bug #174: Safari does expose a wrong numberOfOutputs for MediaStreamAudioDestinationNodes.\n            if (output < 0 || output >= this._nativeAudioNode.numberOfOutputs) {\n                throw createIndexSizeError();\n            }\n\n            const nativeContext = getNativeContext(this._context);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n\n            if (isNativeAudioNode(destination) || isNativeAudioParam(destination)) {\n                throw createInvalidAccessError();\n            }\n\n            if (isAudioNode(destination)) {\n                const nativeDestinationAudioNode = getNativeAudioNode(destination);\n\n                try {\n                    const connection = connectNativeAudioNodeToNativeAudioNode(\n                        this._nativeAudioNode,\n                        nativeDestinationAudioNode,\n                        output,\n                        input\n                    );\n\n                    const isPassive = isPassiveAudioNode(this);\n\n                    if (isOffline || isPassive) {\n                        this._nativeAudioNode.disconnect(...connection);\n                    }\n\n                    if (this.context.state !== 'closed' && !isPassive && isPassiveAudioNode(destination)) {\n                        setInternalStateToActive(destination);\n                    }\n                } catch (err) {\n                    // Bug #41: Safari does not throw the correct exception so far.\n                    if (err.code === 12) {\n                        throw createInvalidAccessError();\n                    }\n\n                    throw err;\n                }\n\n                const isNewConnectionToAudioNode = addConnectionToAudioNode(\n                    this,\n                    <IAudioNode<TContext>>destination,\n                    output,\n                    input,\n                    isOffline\n                );\n\n                // Bug #164: Only Firefox detects cycles so far.\n                if (isNewConnectionToAudioNode) {\n                    const cycles = detectCycles([this], <IAudioNode<T>>(<unknown>destination));\n\n                    visitEachAudioNodeOnce(cycles, createIncrementCycleCounter(isOffline));\n                }\n\n                return destination;\n            }\n\n            const nativeAudioParam = getNativeAudioParam(destination);\n\n            /*\n             * Bug #73, #147 & #153: Safari does not support to connect an input signal to the playbackRate AudioParam of an\n             * AudioBufferSourceNode. This can't be easily detected and that's why the outdated name property is used here to identify\n             * Safari. In addition to that the maxValue property is used to only detect the affected versions below v14.0.2.\n             */\n            if ((<TNativeAudioParam & { name: string }>nativeAudioParam).name === 'playbackRate' && nativeAudioParam.maxValue === 1024) {\n                throw createNotSupportedError();\n            }\n\n            try {\n                this._nativeAudioNode.connect(nativeAudioParam, output);\n\n                if (isOffline || isPassiveAudioNode(this)) {\n                    this._nativeAudioNode.disconnect(nativeAudioParam, output);\n                }\n            } catch (err) {\n                // Bug #58: Safari doesn't throw an InvalidAccessError yet.\n                if (err.code === 12) {\n                    throw createInvalidAccessError();\n                }\n\n                throw err;\n            }\n\n            const isNewConnectionToAudioParam = addConnectionToAudioParamOfAudioContext(this, destination, output, isOffline);\n\n            // Bug #164: Only Firefox detects cycles so far.\n            if (isNewConnectionToAudioParam) {\n                const cycles = detectCycles([this], destination);\n\n                visitEachAudioNodeOnce(cycles, createIncrementCycleCounter(isOffline));\n            }\n        }\n\n        public disconnect(output?: number): void;\n        public disconnect<U extends TContext>(destinationNode: IAudioNode<U>, output?: number, input?: number): void;\n        public disconnect(destinationParam: IAudioParam, output?: number): void;\n        public disconnect<U extends TContext>(\n            destinationOrOutput?: number | IAudioNode<U> | IAudioParam,\n            output?: number,\n            input?: number\n        ): void {\n            let destinations: (IAudioNode<T> | IAudioParam)[];\n\n            const nativeContext = getNativeContext(this._context);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n\n            if (destinationOrOutput === undefined) {\n                destinations = deleteAnyConnection(this, isOffline);\n            } else if (typeof destinationOrOutput === 'number') {\n                if (destinationOrOutput < 0 || destinationOrOutput >= this.numberOfOutputs) {\n                    throw createIndexSizeError();\n                }\n\n                destinations = deleteConnectionAtOutput(this, isOffline, destinationOrOutput);\n            } else {\n                if (output !== undefined && (output < 0 || output >= this.numberOfOutputs)) {\n                    throw createIndexSizeError();\n                }\n\n                if (isAudioNode(destinationOrOutput) && input !== undefined && (input < 0 || input >= destinationOrOutput.numberOfInputs)) {\n                    throw createIndexSizeError();\n                }\n\n                destinations = deleteConnectionToDestination(this, isOffline, destinationOrOutput, output, input);\n\n                if (destinations.length === 0) {\n                    throw createInvalidAccessError();\n                }\n            }\n\n            // Bug #164: Only Firefox detects cycles so far.\n            for (const destination of destinations) {\n                const cycles = detectCycles([this], destination);\n\n                visitEachAudioNodeOnce(cycles, decrementCycleCounter);\n            }\n        }\n    };\n};\n", "import { AutomationEventList } from 'automation-events';\nimport { IAudioNode, IAudioParam, IAudioParamRenderer, IMinimalOfflineAudioContext, IOfflineAudioContext } from '../interfaces';\nimport { TAudioParamFactoryFactory, TContext, TNativeAudioParam } from '../types';\n\nexport const createAudioParamFactory: TAudioParamFactoryFactory = (\n    addAudioParamConnections,\n    audioParamAudioNodeStore,\n    audioParamStore,\n    createAudioParamRenderer,\n    createCancelAndHoldAutomationEvent,\n    createCancelScheduledValuesAutomationEvent,\n    createExponentialRampToValueAutomationEvent,\n    createLinearRampToValueAutomationEvent,\n    createSetTargetAutomationEvent,\n    createSetValueAutomationEvent,\n    createSetValueCurveAutomationEvent,\n    nativeAudioContextConstructor,\n    setValueAtTimeUntilPossible\n) => {\n    return <T extends TContext>(\n        audioNode: IAudioNode<T>,\n        isAudioParamOfOfflineAudioContext: boolean,\n        nativeAudioParam: TNativeAudioParam,\n        maxValue: null | number = null,\n        minValue: null | number = null\n    ): IAudioParam => {\n        // Bug #196 Only Safari sets the defaultValue to the initial value.\n        const defaultValue = nativeAudioParam.value;\n        const automationEventList = new AutomationEventList(defaultValue);\n        const audioParamRenderer = isAudioParamOfOfflineAudioContext ? createAudioParamRenderer(automationEventList) : null;\n        const audioParam = {\n            get defaultValue(): number {\n                return defaultValue;\n            },\n            get maxValue(): number {\n                return maxValue === null ? nativeAudioParam.maxValue : maxValue;\n            },\n            get minValue(): number {\n                return minValue === null ? nativeAudioParam.minValue : minValue;\n            },\n            get value(): number {\n                return nativeAudioParam.value;\n            },\n            set value(value) {\n                nativeAudioParam.value = value;\n\n                // Bug #98: Firefox & Safari do not yet treat the value setter like a call to setValueAtTime().\n                audioParam.setValueAtTime(value, audioNode.context.currentTime);\n            },\n            cancelAndHoldAtTime(cancelTime: number): IAudioParam {\n                // Bug #28: Firefox & Safari do not yet implement cancelAndHoldAtTime().\n                if (typeof nativeAudioParam.cancelAndHoldAtTime === 'function') {\n                    if (audioParamRenderer === null) {\n                        automationEventList.flush(audioNode.context.currentTime);\n                    }\n\n                    automationEventList.add(createCancelAndHoldAutomationEvent(cancelTime));\n                    nativeAudioParam.cancelAndHoldAtTime(cancelTime);\n                } else {\n                    const previousLastEvent = Array.from(automationEventList).pop();\n\n                    if (audioParamRenderer === null) {\n                        automationEventList.flush(audioNode.context.currentTime);\n                    }\n\n                    automationEventList.add(createCancelAndHoldAutomationEvent(cancelTime));\n\n                    const currentLastEvent = Array.from(automationEventList).pop();\n\n                    nativeAudioParam.cancelScheduledValues(cancelTime);\n\n                    if (previousLastEvent !== currentLastEvent && currentLastEvent !== undefined) {\n                        if (currentLastEvent.type === 'exponentialRampToValue') {\n                            nativeAudioParam.exponentialRampToValueAtTime(currentLastEvent.value, currentLastEvent.endTime);\n                        } else if (currentLastEvent.type === 'linearRampToValue') {\n                            nativeAudioParam.linearRampToValueAtTime(currentLastEvent.value, currentLastEvent.endTime);\n                        } else if (currentLastEvent.type === 'setValue') {\n                            nativeAudioParam.setValueAtTime(currentLastEvent.value, currentLastEvent.startTime);\n                        } else if (currentLastEvent.type === 'setValueCurve') {\n                            nativeAudioParam.setValueCurveAtTime(\n                                currentLastEvent.values,\n                                currentLastEvent.startTime,\n                                currentLastEvent.duration\n                            );\n                        }\n                    }\n                }\n\n                return audioParam;\n            },\n            cancelScheduledValues(cancelTime: number): IAudioParam {\n                if (audioParamRenderer === null) {\n                    automationEventList.flush(audioNode.context.currentTime);\n                }\n\n                automationEventList.add(createCancelScheduledValuesAutomationEvent(cancelTime));\n                nativeAudioParam.cancelScheduledValues(cancelTime);\n\n                return audioParam;\n            },\n            exponentialRampToValueAtTime(value: number, endTime: number): IAudioParam {\n                // Bug #45: Safari does not throw an error yet.\n                if (value === 0) {\n                    throw new RangeError();\n                }\n\n                // Bug #187: Safari does not throw an error yet.\n                if (!Number.isFinite(endTime) || endTime < 0) {\n                    throw new RangeError();\n                }\n\n                const currentTime = audioNode.context.currentTime;\n\n                if (audioParamRenderer === null) {\n                    automationEventList.flush(currentTime);\n                }\n\n                // Bug #194: Firefox does not implicitly call setValueAtTime() if there is no previous event.\n                if (Array.from(automationEventList).length === 0) {\n                    automationEventList.add(createSetValueAutomationEvent(defaultValue, currentTime));\n                    nativeAudioParam.setValueAtTime(defaultValue, currentTime);\n                }\n\n                automationEventList.add(createExponentialRampToValueAutomationEvent(value, endTime));\n                nativeAudioParam.exponentialRampToValueAtTime(value, endTime);\n\n                return audioParam;\n            },\n            linearRampToValueAtTime(value: number, endTime: number): IAudioParam {\n                const currentTime = audioNode.context.currentTime;\n\n                if (audioParamRenderer === null) {\n                    automationEventList.flush(currentTime);\n                }\n\n                // Bug #195: Firefox does not implicitly call setValueAtTime() if there is no previous event.\n                if (Array.from(automationEventList).length === 0) {\n                    automationEventList.add(createSetValueAutomationEvent(defaultValue, currentTime));\n                    nativeAudioParam.setValueAtTime(defaultValue, currentTime);\n                }\n\n                automationEventList.add(createLinearRampToValueAutomationEvent(value, endTime));\n                nativeAudioParam.linearRampToValueAtTime(value, endTime);\n\n                return audioParam;\n            },\n            setTargetAtTime(target: number, startTime: number, timeConstant: number): IAudioParam {\n                if (audioParamRenderer === null) {\n                    automationEventList.flush(audioNode.context.currentTime);\n                }\n\n                automationEventList.add(createSetTargetAutomationEvent(target, startTime, timeConstant));\n                nativeAudioParam.setTargetAtTime(target, startTime, timeConstant);\n\n                return audioParam;\n            },\n            setValueAtTime(value: number, startTime: number): IAudioParam {\n                if (audioParamRenderer === null) {\n                    automationEventList.flush(audioNode.context.currentTime);\n                }\n\n                automationEventList.add(createSetValueAutomationEvent(value, startTime));\n                nativeAudioParam.setValueAtTime(value, startTime);\n\n                return audioParam;\n            },\n            setValueCurveAtTime(values: Iterable<number>, startTime: number, duration: number): IAudioParam {\n                // Bug 183: Safari only accepts a Float32Array.\n                const convertedValues = values instanceof Float32Array ? values : new Float32Array(values);\n                /*\n                 * Bug #152: Safari does not correctly interpolate the values of the curve.\n                 * @todo Unfortunately there is no way to test for this behavior in a synchronous fashion which is why testing for the\n                 * existence of the webkitAudioContext is used as a workaround here.\n                 */\n                if (nativeAudioContextConstructor !== null && nativeAudioContextConstructor.name === 'webkitAudioContext') {\n                    const endTime = startTime + duration;\n                    const sampleRate = audioNode.context.sampleRate;\n                    const firstSample = Math.ceil(startTime * sampleRate);\n                    const lastSample = Math.floor(endTime * sampleRate);\n                    const numberOfInterpolatedValues = lastSample - firstSample;\n                    const interpolatedValues = new Float32Array(numberOfInterpolatedValues);\n\n                    for (let i = 0; i < numberOfInterpolatedValues; i += 1) {\n                        const theoreticIndex = ((convertedValues.length - 1) / duration) * ((firstSample + i) / sampleRate - startTime);\n                        const lowerIndex = Math.floor(theoreticIndex);\n                        const upperIndex = Math.ceil(theoreticIndex);\n\n                        interpolatedValues[i] =\n                            lowerIndex === upperIndex\n                                ? convertedValues[lowerIndex]\n                                : (1 - (theoreticIndex - lowerIndex)) * convertedValues[lowerIndex] +\n                                  (1 - (upperIndex - theoreticIndex)) * convertedValues[upperIndex];\n                    }\n\n                    if (audioParamRenderer === null) {\n                        automationEventList.flush(audioNode.context.currentTime);\n                    }\n\n                    automationEventList.add(createSetValueCurveAutomationEvent(interpolatedValues, startTime, duration));\n                    nativeAudioParam.setValueCurveAtTime(interpolatedValues, startTime, duration);\n\n                    const timeOfLastSample = lastSample / sampleRate;\n\n                    if (timeOfLastSample < endTime) {\n                        setValueAtTimeUntilPossible(audioParam, interpolatedValues[interpolatedValues.length - 1], timeOfLastSample);\n                    }\n\n                    setValueAtTimeUntilPossible(audioParam, convertedValues[convertedValues.length - 1], endTime);\n                } else {\n                    if (audioParamRenderer === null) {\n                        automationEventList.flush(audioNode.context.currentTime);\n                    }\n\n                    automationEventList.add(createSetValueCurveAutomationEvent(convertedValues, startTime, duration));\n                    nativeAudioParam.setValueCurveAtTime(convertedValues, startTime, duration);\n                }\n\n                return audioParam;\n            }\n        };\n\n        audioParamStore.set(audioParam, nativeAudioParam);\n        audioParamAudioNodeStore.set(audioParam, audioNode);\n\n        addAudioParamConnections(\n            audioParam,\n            <T extends IMinimalOfflineAudioContext | IOfflineAudioContext ? IAudioParamRenderer : null>audioParamRenderer\n        );\n\n        return audioParam;\n    };\n};\n", "import { TAudioParamRendererFactory, TNativeAudioParam } from '../types';\n\nexport const createAudioParamRenderer: TAudioParamRendererFactory = (automationEventList) => {\n    return {\n        replay(audioParam: TNativeAudioParam): void {\n            for (const automationEvent of automationEventList) {\n                if (automationEvent.type === 'exponentialRampToValue') {\n                    const { endTime, value } = automationEvent;\n\n                    audioParam.exponentialRampToValueAtTime(value, endTime);\n                } else if (automationEvent.type === 'linearRampToValue') {\n                    const { endTime, value } = automationEvent;\n\n                    audioParam.linearRampToValueAtTime(value, endTime);\n                } else if (automationEvent.type === 'setTarget') {\n                    const { startTime, target, timeConstant } = automationEvent;\n\n                    audioParam.setTargetAtTime(target, startTime, timeConstant);\n                } else if (automationEvent.type === 'setValue') {\n                    const { startTime, value } = automationEvent;\n\n                    audioParam.setValueAtTime(value, startTime);\n                } else if (automationEvent.type === 'setValueCurve') {\n                    const { duration, startTime, values } = automationEvent;\n\n                    audioParam.setValueCurveAtTime(values, startTime, duration);\n                } else {\n                    throw new Error(\"Can't apply an unknown automation.\");\n                }\n            }\n        }\n    };\n};\n", "import { IReadOnlyMap } from './interfaces';\n\nexport class ReadOnlyMap<T, U> implements IReadOnlyMap<T, U> {\n    private _map: Map<T, U>;\n\n    constructor(parameters: [T, U][]) {\n        this._map = new Map(parameters);\n    }\n\n    get size(): number {\n        return this._map.size;\n    }\n\n    public entries(): IterableIterator<[T, U]> {\n        return this._map.entries();\n    }\n\n    public forEach(callback: (audioParam: U, name: T, map: ReadOnlyMap<T, U>) => void, thisArg: any = null): void {\n        return this._map.forEach((value: U, key: T) => callback.call(thisArg, value, key, this));\n    }\n\n    public get(name: T): undefined | U {\n        return this._map.get(name);\n    }\n\n    public has(name: T): boolean {\n        return this._map.has(name);\n    }\n\n    public keys(): IterableIterator<T> {\n        return this._map.keys();\n    }\n\n    public values(): IterableIterator<U> {\n        return this._map.values();\n    }\n}\n", "import { NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS } from '../globals';\nimport {\n    IAudioParam,\n    IAudioWorkletNode,\n    IAudioWorkletNodeEventMap,\n    IAudioWorkletNodeOptions,\n    IMinimalAudioContext,\n    IMinimalOfflineAudioContext,\n    IOfflineAudioContext,\n    IReadOnlyMap\n} from '../interfaces';\nimport { ReadOnlyMap } from '../read-only-map';\nimport {\n    TAudioNodeRenderer,\n    TAudioParamMap,\n    TAudioWorkletNodeConstructorFactory,\n    TContext,\n    TErrorEventHandler,\n    TNativeAudioContext,\n    TNativeAudioParam,\n    TNativeAudioWorkletNode\n} from '../types';\n\nconst DEFAULT_OPTIONS = {\n    channelCount: 2,\n    // Bug #61: The channelCountMode should be 'max' according to the spec but is set to 'explicit' to achieve consistent behavior.\n    channelCountMode: 'explicit',\n    channelInterpretation: 'speakers',\n    numberOfInputs: 1,\n    numberOfOutputs: 1,\n    parameterData: {},\n    processorOptions: {}\n} as const;\n\nexport const createAudioWorkletNodeConstructor: TAudioWorkletNodeConstructorFactory = (\n    addUnrenderedAudioWorkletNode,\n    audioNodeConstructor,\n    createAudioParam,\n    createAudioWorkletNodeRenderer,\n    createNativeAudioWorkletNode,\n    getAudioNodeConnections,\n    getBackupOfflineAudioContext,\n    getNativeContext,\n    isNativeOfflineAudioContext,\n    nativeAudioWorkletNodeConstructor,\n    sanitizeAudioWorkletNodeOptions,\n    setActiveAudioWorkletNodeInputs,\n    testAudioWorkletNodeOptionsClonability,\n    wrapEventListener\n) => {\n    return class AudioWorkletNode<T extends TContext>\n        extends audioNodeConstructor<T, IAudioWorkletNodeEventMap>\n        implements IAudioWorkletNode<T>\n    {\n        private _nativeAudioWorkletNode: TNativeAudioWorkletNode;\n\n        private _onprocessorerror: null | TErrorEventHandler<this>;\n\n        private _parameters: null | TAudioParamMap;\n\n        constructor(context: T, name: string, options?: Partial<IAudioWorkletNodeOptions>) {\n            const nativeContext = getNativeContext(context);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            const mergedOptions = sanitizeAudioWorkletNodeOptions({ ...DEFAULT_OPTIONS, ...options });\n\n            // Bug #191: Safari doesn't throw an error if the options aren't clonable.\n            testAudioWorkletNodeOptionsClonability(mergedOptions);\n\n            const nodeNameToProcessorConstructorMap = NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS.get(nativeContext);\n            const processorConstructor = nodeNameToProcessorConstructorMap?.get(name);\n            // Bug #186: Chrome and Edge do not allow to create an AudioWorkletNode on a closed AudioContext.\n            const nativeContextOrBackupOfflineAudioContext =\n                isOffline || nativeContext.state !== 'closed'\n                    ? nativeContext\n                    : getBackupOfflineAudioContext(<TNativeAudioContext>nativeContext) ?? nativeContext;\n            const nativeAudioWorkletNode = createNativeAudioWorkletNode(\n                nativeContextOrBackupOfflineAudioContext,\n                isOffline ? null : (<IMinimalAudioContext>(<any>context)).baseLatency,\n                nativeAudioWorkletNodeConstructor,\n                name,\n                processorConstructor,\n                mergedOptions\n            );\n            const audioWorkletNodeRenderer = <TAudioNodeRenderer<T, this>>(\n                (isOffline ? createAudioWorkletNodeRenderer(name, mergedOptions, processorConstructor) : null)\n            );\n\n            /*\n             * @todo Add a mechanism to switch an AudioWorkletNode to passive once the process() function of the AudioWorkletProcessor\n             * returns false.\n             */\n            super(context, true, nativeAudioWorkletNode, audioWorkletNodeRenderer);\n\n            const parameters: [string, IAudioParam][] = [];\n\n            nativeAudioWorkletNode.parameters.forEach((nativeAudioParam, nm) => {\n                const audioParam = createAudioParam(this, isOffline, nativeAudioParam);\n\n                parameters.push([nm, audioParam]);\n            });\n\n            this._nativeAudioWorkletNode = nativeAudioWorkletNode;\n            this._onprocessorerror = null;\n            this._parameters = new ReadOnlyMap(parameters);\n\n            /*\n             * Bug #86 & #87: Invoking the renderer of an AudioWorkletNode might be necessary if it has no direct or indirect connection to\n             * the destination.\n             */\n            if (isOffline) {\n                addUnrenderedAudioWorkletNode(nativeContext, <IAudioWorkletNode<IMinimalOfflineAudioContext | IOfflineAudioContext>>this);\n            }\n\n            const { activeInputs } = getAudioNodeConnections(this);\n\n            setActiveAudioWorkletNodeInputs(nativeAudioWorkletNode, activeInputs);\n        }\n\n        get onprocessorerror(): null | TErrorEventHandler<this> {\n            return this._onprocessorerror;\n        }\n\n        set onprocessorerror(value) {\n            const wrappedListener = typeof value === 'function' ? wrapEventListener(this, <EventListenerOrEventListenerObject>value) : null;\n\n            this._nativeAudioWorkletNode.onprocessorerror = wrappedListener;\n\n            const nativeOnProcessorError = this._nativeAudioWorkletNode.onprocessorerror;\n\n            this._onprocessorerror =\n                nativeOnProcessorError !== null && nativeOnProcessorError === wrappedListener\n                    ? value\n                    : <null | TErrorEventHandler<this>>nativeOnProcessorError;\n        }\n\n        get parameters(): TAudioParamMap {\n            if (this._parameters === null) {\n                // @todo The definition that TypeScript uses of the AudioParamMap is lacking many methods.\n                return <IReadOnlyMap<string, TNativeAudioParam>>this._nativeAudioWorkletNode.parameters;\n            }\n\n            return this._parameters;\n        }\n\n        get port(): MessagePort {\n            return this._nativeAudioWorkletNode.port;\n        }\n    };\n};\n", "import { TNativeAudioBuffer } from '../types';\n\nexport function copyFromChannel(\n    audioBuffer: TNativeAudioBuffer,\n    parent: { [key: number]: Float32Array },\n    key: number,\n    channelNumber: number,\n    bufferOffset: number\n): void;\nexport function copyFromChannel(\n    audioBuffer: TNativeAudioBuffer,\n    parent: { [key: string]: Float32Array },\n    key: string,\n    channelNumber: number,\n    bufferOffset: number\n): void;\nexport function copyFromChannel(\n    audioBuffer: TNativeAudioBuffer,\n    // @todo There is currently no way to define something like { [ key: number | string ]: Float32Array }\n    parent: any,\n    key: number | string,\n    channelNumber: number,\n    bufferOffset: number\n): void {\n    if (typeof audioBuffer.copyFromChannel === 'function') {\n        // The byteLength will be 0 when the ArrayBuffer was transferred.\n        if (parent[key].byteLength === 0) {\n            parent[key] = new Float32Array(128);\n        }\n\n        audioBuffer.copyFromChannel(parent[key], channelNumber, bufferOffset);\n\n        // Bug #5: Safari does not support copyFromChannel().\n    } else {\n        const channelData = audioBuffer.getChannelData(channelNumber);\n\n        // The byteLength will be 0 when the ArrayBuffer was transferred.\n        if (parent[key].byteLength === 0) {\n            parent[key] = channelData.slice(bufferOffset, bufferOffset + 128);\n        } else {\n            const slicedInput = new Float32Array(channelData.buffer, bufferOffset * Float32Array.BYTES_PER_ELEMENT, 128);\n\n            parent[key].set(slicedInput);\n        }\n    }\n}\n", "import { TNativeAudioBuffer } from '../types';\n\nexport const copyToChannel = (\n    audioBuffer: TNativeAudioBuffer,\n    parent: { [key: number]: Float32Array },\n    key: number,\n    channelNumber: number,\n    bufferOffset: number\n): void => {\n    if (typeof audioBuffer.copyToChannel === 'function') {\n        // The byteLength will be 0 when the ArrayBuffer was transferred.\n        if (parent[key].byteLength !== 0) {\n            audioBuffer.copyToChannel(parent[key], channelNumber, bufferOffset);\n        }\n\n        // Bug #5: Safari does not support copyToChannel().\n    } else {\n        // The byteLength will be 0 when the ArrayBuffer was transferred.\n        if (parent[key].byteLength !== 0) {\n            audioBuffer.getChannelData(channelNumber).set(parent[key], bufferOffset);\n        }\n    }\n};\n", "export const createNestedArrays = (x: number, y: number | number[]): Float32Array[][] => {\n    const arrays: Float32Array[][] = [];\n\n    for (let i = 0; i < x; i += 1) {\n        const array = [];\n\n        const length = typeof y === 'number' ? y : y[i];\n\n        for (let j = 0; j < length; j += 1) {\n            array.push(new Float32Array(128));\n        }\n\n        arrays.push(array);\n    }\n\n    return arrays;\n};\n", "import { NODE_TO_PROCESSOR_MAPS } from '../globals';\nimport { IAudioNode, IAudioWorkletProcessor } from '../interfaces';\nimport { TContext, TNativeAudioWorkletNode, TNativeOfflineAudioContext } from '../types';\nimport { getNativeAudioNode } from './get-native-audio-node';\nimport { getValueForKey } from './get-value-for-key';\n\nexport const getAudioWorkletProcessor = <T extends TContext>(\n    nativeOfflineAudioContext: TNativeOfflineAudioContext,\n    proxy: IAudioNode<T>\n): Promise<IAudioWorkletProcessor> => {\n    const nodeToProcessorMap = getValueForKey(NODE_TO_PROCESSOR_MAPS, nativeOfflineAudioContext);\n    const nativeAudioWorkletNode = getNativeAudioNode<T, TNativeAudioWorkletNode>(proxy);\n\n    return getValueForKey(nodeToProcessorMap, nativeAudioWorkletNode);\n};\n", "import { copyFromChannel } from '../helpers/copy-from-channel';\nimport { copyToChannel } from '../helpers/copy-to-channel';\nimport { createNestedArrays } from '../helpers/create-nested-arrays';\nimport { getAudioNodeConnections } from '../helpers/get-audio-node-connections';\nimport { getAudioWorkletProcessor } from '../helpers/get-audio-worklet-processor';\nimport { isOwnedByContext } from '../helpers/is-owned-by-context';\nimport {\n    IAudioWorkletNode,\n    IAudioWorkletNodeOptions,\n    IAudioWorkletProcessorConstructor,\n    IMinimalOfflineAudioContext,\n    IOfflineAudioContext,\n    IReadOnlyMap\n} from '../interfaces';\nimport {\n    TAudioWorkletNodeRendererFactoryFactory,\n    TExposeCurrentFrameAndCurrentTimeFunction,\n    TNativeAudioBuffer,\n    TNativeAudioNode,\n    TNativeAudioParam,\n    TNativeAudioWorkletNode,\n    TNativeChannelMergerNode,\n    TNativeChannelSplitterNode,\n    TNativeGainNode,\n    TNativeOfflineAudioContext\n} from '../types';\n\nconst processBuffer = async <T extends IMinimalOfflineAudioContext | IOfflineAudioContext>(\n    proxy: IAudioWorkletNode<T>,\n    renderedBuffer: null | TNativeAudioBuffer,\n    nativeOfflineAudioContext: TNativeOfflineAudioContext,\n    options: IAudioWorkletNodeOptions,\n    outputChannelCount: number[],\n    processorConstructor: undefined | IAudioWorkletProcessorConstructor,\n    exposeCurrentFrameAndCurrentTime: TExposeCurrentFrameAndCurrentTimeFunction\n): Promise<null | TNativeAudioBuffer> => {\n    // Ceil the length to the next full render quantum.\n    // Bug #17: Safari does not yet expose the length.\n    const length = renderedBuffer === null ? Math.ceil(proxy.context.length / 128) * 128 : renderedBuffer.length;\n    const numberOfInputChannels = options.channelCount * options.numberOfInputs;\n    const numberOfOutputChannels = outputChannelCount.reduce((sum, value) => sum + value, 0);\n    const processedBuffer =\n        numberOfOutputChannels === 0\n            ? null\n            : nativeOfflineAudioContext.createBuffer(numberOfOutputChannels, length, nativeOfflineAudioContext.sampleRate);\n\n    if (processorConstructor === undefined) {\n        throw new Error('Missing the processor constructor.');\n    }\n\n    const audioNodeConnections = getAudioNodeConnections(proxy);\n    const audioWorkletProcessor = await getAudioWorkletProcessor(nativeOfflineAudioContext, proxy);\n    const inputs = createNestedArrays(options.numberOfInputs, options.channelCount);\n    const outputs = createNestedArrays(options.numberOfOutputs, outputChannelCount);\n    const parameters: { [name: string]: Float32Array } = Array.from(proxy.parameters.keys()).reduce(\n        (prmtrs, name) => ({ ...prmtrs, [name]: new Float32Array(128) }),\n        {}\n    );\n\n    for (let i = 0; i < length; i += 128) {\n        if (options.numberOfInputs > 0 && renderedBuffer !== null) {\n            for (let j = 0; j < options.numberOfInputs; j += 1) {\n                for (let k = 0; k < options.channelCount; k += 1) {\n                    copyFromChannel(renderedBuffer, inputs[j], k, k, i);\n                }\n            }\n        }\n\n        if (processorConstructor.parameterDescriptors !== undefined && renderedBuffer !== null) {\n            processorConstructor.parameterDescriptors.forEach(({ name }, index) => {\n                copyFromChannel(renderedBuffer, parameters, name, numberOfInputChannels + index, i);\n            });\n        }\n\n        for (let j = 0; j < options.numberOfInputs; j += 1) {\n            for (let k = 0; k < outputChannelCount[j]; k += 1) {\n                // The byteLength will be 0 when the ArrayBuffer was transferred.\n                if (outputs[j][k].byteLength === 0) {\n                    outputs[j][k] = new Float32Array(128);\n                }\n            }\n        }\n\n        try {\n            const potentiallyEmptyInputs = inputs.map((input, index) => {\n                if (audioNodeConnections.activeInputs[index].size === 0) {\n                    return [];\n                }\n\n                return input;\n            });\n            const activeSourceFlag = exposeCurrentFrameAndCurrentTime(\n                i / nativeOfflineAudioContext.sampleRate,\n                nativeOfflineAudioContext.sampleRate,\n                () => audioWorkletProcessor.process(potentiallyEmptyInputs, outputs, parameters)\n            );\n\n            if (processedBuffer !== null) {\n                for (let j = 0, outputChannelSplitterNodeOutput = 0; j < options.numberOfOutputs; j += 1) {\n                    for (let k = 0; k < outputChannelCount[j]; k += 1) {\n                        copyToChannel(processedBuffer, outputs[j], k, outputChannelSplitterNodeOutput + k, i);\n                    }\n\n                    outputChannelSplitterNodeOutput += outputChannelCount[j];\n                }\n            }\n\n            if (!activeSourceFlag) {\n                break;\n            }\n        } catch (error) {\n            proxy.dispatchEvent(\n                new ErrorEvent('processorerror', {\n                    colno: error.colno,\n                    filename: error.filename,\n                    lineno: error.lineno,\n                    message: error.message\n                })\n            );\n\n            break;\n        }\n    }\n\n    return processedBuffer;\n};\n\nexport const createAudioWorkletNodeRendererFactory: TAudioWorkletNodeRendererFactoryFactory = (\n    connectAudioParam,\n    connectMultipleOutputs,\n    createNativeAudioBufferSourceNode,\n    createNativeChannelMergerNode,\n    createNativeChannelSplitterNode,\n    createNativeConstantSourceNode,\n    createNativeGainNode,\n    deleteUnrenderedAudioWorkletNode,\n    disconnectMultipleOutputs,\n    exposeCurrentFrameAndCurrentTime,\n    getNativeAudioNode,\n    nativeAudioWorkletNodeConstructor,\n    nativeOfflineAudioContextConstructor,\n    renderAutomation,\n    renderInputsOfAudioNode,\n    renderNativeOfflineAudioContext\n) => {\n    return <T extends IMinimalOfflineAudioContext | IOfflineAudioContext>(\n        name: string,\n        options: IAudioWorkletNodeOptions,\n        processorConstructor: undefined | IAudioWorkletProcessorConstructor\n    ) => {\n        const renderedNativeAudioNodes = new WeakMap<TNativeOfflineAudioContext, TNativeAudioWorkletNode | TNativeGainNode>();\n\n        let processedBufferPromise: null | Promise<null | TNativeAudioBuffer> = null;\n\n        const createAudioNode = async (proxy: IAudioWorkletNode<T>, nativeOfflineAudioContext: TNativeOfflineAudioContext) => {\n            let nativeAudioWorkletNode = getNativeAudioNode<T, TNativeAudioWorkletNode>(proxy);\n            let nativeOutputNodes: null | [TNativeChannelSplitterNode, TNativeChannelMergerNode[], TNativeGainNode] = null;\n\n            const nativeAudioWorkletNodeIsOwnedByContext = isOwnedByContext(nativeAudioWorkletNode, nativeOfflineAudioContext);\n            const outputChannelCount = Array.isArray(options.outputChannelCount)\n                ? options.outputChannelCount\n                : Array.from(options.outputChannelCount);\n\n            // Bug #61: Only Chrome, Edge & Firefox have an implementation of the AudioWorkletNode yet.\n            if (nativeAudioWorkletNodeConstructor === null) {\n                const numberOfOutputChannels = outputChannelCount.reduce((sum, value) => sum + value, 0);\n                const outputChannelSplitterNode = createNativeChannelSplitterNode(nativeOfflineAudioContext, {\n                    channelCount: Math.max(1, numberOfOutputChannels),\n                    channelCountMode: 'explicit',\n                    channelInterpretation: 'discrete',\n                    numberOfOutputs: Math.max(1, numberOfOutputChannels)\n                });\n                const outputChannelMergerNodes: TNativeChannelMergerNode[] = [];\n\n                for (let i = 0; i < proxy.numberOfOutputs; i += 1) {\n                    outputChannelMergerNodes.push(\n                        createNativeChannelMergerNode(nativeOfflineAudioContext, {\n                            channelCount: 1,\n                            channelCountMode: 'explicit',\n                            channelInterpretation: 'speakers',\n                            numberOfInputs: outputChannelCount[i]\n                        })\n                    );\n                }\n\n                const outputGainNode = createNativeGainNode(nativeOfflineAudioContext, {\n                    channelCount: options.channelCount,\n                    channelCountMode: options.channelCountMode,\n                    channelInterpretation: options.channelInterpretation,\n                    gain: 1\n                });\n\n                outputGainNode.connect = <TNativeAudioNode['connect']>connectMultipleOutputs.bind(null, outputChannelMergerNodes);\n                outputGainNode.disconnect = <TNativeAudioNode['disconnect']>disconnectMultipleOutputs.bind(null, outputChannelMergerNodes);\n\n                nativeOutputNodes = [outputChannelSplitterNode, outputChannelMergerNodes, outputGainNode];\n            } else if (!nativeAudioWorkletNodeIsOwnedByContext) {\n                nativeAudioWorkletNode = new nativeAudioWorkletNodeConstructor(nativeOfflineAudioContext, name);\n            }\n\n            renderedNativeAudioNodes.set(\n                nativeOfflineAudioContext,\n                nativeOutputNodes === null ? nativeAudioWorkletNode : nativeOutputNodes[2]\n            );\n\n            if (nativeOutputNodes !== null) {\n                if (processedBufferPromise === null) {\n                    if (processorConstructor === undefined) {\n                        throw new Error('Missing the processor constructor.');\n                    }\n\n                    if (nativeOfflineAudioContextConstructor === null) {\n                        throw new Error('Missing the native OfflineAudioContext constructor.');\n                    }\n\n                    // Bug #47: The AudioDestinationNode in Safari gets not initialized correctly.\n                    const numberOfInputChannels = proxy.channelCount * proxy.numberOfInputs;\n                    const numberOfParameters =\n                        processorConstructor.parameterDescriptors === undefined ? 0 : processorConstructor.parameterDescriptors.length;\n                    const numberOfChannels = numberOfInputChannels + numberOfParameters;\n\n                    const renderBuffer = async () => {\n                        const partialOfflineAudioContext = new nativeOfflineAudioContextConstructor(\n                            numberOfChannels,\n                            // Ceil the length to the next full render quantum.\n                            // Bug #17: Safari does not yet expose the length.\n                            Math.ceil(proxy.context.length / 128) * 128,\n                            nativeOfflineAudioContext.sampleRate\n                        );\n                        const gainNodes: TNativeGainNode[] = [];\n                        const inputChannelSplitterNodes = [];\n\n                        for (let i = 0; i < options.numberOfInputs; i += 1) {\n                            gainNodes.push(\n                                createNativeGainNode(partialOfflineAudioContext, {\n                                    channelCount: options.channelCount,\n                                    channelCountMode: options.channelCountMode,\n                                    channelInterpretation: options.channelInterpretation,\n                                    gain: 1\n                                })\n                            );\n                            inputChannelSplitterNodes.push(\n                                createNativeChannelSplitterNode(partialOfflineAudioContext, {\n                                    channelCount: options.channelCount,\n                                    channelCountMode: 'explicit',\n                                    channelInterpretation: 'discrete',\n                                    numberOfOutputs: options.channelCount\n                                })\n                            );\n                        }\n\n                        const constantSourceNodes = await Promise.all(\n                            Array.from(proxy.parameters.values()).map(async (audioParam) => {\n                                const constantSourceNode = createNativeConstantSourceNode(partialOfflineAudioContext, {\n                                    channelCount: 1,\n                                    channelCountMode: 'explicit',\n                                    channelInterpretation: 'discrete',\n                                    offset: audioParam.value\n                                });\n\n                                await renderAutomation(partialOfflineAudioContext, audioParam, constantSourceNode.offset);\n\n                                return constantSourceNode;\n                            })\n                        );\n\n                        const inputChannelMergerNode = createNativeChannelMergerNode(partialOfflineAudioContext, {\n                            channelCount: 1,\n                            channelCountMode: 'explicit',\n                            channelInterpretation: 'speakers',\n                            numberOfInputs: Math.max(1, numberOfInputChannels + numberOfParameters)\n                        });\n\n                        for (let i = 0; i < options.numberOfInputs; i += 1) {\n                            gainNodes[i].connect(inputChannelSplitterNodes[i]);\n\n                            for (let j = 0; j < options.channelCount; j += 1) {\n                                inputChannelSplitterNodes[i].connect(inputChannelMergerNode, j, i * options.channelCount + j);\n                            }\n                        }\n\n                        for (const [index, constantSourceNode] of constantSourceNodes.entries()) {\n                            constantSourceNode.connect(inputChannelMergerNode, 0, numberOfInputChannels + index);\n                            constantSourceNode.start(0);\n                        }\n\n                        inputChannelMergerNode.connect(partialOfflineAudioContext.destination);\n\n                        await Promise.all(\n                            gainNodes.map((gainNode) => renderInputsOfAudioNode(proxy, partialOfflineAudioContext, gainNode))\n                        );\n\n                        return renderNativeOfflineAudioContext(partialOfflineAudioContext);\n                    };\n\n                    processedBufferPromise = processBuffer(\n                        proxy,\n                        numberOfChannels === 0 ? null : await renderBuffer(),\n                        nativeOfflineAudioContext,\n                        options,\n                        outputChannelCount,\n                        processorConstructor,\n                        exposeCurrentFrameAndCurrentTime\n                    );\n                }\n\n                const processedBuffer = await processedBufferPromise;\n                const audioBufferSourceNode = createNativeAudioBufferSourceNode(nativeOfflineAudioContext, {\n                    buffer: null,\n                    channelCount: 2,\n                    channelCountMode: 'max',\n                    channelInterpretation: 'speakers',\n                    loop: false,\n                    loopEnd: 0,\n                    loopStart: 0,\n                    playbackRate: 1\n                });\n                const [outputChannelSplitterNode, outputChannelMergerNodes, outputGainNode] = nativeOutputNodes;\n\n                if (processedBuffer !== null) {\n                    audioBufferSourceNode.buffer = processedBuffer;\n                    audioBufferSourceNode.start(0);\n                }\n\n                audioBufferSourceNode.connect(outputChannelSplitterNode);\n\n                for (let i = 0, outputChannelSplitterNodeOutput = 0; i < proxy.numberOfOutputs; i += 1) {\n                    const outputChannelMergerNode = outputChannelMergerNodes[i];\n\n                    for (let j = 0; j < outputChannelCount[i]; j += 1) {\n                        outputChannelSplitterNode.connect(outputChannelMergerNode, outputChannelSplitterNodeOutput + j, j);\n                    }\n\n                    outputChannelSplitterNodeOutput += outputChannelCount[i];\n                }\n\n                return outputGainNode;\n            }\n\n            if (!nativeAudioWorkletNodeIsOwnedByContext) {\n                for (const [nm, audioParam] of proxy.parameters.entries()) {\n                    await renderAutomation(\n                        nativeOfflineAudioContext,\n                        audioParam,\n                        // @todo The definition that TypeScript uses of the AudioParamMap is lacking many methods.\n                        <TNativeAudioParam>(<IReadOnlyMap<string, TNativeAudioParam>>nativeAudioWorkletNode.parameters).get(nm)\n                    );\n                }\n            } else {\n                for (const [nm, audioParam] of proxy.parameters.entries()) {\n                    await connectAudioParam(\n                        nativeOfflineAudioContext,\n                        audioParam,\n                        // @todo The definition that TypeScript uses of the AudioParamMap is lacking many methods.\n                        <TNativeAudioParam>(<IReadOnlyMap<string, TNativeAudioParam>>nativeAudioWorkletNode.parameters).get(nm)\n                    );\n                }\n            }\n\n            await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeAudioWorkletNode);\n\n            return nativeAudioWorkletNode;\n        };\n\n        return {\n            render(\n                proxy: IAudioWorkletNode<T>,\n                nativeOfflineAudioContext: TNativeOfflineAudioContext\n            ): Promise<TNativeAudioWorkletNode | TNativeGainNode> {\n                deleteUnrenderedAudioWorkletNode(nativeOfflineAudioContext, proxy);\n\n                const renderedNativeAudioWorkletNodeOrGainNode = renderedNativeAudioNodes.get(nativeOfflineAudioContext);\n\n                if (renderedNativeAudioWorkletNodeOrGainNode !== undefined) {\n                    return Promise.resolve(renderedNativeAudioWorkletNodeOrGainNode);\n                }\n\n                return createAudioNode(proxy, nativeOfflineAudioContext);\n            }\n        };\n    };\n};\n", "import {\n    IAnalyserNode,\n    IAudioBuffer,\n    IAudioBufferSourceNode,\n    IAudioNode,\n    IAudioWorklet,\n    IBaseAudioContext,\n    IBiquadFilterNode,\n    IConstantSourceNode,\n    IConvolverNode,\n    IDelayNode,\n    IDynamicsCompressorNode,\n    IGainNode,\n    IIIRFilterNode,\n    IOscillatorNode,\n    IPannerNode,\n    IPeriodicWave,\n    IPeriodicWaveConstraints,\n    IStereoPannerNode,\n    IWaveShaperNode,\n    IWorkletOptions\n} from '../interfaces';\nimport { TBaseAudioContextConstructorFactory, TContext, TDecodeErrorCallback, TDecodeSuccessCallback, TNativeContext } from '../types';\n\nexport const createBaseAudioContextConstructor: TBaseAudioContextConstructorFactory = (\n    addAudioWorkletModule,\n    analyserNodeConstructor,\n    audioBufferConstructor,\n    audioBufferSourceNodeConstructor,\n    biquadFilterNodeConstructor,\n    channelMergerNodeConstructor,\n    channelSplitterNodeConstructor,\n    constantSourceNodeConstructor,\n    convolverNodeConstructor,\n    decodeAudioData,\n    delayNodeConstructor,\n    dynamicsCompressorNodeConstructor,\n    gainNodeConstructor,\n    iIRFilterNodeConstructor,\n    minimalBaseAudioContextConstructor,\n    oscillatorNodeConstructor,\n    pannerNodeConstructor,\n    periodicWaveConstructor,\n    stereoPannerNodeConstructor,\n    waveShaperNodeConstructor\n) => {\n    return class BaseAudioContext<T extends TContext> extends minimalBaseAudioContextConstructor<T> implements IBaseAudioContext<T> {\n        private _audioWorklet: undefined | IAudioWorklet;\n\n        constructor(private _nativeContext: TNativeContext, numberOfChannels: number) {\n            super(_nativeContext, numberOfChannels);\n\n            this._audioWorklet =\n                addAudioWorkletModule === undefined\n                    ? undefined\n                    : {\n                          addModule: (moduleURL: string, options?: IWorkletOptions) => {\n                              return addAudioWorkletModule(<T>(<unknown>this), moduleURL, options);\n                          }\n                      };\n        }\n\n        get audioWorklet(): undefined | IAudioWorklet {\n            return this._audioWorklet;\n        }\n\n        public createAnalyser(): IAnalyserNode<T> {\n            return new analyserNodeConstructor(<T>(<unknown>this));\n        }\n\n        public createBiquadFilter(): IBiquadFilterNode<T> {\n            return new biquadFilterNodeConstructor(<T>(<unknown>this));\n        }\n\n        public createBuffer(numberOfChannels: number, length: number, sampleRate: number): IAudioBuffer {\n            return new audioBufferConstructor({ length, numberOfChannels, sampleRate });\n        }\n\n        public createBufferSource(): IAudioBufferSourceNode<T> {\n            return new audioBufferSourceNodeConstructor(<T>(<unknown>this));\n        }\n\n        public createChannelMerger(numberOfInputs = 6): IAudioNode<T> {\n            return new channelMergerNodeConstructor(<T>(<unknown>this), { numberOfInputs });\n        }\n\n        public createChannelSplitter(numberOfOutputs = 6): IAudioNode<T> {\n            return new channelSplitterNodeConstructor(<T>(<unknown>this), { numberOfOutputs });\n        }\n\n        public createConstantSource(): IConstantSourceNode<T> {\n            return new constantSourceNodeConstructor(<T>(<unknown>this));\n        }\n\n        public createConvolver(): IConvolverNode<T> {\n            return new convolverNodeConstructor(<T>(<unknown>this));\n        }\n\n        public createDelay(maxDelayTime = 1): IDelayNode<T> {\n            return new delayNodeConstructor(<T>(<unknown>this), { maxDelayTime });\n        }\n\n        public createDynamicsCompressor(): IDynamicsCompressorNode<T> {\n            return new dynamicsCompressorNodeConstructor(<T>(<unknown>this));\n        }\n\n        public createGain(): IGainNode<T> {\n            return new gainNodeConstructor(<T>(<unknown>this));\n        }\n\n        public createIIRFilter(feedforward: Iterable<number>, feedback: Iterable<number>): IIIRFilterNode<T> {\n            return new iIRFilterNodeConstructor(<T>(<unknown>this), { feedback, feedforward });\n        }\n\n        public createOscillator(): IOscillatorNode<T> {\n            return new oscillatorNodeConstructor(<T>(<unknown>this));\n        }\n\n        public createPanner(): IPannerNode<T> {\n            return new pannerNodeConstructor(<T>(<unknown>this));\n        }\n\n        public createPeriodicWave(\n            real: Iterable<number>,\n            imag: Iterable<number>,\n            constraints: Partial<IPeriodicWaveConstraints> = { disableNormalization: false }\n        ): IPeriodicWave {\n            return new periodicWaveConstructor(<T>(<unknown>this), { ...constraints, imag, real });\n        }\n\n        public createStereoPanner(): IStereoPannerNode<T> {\n            return new stereoPannerNodeConstructor(<T>(<unknown>this));\n        }\n\n        public createWaveShaper(): IWaveShaperNode<T> {\n            return new waveShaperNodeConstructor(<T>(<unknown>this));\n        }\n\n        public decodeAudioData(\n            audioData: ArrayBuffer,\n            successCallback?: TDecodeSuccessCallback,\n            errorCallback?: TDecodeErrorCallback\n        ): Promise<IAudioBuffer> {\n            return decodeAudioData(this._nativeContext, audioData).then(\n                (audioBuffer) => {\n                    if (typeof successCallback === 'function') {\n                        successCallback(audioBuffer);\n                    }\n\n                    return audioBuffer;\n                },\n                (err) => {\n                    if (typeof errorCallback === 'function') {\n                        errorCallback(err);\n                    }\n\n                    throw err;\n                }\n            );\n        }\n    };\n};\n", "import { MOST_NEGATIVE_SINGLE_FLOAT, MOST_POSITIVE_SINGLE_FLOAT } from '../constants';\nimport { IAudioParam, IBiquadFilterNode, IBiquadFilterOptions } from '../interfaces';\nimport { TAudioNodeRenderer, TBiquadFilterNodeConstructorFactory, TBiquadFilterType, TContext, TNativeBiquadFilterNode } from '../types';\n\nconst DEFAULT_OPTIONS = {\n    Q: 1,\n    channelCount: 2,\n    channelCountMode: 'max',\n    channelInterpretation: 'speakers',\n    detune: 0,\n    frequency: 350,\n    gain: 0,\n    type: 'lowpass'\n} as const;\n\nexport const createBiquadFilterNodeConstructor: TBiquadFilterNodeConstructorFactory = (\n    audioNodeConstructor,\n    createAudioParam,\n    createBiquadFilterNodeRenderer,\n    createInvalidAccessError,\n    createNativeBiquadFilterNode,\n    getNativeContext,\n    isNativeOfflineAudioContext,\n    setAudioNodeTailTime\n) => {\n    return class BiquadFilterNode<T extends TContext> extends audioNodeConstructor<T> implements IBiquadFilterNode<T> {\n        private _detune: IAudioParam;\n\n        private _frequency: IAudioParam;\n\n        private _gain: IAudioParam;\n\n        private _nativeBiquadFilterNode: TNativeBiquadFilterNode;\n\n        private _Q: IAudioParam;\n\n        constructor(context: T, options?: Partial<IBiquadFilterOptions>) {\n            const nativeContext = getNativeContext(context);\n            const mergedOptions = { ...DEFAULT_OPTIONS, ...options };\n            const nativeBiquadFilterNode = createNativeBiquadFilterNode(nativeContext, mergedOptions);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            const biquadFilterNodeRenderer = <TAudioNodeRenderer<T, this>>(isOffline ? createBiquadFilterNodeRenderer() : null);\n\n            super(context, false, nativeBiquadFilterNode, biquadFilterNodeRenderer);\n\n            // Bug #80: Safari does not export the correct values for maxValue and minValue.\n            this._Q = createAudioParam(this, isOffline, nativeBiquadFilterNode.Q, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);\n            // Bug #78: Firefox & Safari do not export the correct values for maxValue and minValue.\n            this._detune = createAudioParam(\n                this,\n                isOffline,\n                nativeBiquadFilterNode.detune,\n                1200 * Math.log2(MOST_POSITIVE_SINGLE_FLOAT),\n                -1200 * Math.log2(MOST_POSITIVE_SINGLE_FLOAT)\n            );\n            // Bug #77: Firefox & Safari do not export the correct value for minValue.\n            this._frequency = createAudioParam(this, isOffline, nativeBiquadFilterNode.frequency, context.sampleRate / 2, 0);\n            // Bug #79: Firefox & Safari do not export the correct values for maxValue and minValue.\n            this._gain = createAudioParam(\n                this,\n                isOffline,\n                nativeBiquadFilterNode.gain,\n                40 * Math.log10(MOST_POSITIVE_SINGLE_FLOAT),\n                MOST_NEGATIVE_SINGLE_FLOAT\n            );\n            this._nativeBiquadFilterNode = nativeBiquadFilterNode;\n\n            // @todo Determine a meaningful tail-time instead of just using one second.\n            setAudioNodeTailTime(this, 1);\n        }\n\n        get detune(): IAudioParam {\n            return this._detune;\n        }\n\n        get frequency(): IAudioParam {\n            return this._frequency;\n        }\n\n        get gain(): IAudioParam {\n            return this._gain;\n        }\n\n        get Q(): IAudioParam {\n            return this._Q;\n        }\n\n        get type(): TBiquadFilterType {\n            return this._nativeBiquadFilterNode.type;\n        }\n\n        set type(value) {\n            this._nativeBiquadFilterNode.type = value;\n        }\n\n        public getFrequencyResponse(frequencyHz: Float32Array, magResponse: Float32Array, phaseResponse: Float32Array): void {\n            // Bug #189: Safari does throw an InvalidStateError.\n            try {\n                this._nativeBiquadFilterNode.getFrequencyResponse(frequencyHz, magResponse, phaseResponse);\n            } catch (err) {\n                if (err.code === 11) {\n                    throw createInvalidAccessError();\n                }\n\n                throw err;\n            }\n\n            // Bug #68: Safari does not throw an error if the parameters differ in their length.\n            if (frequencyHz.length !== magResponse.length || magResponse.length !== phaseResponse.length) {\n                throw createInvalidAccessError();\n            }\n        }\n    };\n};\n", "import { isOwnedByContext } from '../helpers/is-owned-by-context';\nimport { IBiquadFilterNode, IMinimalOfflineAudioContext, IOfflineAudioContext } from '../interfaces';\nimport { TBiquadFilterNodeRendererFactoryFactory, TNativeBiquadFilterNode, TNativeOfflineAudioContext } from '../types';\n\nexport const createBiquadFilterNodeRendererFactory: TBiquadFilterNodeRendererFactoryFactory = (\n    connectAudioParam,\n    createNativeBiquadFilterNode,\n    getNativeAudioNode,\n    renderAutomation,\n    renderInputsOfAudioNode\n) => {\n    return <T extends IMinimalOfflineAudioContext | IOfflineAudioContext>() => {\n        const renderedNativeBiquadFilterNodes = new WeakMap<TNativeOfflineAudioContext, TNativeBiquadFilterNode>();\n\n        const createBiquadFilterNode = async (proxy: IBiquadFilterNode<T>, nativeOfflineAudioContext: TNativeOfflineAudioContext) => {\n            let nativeBiquadFilterNode = getNativeAudioNode<T, TNativeBiquadFilterNode>(proxy);\n\n            /*\n             * If the initially used nativeBiquadFilterNode was not constructed on the same OfflineAudioContext it needs to be created\n             * again.\n             */\n            const nativeBiquadFilterNodeIsOwnedByContext = isOwnedByContext(nativeBiquadFilterNode, nativeOfflineAudioContext);\n\n            if (!nativeBiquadFilterNodeIsOwnedByContext) {\n                const options = {\n                    Q: nativeBiquadFilterNode.Q.value,\n                    channelCount: nativeBiquadFilterNode.channelCount,\n                    channelCountMode: nativeBiquadFilterNode.channelCountMode,\n                    channelInterpretation: nativeBiquadFilterNode.channelInterpretation,\n                    detune: nativeBiquadFilterNode.detune.value,\n                    frequency: nativeBiquadFilterNode.frequency.value,\n                    gain: nativeBiquadFilterNode.gain.value,\n                    type: nativeBiquadFilterNode.type\n                };\n\n                nativeBiquadFilterNode = createNativeBiquadFilterNode(nativeOfflineAudioContext, options);\n            }\n\n            renderedNativeBiquadFilterNodes.set(nativeOfflineAudioContext, nativeBiquadFilterNode);\n\n            if (!nativeBiquadFilterNodeIsOwnedByContext) {\n                await renderAutomation(nativeOfflineAudioContext, proxy.Q, nativeBiquadFilterNode.Q);\n                await renderAutomation(nativeOfflineAudioContext, proxy.detune, nativeBiquadFilterNode.detune);\n                await renderAutomation(nativeOfflineAudioContext, proxy.frequency, nativeBiquadFilterNode.frequency);\n                await renderAutomation(nativeOfflineAudioContext, proxy.gain, nativeBiquadFilterNode.gain);\n            } else {\n                await connectAudioParam(nativeOfflineAudioContext, proxy.Q, nativeBiquadFilterNode.Q);\n                await connectAudioParam(nativeOfflineAudioContext, proxy.detune, nativeBiquadFilterNode.detune);\n                await connectAudioParam(nativeOfflineAudioContext, proxy.frequency, nativeBiquadFilterNode.frequency);\n                await connectAudioParam(nativeOfflineAudioContext, proxy.gain, nativeBiquadFilterNode.gain);\n            }\n\n            await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeBiquadFilterNode);\n\n            return nativeBiquadFilterNode;\n        };\n\n        return {\n            render(proxy: IBiquadFilterNode<T>, nativeOfflineAudioContext: TNativeOfflineAudioContext): Promise<TNativeBiquadFilterNode> {\n                const renderedNativeBiquadFilterNode = renderedNativeBiquadFilterNodes.get(nativeOfflineAudioContext);\n\n                if (renderedNativeBiquadFilterNode !== undefined) {\n                    return Promise.resolve(renderedNativeBiquadFilterNode);\n                }\n\n                return createBiquadFilterNode(proxy, nativeOfflineAudioContext);\n            }\n        };\n    };\n};\n", "import { TCacheTestResultFactory } from '../types';\n\nexport const createCacheTestResult: TCacheTestResultFactory = (ongoingTests, testResults) => {\n    return (tester, test) => {\n        const cachedTestResult = testResults.get(tester);\n\n        if (cachedTestResult !== undefined) {\n            return cachedTestResult;\n        }\n\n        const ongoingTest = ongoingTests.get(tester);\n\n        if (ongoingTest !== undefined) {\n            return ongoingTest;\n        }\n\n        try {\n            const synchronousTestResult = test();\n\n            if (synchronousTestResult instanceof Promise) {\n                ongoingTests.set(tester, synchronousTestResult);\n\n                return synchronousTestResult\n                    .catch(() => false)\n                    .then((finalTestResult) => {\n                        ongoingTests.delete(tester);\n                        testResults.set(tester, finalTestResult);\n\n                        return finalTestResult;\n                    });\n            }\n\n            testResults.set(tester, synchronousTestResult);\n\n            return synchronousTestResult;\n        } catch {\n            testResults.set(tester, false);\n\n            return false;\n        }\n    };\n};\n", "import { IChannelMergerOptions } from '../interfaces';\nimport { TAudioNodeRenderer, TChannelMergerNodeConstructorFactory, TContext } from '../types';\n\nconst DEFAULT_OPTIONS = {\n    channelCount: 1,\n    channelCountMode: 'explicit',\n    channelInterpretation: 'speakers',\n    numberOfInputs: 6\n} as const;\n\nexport const createChannelMergerNodeConstructor: TChannelMergerNodeConstructorFactory = (\n    audioNodeConstructor,\n    createChannelMergerNodeRenderer,\n    createNativeChannelMergerNode,\n    getNativeContext,\n    isNativeOfflineAudioContext\n) => {\n    return class ChannelMergerNode<T extends TContext> extends audioNodeConstructor<T> {\n        constructor(context: T, options?: Partial<IChannelMergerOptions>) {\n            const nativeContext = getNativeContext(context);\n            const mergedOptions = { ...DEFAULT_OPTIONS, ...options };\n            const nativeChannelMergerNode = createNativeChannelMergerNode(nativeContext, mergedOptions);\n            const channelMergerNodeRenderer = <TAudioNodeRenderer<T, this>>(\n                (isNativeOfflineAudioContext(nativeContext) ? createChannelMergerNodeRenderer() : null)\n            );\n\n            super(context, false, nativeChannelMergerNode, channelMergerNodeRenderer);\n        }\n    };\n};\n", "import { isOwnedByContext } from '../helpers/is-owned-by-context';\nimport { IAudioNode, IMinimalOfflineAudioContext, IOfflineAudioContext } from '../interfaces';\nimport { TChannelMergerNodeRendererFactoryFactory, TNativeAudioNode, TNativeOfflineAudioContext } from '../types';\n\nexport const createChannelMergerNodeRendererFactory: TChannelMergerNodeRendererFactoryFactory = (\n    createNativeChannelMergerNode,\n    getNativeAudioNode,\n    renderInputsOfAudioNode\n) => {\n    return <T extends IMinimalOfflineAudioContext | IOfflineAudioContext>() => {\n        const renderedNativeAudioNodes = new WeakMap<TNativeOfflineAudioContext, TNativeAudioNode>();\n\n        const createAudioNode = async (proxy: IAudioNode<T>, nativeOfflineAudioContext: TNativeOfflineAudioContext) => {\n            let nativeAudioNode = getNativeAudioNode<T, TNativeAudioNode>(proxy);\n\n            // If the initially used nativeAudioNode was not constructed on the same OfflineAudioContext it needs to be created again.\n            const nativeAudioNodeIsOwnedByContext = isOwnedByContext(nativeAudioNode, nativeOfflineAudioContext);\n\n            if (!nativeAudioNodeIsOwnedByContext) {\n                const options = {\n                    channelCount: nativeAudioNode.channelCount,\n                    channelCountMode: nativeAudioNode.channelCountMode,\n                    channelInterpretation: nativeAudioNode.channelInterpretation,\n                    numberOfInputs: nativeAudioNode.numberOfInputs\n                };\n\n                nativeAudioNode = createNativeChannelMergerNode(nativeOfflineAudioContext, options);\n            }\n\n            renderedNativeAudioNodes.set(nativeOfflineAudioContext, nativeAudioNode);\n\n            await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeAudioNode);\n\n            return nativeAudioNode;\n        };\n\n        return {\n            render(proxy: IAudioNode<T>, nativeOfflineAudioContext: TNativeOfflineAudioContext): Promise<TNativeAudioNode> {\n                const renderedNativeAudioNode = renderedNativeAudioNodes.get(nativeOfflineAudioContext);\n\n                if (renderedNativeAudioNode !== undefined) {\n                    return Promise.resolve(renderedNativeAudioNode);\n                }\n\n                return createAudioNode(proxy, nativeOfflineAudioContext);\n            }\n        };\n    };\n};\n", "import { IChannelSplitterOptions } from '../interfaces';\nimport { TAudioNodeRenderer, TChannelSplitterNodeConstructorFactory, TContext } from '../types';\n\nconst DEFAULT_OPTIONS = {\n    channelCount: 6,\n    channelCountMode: 'explicit',\n    channelInterpretation: 'discrete',\n    numberOfOutputs: 6\n} as const;\n\nexport const createChannelSplitterNodeConstructor: TChannelSplitterNodeConstructorFactory = (\n    audioNodeConstructor,\n    createChannelSplitterNodeRenderer,\n    createNativeChannelSplitterNode,\n    getNativeContext,\n    isNativeOfflineAudioContext,\n    sanitizeChannelSplitterOptions\n) => {\n    return class ChannelSplitterNode<T extends TContext> extends audioNodeConstructor<T> {\n        constructor(context: T, options?: Partial<IChannelSplitterOptions>) {\n            const nativeContext = getNativeContext(context);\n            const mergedOptions = sanitizeChannelSplitterOptions({ ...DEFAULT_OPTIONS, ...options });\n            const nativeChannelSplitterNode = createNativeChannelSplitterNode(nativeContext, mergedOptions);\n            const channelSplitterNodeRenderer = <TAudioNodeRenderer<T, this>>(\n                (isNativeOfflineAudioContext(nativeContext) ? createChannelSplitterNodeRenderer() : null)\n            );\n\n            super(context, false, nativeChannelSplitterNode, channelSplitterNodeRenderer);\n        }\n    };\n};\n", "import { isOwnedByContext } from '../helpers/is-owned-by-context';\nimport { IAudioNode, IMinimalOfflineAudioContext, IOfflineAudioContext } from '../interfaces';\nimport { TChannelSplitterNodeRendererFactoryFactory, TNativeAudioNode, TNativeOfflineAudioContext } from '../types';\n\nexport const createChannelSplitterNodeRendererFactory: TChannelSplitterNodeRendererFactoryFactory = (\n    createNativeChannelSplitterNode,\n    getNativeAudioNode,\n    renderInputsOfAudioNode\n) => {\n    return <T extends IMinimalOfflineAudioContext | IOfflineAudioContext>() => {\n        const renderedNativeAudioNodes = new WeakMap<TNativeOfflineAudioContext, TNativeAudioNode>();\n\n        const createAudioNode = async (proxy: IAudioNode<T>, nativeOfflineAudioContext: TNativeOfflineAudioContext) => {\n            let nativeAudioNode = getNativeAudioNode<T, TNativeAudioNode>(proxy);\n\n            // If the initially used nativeAudioNode was not constructed on the same OfflineAudioContext it needs to be created again.\n            const nativeAudioNodeIsOwnedByContext = isOwnedByContext(nativeAudioNode, nativeOfflineAudioContext);\n\n            if (!nativeAudioNodeIsOwnedByContext) {\n                const options = {\n                    channelCount: nativeAudioNode.channelCount,\n                    channelCountMode: nativeAudioNode.channelCountMode,\n                    channelInterpretation: nativeAudioNode.channelInterpretation,\n                    numberOfOutputs: nativeAudioNode.numberOfOutputs\n                };\n\n                nativeAudioNode = createNativeChannelSplitterNode(nativeOfflineAudioContext, options);\n            }\n\n            renderedNativeAudioNodes.set(nativeOfflineAudioContext, nativeAudioNode);\n\n            await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeAudioNode);\n\n            return nativeAudioNode;\n        };\n\n        return {\n            render(proxy: IAudioNode<T>, nativeOfflineAudioContext: TNativeOfflineAudioContext): Promise<TNativeAudioNode> {\n                const renderedNativeAudioNode = renderedNativeAudioNodes.get(nativeOfflineAudioContext);\n\n                if (renderedNativeAudioNode !== undefined) {\n                    return Promise.resolve(renderedNativeAudioNode);\n                }\n\n                return createAudioNode(proxy, nativeOfflineAudioContext);\n            }\n        };\n    };\n};\n", "import { TConnectAudioParamFactory } from '../types';\n\nexport const createConnectAudioParam: TConnectAudioParamFactory = (renderInputsOfAudioParam) => {\n    return (nativeOfflineAudioContext, audioParam, nativeAudioParam) => {\n        return renderInputsOfAudioParam(audioParam, nativeOfflineAudioContext, nativeAudioParam);\n    };\n};\n", "import { isNativeAudioNode } from '../guards/native-audio-node';\nimport { TConnectMultipleOutputsFactory } from '../types';\n\nexport const createConnectMultipleOutputs: TConnectMultipleOutputsFactory = (createIndexSizeError) => {\n    return (outputAudioNodes, destination, output = 0, input = 0) => {\n        const outputAudioNode = outputAudioNodes[output];\n\n        if (outputAudioNode === undefined) {\n            throw createIndexSizeError();\n        }\n\n        if (isNativeAudioNode(destination)) {\n            return outputAudioNode.connect(destination, 0, input);\n        }\n\n        return outputAudioNode.connect(destination, 0);\n    };\n};\n", "import { TConnectedNativeAudioBufferSourceNodeFactoryFactory } from '../types';\n\nexport const createConnectedNativeAudioBufferSourceNodeFactory: TConnectedNativeAudioBufferSourceNodeFactoryFactory = (\n    createNativeAudioBufferSourceNode\n) => {\n    return (nativeContext, nativeAudioNode) => {\n        const nativeAudioBufferSourceNode = createNativeAudioBufferSourceNode(nativeContext, {\n            buffer: null,\n            channelCount: 2,\n            channelCountMode: 'max',\n            channelInterpretation: 'speakers',\n            loop: false,\n            loopEnd: 0,\n            loopStart: 0,\n            playbackRate: 1\n        });\n        const nativeAudioBuffer = nativeContext.createBuffer(1, 2, 44100);\n\n        nativeAudioBufferSourceNode.buffer = nativeAudioBuffer;\n        nativeAudioBufferSourceNode.loop = true;\n\n        nativeAudioBufferSourceNode.connect(nativeAudioNode);\n        nativeAudioBufferSourceNode.start();\n\n        return () => {\n            nativeAudioBufferSourceNode.stop();\n            nativeAudioBufferSourceNode.disconnect(nativeAudioNode);\n        };\n    };\n};\n", "import { MOST_NEGATIVE_SINGLE_FLOAT, MOST_POSITIVE_SINGLE_FLOAT } from '../constants';\nimport { isActiveAudioNode } from '../helpers/is-active-audio-node';\nimport { setInternalStateToActive } from '../helpers/set-internal-state-to-active';\nimport { setInternalStateToPassive } from '../helpers/set-internal-state-to-passive';\nimport { IAudioParam, IAudioScheduledSourceNodeEventMap, IConstantSourceNode, IConstantSourceOptions } from '../interfaces';\nimport {\n    TConstantSourceNodeConstructorFactory,\n    TConstantSourceNodeRenderer,\n    TContext,\n    TEventHandler,\n    TNativeConstantSourceNode\n} from '../types';\n\nconst DEFAULT_OPTIONS = {\n    channelCount: 2,\n    channelCountMode: 'max',\n    channelInterpretation: 'speakers',\n    offset: 1\n} as const;\n\nexport const createConstantSourceNodeConstructor: TConstantSourceNodeConstructorFactory = (\n    audioNodeConstructor,\n    createAudioParam,\n    createConstantSourceNodeRendererFactory,\n    createNativeConstantSourceNode,\n    getNativeContext,\n    isNativeOfflineAudioContext,\n    wrapEventListener\n) => {\n    return class ConstantSourceNode<T extends TContext>\n        extends audioNodeConstructor<T, IAudioScheduledSourceNodeEventMap>\n        implements IConstantSourceNode<T>\n    {\n        private _constantSourceNodeRenderer: TConstantSourceNodeRenderer<T>;\n\n        private _nativeConstantSourceNode: TNativeConstantSourceNode;\n\n        private _offset: IAudioParam;\n\n        private _onended: null | TEventHandler<this>;\n\n        constructor(context: T, options?: Partial<IConstantSourceOptions>) {\n            const nativeContext = getNativeContext(context);\n            const mergedOptions = { ...DEFAULT_OPTIONS, ...options };\n            const nativeConstantSourceNode = createNativeConstantSourceNode(nativeContext, mergedOptions);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            const constantSourceNodeRenderer = <TConstantSourceNodeRenderer<T>>(\n                (isOffline ? createConstantSourceNodeRendererFactory() : null)\n            );\n\n            super(context, false, nativeConstantSourceNode, constantSourceNodeRenderer);\n\n            this._constantSourceNodeRenderer = constantSourceNodeRenderer;\n            this._nativeConstantSourceNode = nativeConstantSourceNode;\n            /*\n             * Bug #62 & #74: Safari does not support ConstantSourceNodes and does not export the correct values for maxValue and minValue\n             * for GainNodes.\n             */\n            this._offset = createAudioParam(\n                this,\n                isOffline,\n                nativeConstantSourceNode.offset,\n                MOST_POSITIVE_SINGLE_FLOAT,\n                MOST_NEGATIVE_SINGLE_FLOAT\n            );\n            this._onended = null;\n        }\n\n        get offset(): IAudioParam {\n            return this._offset;\n        }\n\n        get onended(): null | TEventHandler<this> {\n            return this._onended;\n        }\n\n        set onended(value) {\n            const wrappedListener = typeof value === 'function' ? wrapEventListener(this, value) : null;\n\n            this._nativeConstantSourceNode.onended = wrappedListener;\n\n            const nativeOnEnded = this._nativeConstantSourceNode.onended;\n\n            this._onended = nativeOnEnded !== null && nativeOnEnded === wrappedListener ? value : nativeOnEnded;\n        }\n\n        public start(when = 0): void {\n            this._nativeConstantSourceNode.start(when);\n\n            if (this._constantSourceNodeRenderer !== null) {\n                this._constantSourceNodeRenderer.start = when;\n            }\n\n            if (this.context.state !== 'closed') {\n                setInternalStateToActive(this);\n\n                const resetInternalStateToPassive = () => {\n                    this._nativeConstantSourceNode.removeEventListener('ended', resetInternalStateToPassive);\n\n                    if (isActiveAudioNode(this)) {\n                        setInternalStateToPassive(this);\n                    }\n                };\n\n                this._nativeConstantSourceNode.addEventListener('ended', resetInternalStateToPassive);\n            }\n        }\n\n        public stop(when = 0): void {\n            this._nativeConstantSourceNode.stop(when);\n\n            if (this._constantSourceNodeRenderer !== null) {\n                this._constantSourceNodeRenderer.stop = when;\n            }\n        }\n    };\n};\n", "import { isOwnedByContext } from '../helpers/is-owned-by-context';\nimport { IConstantSourceNode, IMinimalOfflineAudioContext, IOfflineAudioContext } from '../interfaces';\nimport { TConstantSourceNodeRendererFactoryFactory, TNativeConstantSourceNode, TNativeOfflineAudioContext } from '../types';\n\nexport const createConstantSourceNodeRendererFactory: TConstantSourceNodeRendererFactoryFactory = (\n    connectAudioParam,\n    createNativeConstantSourceNode,\n    getNativeAudioNode,\n    renderAutomation,\n    renderInputsOfAudioNode\n) => {\n    return <T extends IMinimalOfflineAudioContext | IOfflineAudioContext>() => {\n        const renderedNativeConstantSourceNodes = new WeakMap<TNativeOfflineAudioContext, TNativeConstantSourceNode>();\n\n        let start: null | number = null;\n        let stop: null | number = null;\n\n        const createConstantSourceNode = async (proxy: IConstantSourceNode<T>, nativeOfflineAudioContext: TNativeOfflineAudioContext) => {\n            let nativeConstantSourceNode = getNativeAudioNode<T, TNativeConstantSourceNode>(proxy);\n\n            /*\n             * If the initially used nativeConstantSourceNode was not constructed on the same OfflineAudioContext it needs to be created\n             * again.\n             */\n            const nativeConstantSourceNodeIsOwnedByContext = isOwnedByContext(nativeConstantSourceNode, nativeOfflineAudioContext);\n\n            if (!nativeConstantSourceNodeIsOwnedByContext) {\n                const options = {\n                    channelCount: nativeConstantSourceNode.channelCount,\n                    channelCountMode: nativeConstantSourceNode.channelCountMode,\n                    channelInterpretation: nativeConstantSourceNode.channelInterpretation,\n                    offset: nativeConstantSourceNode.offset.value\n                };\n\n                nativeConstantSourceNode = createNativeConstantSourceNode(nativeOfflineAudioContext, options);\n\n                if (start !== null) {\n                    nativeConstantSourceNode.start(start);\n                }\n\n                if (stop !== null) {\n                    nativeConstantSourceNode.stop(stop);\n                }\n            }\n\n            renderedNativeConstantSourceNodes.set(nativeOfflineAudioContext, nativeConstantSourceNode);\n\n            if (!nativeConstantSourceNodeIsOwnedByContext) {\n                await renderAutomation(nativeOfflineAudioContext, proxy.offset, nativeConstantSourceNode.offset);\n            } else {\n                await connectAudioParam(nativeOfflineAudioContext, proxy.offset, nativeConstantSourceNode.offset);\n            }\n\n            await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeConstantSourceNode);\n\n            return nativeConstantSourceNode;\n        };\n\n        return {\n            set start(value: number) {\n                start = value;\n            },\n            set stop(value: number) {\n                stop = value;\n            },\n            render(\n                proxy: IConstantSourceNode<T>,\n                nativeOfflineAudioContext: TNativeOfflineAudioContext\n            ): Promise<TNativeConstantSourceNode> {\n                const renderedNativeConstantSourceNode = renderedNativeConstantSourceNodes.get(nativeOfflineAudioContext);\n\n                if (renderedNativeConstantSourceNode !== undefined) {\n                    return Promise.resolve(renderedNativeConstantSourceNode);\n                }\n\n                return createConstantSourceNode(proxy, nativeOfflineAudioContext);\n            }\n        };\n    };\n};\n", "import { TConvertNumberToUnsignedLongFactory } from '../types';\n\nexport const createConvertNumberToUnsignedLong: TConvertNumberToUnsignedLongFactory = (unit32Array) => {\n    return (value) => {\n        unit32Array[0] = value;\n\n        return unit32Array[0];\n    };\n};\n", "import { IConvolverNode, IConvolverOptions } from '../interfaces';\nimport { TAnyAudioBuffer, TAudioNodeRenderer, TContext, TConvolverNodeConstructorFactory, TNativeConvolverNode } from '../types';\n\nconst DEFAULT_OPTIONS = {\n    buffer: null,\n    channelCount: 2,\n    channelCountMode: 'clamped-max',\n    channelInterpretation: 'speakers',\n    disableNormalization: false\n} as const;\n\nexport const createConvolverNodeConstructor: TConvolverNodeConstructorFactory = (\n    audioNodeConstructor,\n    createConvolverNodeRenderer,\n    createNativeConvolverNode,\n    getNativeContext,\n    isNativeOfflineAudioContext,\n    setAudioNodeTailTime\n) => {\n    return class ConvolverNode<T extends TContext> extends audioNodeConstructor<T> implements IConvolverNode<T> {\n        private _isBufferNullified: boolean;\n\n        private _nativeConvolverNode: TNativeConvolverNode;\n\n        constructor(context: T, options?: Partial<IConvolverOptions>) {\n            const nativeContext = getNativeContext(context);\n            const mergedOptions = { ...DEFAULT_OPTIONS, ...options };\n            const nativeConvolverNode = createNativeConvolverNode(nativeContext, mergedOptions);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            const convolverNodeRenderer = <TAudioNodeRenderer<T, this>>(isOffline ? createConvolverNodeRenderer() : null);\n\n            super(context, false, nativeConvolverNode, convolverNodeRenderer);\n\n            this._isBufferNullified = false;\n            this._nativeConvolverNode = nativeConvolverNode;\n\n            if (mergedOptions.buffer !== null) {\n                setAudioNodeTailTime(this, mergedOptions.buffer.duration);\n            }\n        }\n\n        get buffer(): null | TAnyAudioBuffer {\n            if (this._isBufferNullified) {\n                return null;\n            }\n\n            return this._nativeConvolverNode.buffer;\n        }\n\n        set buffer(value) {\n            this._nativeConvolverNode.buffer = value;\n\n            // Bug #115: Safari does not allow to set the buffer to null.\n            if (value === null && this._nativeConvolverNode.buffer !== null) {\n                const nativeContext = this._nativeConvolverNode.context;\n\n                this._nativeConvolverNode.buffer = nativeContext.createBuffer(1, 1, nativeContext.sampleRate);\n                this._isBufferNullified = true;\n\n                setAudioNodeTailTime(this, 0);\n            } else {\n                this._isBufferNullified = false;\n\n                setAudioNodeTailTime(this, this._nativeConvolverNode.buffer === null ? 0 : this._nativeConvolverNode.buffer.duration);\n            }\n        }\n\n        get normalize(): boolean {\n            return this._nativeConvolverNode.normalize;\n        }\n\n        set normalize(value) {\n            this._nativeConvolverNode.normalize = value;\n        }\n    };\n};\n", "import { isNativeAudioNodeFaker } from '../guards/native-audio-node-faker';\nimport { isOwnedByContext } from '../helpers/is-owned-by-context';\nimport { IConvolverNode, IMinimalOfflineAudioContext, IOfflineAudioContext } from '../interfaces';\nimport { TConvolverNodeRendererFactoryFactory, TNativeConvolverNode, TNativeOfflineAudioContext } from '../types';\n\nexport const createConvolverNodeRendererFactory: TConvolverNodeRendererFactoryFactory = (\n    createNativeConvolverNode,\n    getNativeAudioNode,\n    renderInputsOfAudioNode\n) => {\n    return <T extends IMinimalOfflineAudioContext | IOfflineAudioContext>() => {\n        const renderedNativeConvolverNodes = new WeakMap<TNativeOfflineAudioContext, TNativeConvolverNode>();\n\n        const createConvolverNode = async (proxy: IConvolverNode<T>, nativeOfflineAudioContext: TNativeOfflineAudioContext) => {\n            let nativeConvolverNode = getNativeAudioNode<T, TNativeConvolverNode>(proxy);\n\n            // If the initially used nativeConvolverNode was not constructed on the same OfflineAudioContext it needs to be created again.\n            const nativeConvolverNodeIsOwnedByContext = isOwnedByContext(nativeConvolverNode, nativeOfflineAudioContext);\n\n            if (!nativeConvolverNodeIsOwnedByContext) {\n                const options = {\n                    buffer: nativeConvolverNode.buffer,\n                    channelCount: nativeConvolverNode.channelCount,\n                    channelCountMode: nativeConvolverNode.channelCountMode,\n                    channelInterpretation: nativeConvolverNode.channelInterpretation,\n                    disableNormalization: !nativeConvolverNode.normalize\n                };\n\n                nativeConvolverNode = createNativeConvolverNode(nativeOfflineAudioContext, options);\n            }\n\n            renderedNativeConvolverNodes.set(nativeOfflineAudioContext, nativeConvolverNode);\n\n            if (isNativeAudioNodeFaker(nativeConvolverNode)) {\n                await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeConvolverNode.inputs[0]);\n            } else {\n                await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeConvolverNode);\n            }\n\n            return nativeConvolverNode;\n        };\n\n        return {\n            render(proxy: IConvolverNode<T>, nativeOfflineAudioContext: TNativeOfflineAudioContext): Promise<TNativeConvolverNode> {\n                const renderedNativeConvolverNode = renderedNativeConvolverNodes.get(nativeOfflineAudioContext);\n\n                if (renderedNativeConvolverNode !== undefined) {\n                    return Promise.resolve(renderedNativeConvolverNode);\n                }\n\n                return createConvolverNode(proxy, nativeOfflineAudioContext);\n            }\n        };\n    };\n};\n", "import { TCreateNativeOfflineAudioContextFactory } from '../types';\n\nexport const createCreateNativeOfflineAudioContext: TCreateNativeOfflineAudioContextFactory = (\n    createNotSupportedError,\n    nativeOfflineAudioContextConstructor\n) => {\n    return (numberOfChannels, length, sampleRate) => {\n        if (nativeOfflineAudioContextConstructor === null) {\n            throw new Error('Missing the native OfflineAudioContext constructor.');\n        }\n\n        try {\n            return new nativeOfflineAudioContextConstructor(numberOfChannels, length, sampleRate);\n        } catch (err) {\n            // Bug #143, #144 & #146: Safari throws a SyntaxError when numberOfChannels, length or sampleRate are invalid.\n            if (err.name === 'SyntaxError') {\n                throw createNotSupportedError();\n            }\n\n            throw err;\n        }\n    };\n};\n", "import { TDataCloneErrorFactory } from '../types';\n\nexport const createDataCloneError: TDataCloneErrorFactory = () => new DOMException('', 'DataCloneError');\n", "export const detachArrayBuffer = (arrayBuffer: ArrayBuffer): Promise<void> => {\n    const { port1, port2 } = new MessageChannel();\n\n    return new Promise((resolve) => {\n        const closeAndResolve = () => {\n            port2.onmessage = null;\n\n            port1.close();\n            port2.close();\n\n            resolve();\n        };\n\n        port2.onmessage = () => closeAndResolve();\n\n        try {\n            port1.postMessage(arrayBuffer, [arrayBuffer]);\n        } catch {\n            // Ignore errors.\n        } finally {\n            closeAndResolve();\n        }\n    });\n};\n", "import { detachArrayBuffer } from '../helpers/detach-array-buffer';\nimport { wrapAudioBufferGetChannelDataMethod } from '../helpers/wrap-audio-buffer-get-channel-data-method';\nimport { TDecodeAudioDataFactory } from '../types';\n\nexport const createDecodeAudioData: TDecodeAudioDataFactory = (\n    audioBufferStore,\n    cacheTestResult,\n    createDataCloneError,\n    createEncodingError,\n    detachedArrayBuffers,\n    getNativeContext,\n    isNativeContext,\n    testAudioBufferCopyChannelMethodsOutOfBoundsSupport,\n    testPromiseSupport,\n    wrapAudioBufferCopyChannelMethods,\n    wrapAudioBufferCopyChannelMethodsOutOfBounds\n) => {\n    return (anyContext, audioData) => {\n        const nativeContext = isNativeContext(anyContext) ? anyContext : getNativeContext(anyContext);\n\n        // Bug #43: Only Chrome and Edge do throw a DataCloneError.\n        if (detachedArrayBuffers.has(audioData)) {\n            const err = createDataCloneError();\n\n            return Promise.reject(err);\n        }\n\n        // The audioData parameter maybe of a type which can't be added to a WeakSet.\n        try {\n            detachedArrayBuffers.add(audioData);\n        } catch {\n            // Ignore errors.\n        }\n\n        // Bug #21: Safari does not support promises yet.\n        if (cacheTestResult(testPromiseSupport, () => testPromiseSupport(nativeContext))) {\n            return nativeContext.decodeAudioData(audioData).then((audioBuffer) => {\n                // Bug #133: Safari does neuter the ArrayBuffer.\n                detachArrayBuffer(audioData).catch(() => {\n                    // Ignore errors.\n                });\n\n                // Bug #157: Firefox does not allow the bufferOffset to be out-of-bounds.\n                if (\n                    !cacheTestResult(testAudioBufferCopyChannelMethodsOutOfBoundsSupport, () =>\n                        testAudioBufferCopyChannelMethodsOutOfBoundsSupport(audioBuffer)\n                    )\n                ) {\n                    wrapAudioBufferCopyChannelMethodsOutOfBounds(audioBuffer);\n                }\n\n                audioBufferStore.add(audioBuffer);\n\n                return audioBuffer;\n            });\n        }\n\n        // Bug #21: Safari does not return a Promise yet.\n        return new Promise((resolve, reject) => {\n            const complete = async () => {\n                // Bug #133: Safari does neuter the ArrayBuffer.\n                try {\n                    await detachArrayBuffer(audioData);\n                } catch {\n                    // Ignore errors.\n                }\n            };\n\n            const fail = (err: DOMException | Error) => {\n                reject(err);\n                complete();\n            };\n\n            // Bug #26: Safari throws a synchronous error.\n            try {\n                // Bug #1: Safari requires a successCallback.\n                nativeContext.decodeAudioData(\n                    audioData,\n                    (audioBuffer) => {\n                        // Bug #5: Safari does not support copyFromChannel() and copyToChannel().\n                        // Bug #100: Safari does throw a wrong error when calling getChannelData() with an out-of-bounds value.\n                        if (typeof audioBuffer.copyFromChannel !== 'function') {\n                            wrapAudioBufferCopyChannelMethods(audioBuffer);\n                            wrapAudioBufferGetChannelDataMethod(audioBuffer);\n                        }\n\n                        audioBufferStore.add(audioBuffer);\n\n                        complete().then(() => resolve(audioBuffer));\n                    },\n                    (err: DOMException | Error) => {\n                        // Bug #4: Safari returns null instead of an error.\n                        if (err === null) {\n                            fail(createEncodingError());\n                        } else {\n                            fail(err);\n                        }\n                    }\n                );\n            } catch (err) {\n                fail(err);\n            }\n        });\n    };\n};\n", "import { isAudioNodeOutputConnection } from '../guards/audio-node-output-connection';\nimport { TDecrementCycleCounterFactory } from '../types';\n\nexport const createDecrementCycleCounter: TDecrementCycleCounterFactory = (\n    connectNativeAudioNodeToNativeAudioNode,\n    cycleCounters,\n    getAudioNodeConnections,\n    getNativeAudioNode,\n    getNativeAudioParam,\n    getNativeContext,\n    isActiveAudioNode,\n    isNativeOfflineAudioContext\n) => {\n    return (audioNode, count) => {\n        const cycleCounter = cycleCounters.get(audioNode);\n\n        if (cycleCounter === undefined) {\n            throw new Error('Missing the expected cycle count.');\n        }\n\n        const nativeContext = getNativeContext(audioNode.context);\n        const isOffline = isNativeOfflineAudioContext(nativeContext);\n\n        if (cycleCounter === count) {\n            cycleCounters.delete(audioNode);\n\n            if (!isOffline && isActiveAudioNode(audioNode)) {\n                const nativeSourceAudioNode = getNativeAudioNode(audioNode);\n                const { outputs } = getAudioNodeConnections(audioNode);\n\n                for (const output of outputs) {\n                    if (isAudioNodeOutputConnection(output)) {\n                        const nativeDestinationAudioNode = getNativeAudioNode(output[0]);\n\n                        connectNativeAudioNodeToNativeAudioNode(nativeSourceAudioNode, nativeDestinationAudioNode, output[1], output[2]);\n                    } else {\n                        const nativeDestinationAudioParam = getNativeAudioParam(output[0]);\n\n                        nativeSourceAudioNode.connect(nativeDestinationAudioParam, output[1]);\n                    }\n                }\n            }\n        } else {\n            cycleCounters.set(audioNode, cycleCounter - count);\n        }\n    };\n};\n", "import { IAudioParam, IDelayNode, IDelayOptions } from '../interfaces';\nimport { TAudioNodeRenderer, TContext, TDelayNodeConstructorFactory } from '../types';\n\nconst DEFAULT_OPTIONS = {\n    channelCount: 2,\n    channelCountMode: 'max',\n    channelInterpretation: 'speakers',\n    delayTime: 0,\n    maxDelayTime: 1\n} as const;\n\nexport const createDelayNodeConstructor: TDelayNodeConstructorFactory = (\n    audioNodeConstructor,\n    createAudioParam,\n    createDelayNodeRenderer,\n    createNativeDelayNode,\n    getNativeContext,\n    isNativeOfflineAudioContext,\n    setAudioNodeTailTime\n) => {\n    return class DelayNode<T extends TContext> extends audioNodeConstructor<T> implements IDelayNode<T> {\n        private _delayTime: IAudioParam;\n\n        constructor(context: T, options?: Partial<IDelayOptions>) {\n            const nativeContext = getNativeContext(context);\n            const mergedOptions = { ...DEFAULT_OPTIONS, ...options };\n            const nativeDelayNode = createNativeDelayNode(nativeContext, mergedOptions);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            const delayNodeRenderer = <TAudioNodeRenderer<T, this>>(isOffline ? createDelayNodeRenderer(mergedOptions.maxDelayTime) : null);\n\n            super(context, false, nativeDelayNode, delayNodeRenderer);\n\n            this._delayTime = createAudioParam(this, isOffline, nativeDelayNode.delayTime);\n\n            setAudioNodeTailTime(this, mergedOptions.maxDelayTime);\n        }\n\n        get delayTime(): IAudioParam {\n            return this._delayTime;\n        }\n    };\n};\n", "import { isOwnedByContext } from '../helpers/is-owned-by-context';\nimport { IDelayNode, IMinimalOfflineAudioContext, IOfflineAudioContext } from '../interfaces';\nimport { TDelayNodeRendererFactoryFactory, TNativeDelayNode, TNativeOfflineAudioContext } from '../types';\n\nexport const createDelayNodeRendererFactory: TDelayNodeRendererFactoryFactory = (\n    connectAudioParam,\n    createNativeDelayNode,\n    getNativeAudioNode,\n    renderAutomation,\n    renderInputsOfAudioNode\n) => {\n    return <T extends IMinimalOfflineAudioContext | IOfflineAudioContext>(maxDelayTime: number) => {\n        const renderedNativeDelayNodes = new WeakMap<TNativeOfflineAudioContext, TNativeDelayNode>();\n\n        const createDelayNode = async (proxy: IDelayNode<T>, nativeOfflineAudioContext: TNativeOfflineAudioContext) => {\n            let nativeDelayNode = getNativeAudioNode<T, TNativeDelayNode>(proxy);\n\n            // If the initially used nativeDelayNode was not constructed on the same OfflineAudioContext it needs to be created again.\n            const nativeDelayNodeIsOwnedByContext = isOwnedByContext(nativeDelayNode, nativeOfflineAudioContext);\n\n            if (!nativeDelayNodeIsOwnedByContext) {\n                const options = {\n                    channelCount: nativeDelayNode.channelCount,\n                    channelCountMode: nativeDelayNode.channelCountMode,\n                    channelInterpretation: nativeDelayNode.channelInterpretation,\n                    delayTime: nativeDelayNode.delayTime.value,\n                    maxDelayTime\n                };\n\n                nativeDelayNode = createNativeDelayNode(nativeOfflineAudioContext, options);\n            }\n\n            renderedNativeDelayNodes.set(nativeOfflineAudioContext, nativeDelayNode);\n\n            if (!nativeDelayNodeIsOwnedByContext) {\n                await renderAutomation(nativeOfflineAudioContext, proxy.delayTime, nativeDelayNode.delayTime);\n            } else {\n                await connectAudioParam(nativeOfflineAudioContext, proxy.delayTime, nativeDelayNode.delayTime);\n            }\n\n            await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeDelayNode);\n\n            return nativeDelayNode;\n        };\n\n        return {\n            render(proxy: IDelayNode<T>, nativeOfflineAudioContext: TNativeOfflineAudioContext): Promise<TNativeDelayNode> {\n                const renderedNativeDelayNode = renderedNativeDelayNodes.get(nativeOfflineAudioContext);\n\n                if (renderedNativeDelayNode !== undefined) {\n                    return Promise.resolve(renderedNativeDelayNode);\n                }\n\n                return createDelayNode(proxy, nativeOfflineAudioContext);\n            }\n        };\n    };\n};\n", "import { TDeleteActiveInputConnectionToAudioNodeFactory } from '../types';\n\nexport const createDeleteActiveInputConnectionToAudioNode: TDeleteActiveInputConnectionToAudioNodeFactory = (pickElementFromSet) => {\n    return (activeInputs, source, output, input) => {\n        return pickElementFromSet(\n            activeInputs[input],\n            (activeInputConnection) => activeInputConnection[0] === source && activeInputConnection[1] === output\n        );\n    };\n};\n", "import { TDeleteUnrenderedAudioWorkletNodeFactory } from '../types';\n\nexport const createDeleteUnrenderedAudioWorkletNode: TDeleteUnrenderedAudioWorkletNodeFactory = (getUnrenderedAudioWorkletNodes) => {\n    return (nativeContext, audioWorkletNode) => {\n        getUnrenderedAudioWorkletNodes(nativeContext).delete(audioWorkletNode);\n    };\n};\n", "import { IAudioNode, IDelayNode } from '../interfaces';\nimport { TContext } from '../types';\n\nexport const isDelayNode = <T extends TContext>(audioNode: IAudioNode<T>): audioNode is IDelayNode<T> => {\n    return 'delayTime' in audioNode;\n};\n", "import { isAudioNode } from '../guards/audio-node';\nimport { isDelayNode } from '../guards/delay-node';\nimport { IAudioNode, IAudioParam } from '../interfaces';\nimport { TContext, TDetectCyclesFactory } from '../types';\n\nexport const createDetectCycles: TDetectCyclesFactory = (audioParamAudioNodeStore, getAudioNodeConnections, getValueForKey) => {\n    return function detectCycles<T extends TContext>(chain: IAudioNode<T>[], nextLink: IAudioNode<T> | IAudioParam): IAudioNode<T>[][] {\n        const audioNode = isAudioNode(nextLink) ? nextLink : <IAudioNode<T>>getValueForKey(audioParamAudioNodeStore, nextLink);\n\n        if (isDelayNode(audioNode)) {\n            return [];\n        }\n\n        if (chain[0] === audioNode) {\n            return [chain];\n        }\n\n        if (chain.includes(audioNode)) {\n            return [];\n        }\n\n        const { outputs } = getAudioNodeConnections(audioNode);\n\n        return Array.from(outputs)\n            .map((outputConnection) => detectCycles([...chain, audioNode], outputConnection[0]))\n            .reduce((mergedCycles, nestedCycles) => mergedCycles.concat(nestedCycles), []);\n    };\n};\n", "import { isNativeAudioNode } from '../guards/native-audio-node';\nimport { TDisconnectMultipleOutputsFactory, TIndexSizeErrorFactory, TNativeAudioNode } from '../types';\n\nconst getOutputAudioNodeAtIndex = (\n    createIndexSizeError: TIndexSizeErrorFactory,\n    outputAudioNodes: TNativeAudioNode[],\n    output: number\n): TNativeAudioNode => {\n    const outputAudioNode = outputAudioNodes[output];\n\n    if (outputAudioNode === undefined) {\n        throw createIndexSizeError();\n    }\n\n    return outputAudioNode;\n};\n\nexport const createDisconnectMultipleOutputs: TDisconnectMultipleOutputsFactory = (createIndexSizeError) => {\n    return (outputAudioNodes, destinationOrOutput = undefined, output = undefined, input = 0) => {\n        if (destinationOrOutput === undefined) {\n            return outputAudioNodes.forEach((outputAudioNode) => outputAudioNode.disconnect());\n        }\n\n        if (typeof destinationOrOutput === 'number') {\n            return getOutputAudioNodeAtIndex(createIndexSizeError, outputAudioNodes, destinationOrOutput).disconnect();\n        }\n\n        if (isNativeAudioNode(destinationOrOutput)) {\n            if (output === undefined) {\n                return outputAudioNodes.forEach((outputAudioNode) => outputAudioNode.disconnect(destinationOrOutput));\n            }\n\n            if (input === undefined) {\n                return getOutputAudioNodeAtIndex(createIndexSizeError, outputAudioNodes, output).disconnect(destinationOrOutput, 0);\n            }\n\n            return getOutputAudioNodeAtIndex(createIndexSizeError, outputAudioNodes, output).disconnect(destinationOrOutput, 0, input);\n        }\n\n        if (output === undefined) {\n            return outputAudioNodes.forEach((outputAudioNode) => outputAudioNode.disconnect(destinationOrOutput));\n        }\n\n        return getOutputAudioNodeAtIndex(createIndexSizeError, outputAudioNodes, output).disconnect(destinationOrOutput, 0);\n    };\n};\n", "import { IAudioParam, IDynamicsCompressorNode, IDynamicsCompressorOptions } from '../interfaces';\nimport {\n    TAudioNodeRenderer,\n    TChannelCountMode,\n    TContext,\n    TDynamicsCompressorNodeConstructorFactory,\n    TNativeAudioParam,\n    TNativeDynamicsCompressorNode\n} from '../types';\n\nconst DEFAULT_OPTIONS = {\n    attack: 0.003,\n    channelCount: 2,\n    channelCountMode: 'clamped-max',\n    channelInterpretation: 'speakers',\n    knee: 30,\n    ratio: 12,\n    release: 0.25,\n    threshold: -24\n} as const;\n\nexport const createDynamicsCompressorNodeConstructor: TDynamicsCompressorNodeConstructorFactory = (\n    audioNodeConstructor,\n    createAudioParam,\n    createDynamicsCompressorNodeRenderer,\n    createNativeDynamicsCompressorNode,\n    createNotSupportedError,\n    getNativeContext,\n    isNativeOfflineAudioContext,\n    setAudioNodeTailTime\n) => {\n    return class DynamicsCompressorNode<T extends TContext> extends audioNodeConstructor<T> implements IDynamicsCompressorNode<T> {\n        private _attack: IAudioParam;\n\n        private _knee: IAudioParam;\n\n        private _nativeDynamicsCompressorNode: TNativeDynamicsCompressorNode;\n\n        private _ratio: IAudioParam;\n\n        private _release: IAudioParam;\n\n        private _threshold: IAudioParam;\n\n        constructor(context: T, options?: Partial<IDynamicsCompressorOptions>) {\n            const nativeContext = getNativeContext(context);\n            const mergedOptions = { ...DEFAULT_OPTIONS, ...options };\n            const nativeDynamicsCompressorNode = createNativeDynamicsCompressorNode(nativeContext, mergedOptions);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            const dynamicsCompressorNodeRenderer = <TAudioNodeRenderer<T, this>>(isOffline ? createDynamicsCompressorNodeRenderer() : null);\n\n            super(context, false, nativeDynamicsCompressorNode, dynamicsCompressorNodeRenderer);\n\n            this._attack = createAudioParam(this, isOffline, nativeDynamicsCompressorNode.attack);\n            this._knee = createAudioParam(this, isOffline, nativeDynamicsCompressorNode.knee);\n            this._nativeDynamicsCompressorNode = nativeDynamicsCompressorNode;\n            this._ratio = createAudioParam(this, isOffline, nativeDynamicsCompressorNode.ratio);\n            this._release = createAudioParam(this, isOffline, nativeDynamicsCompressorNode.release);\n            this._threshold = createAudioParam(this, isOffline, nativeDynamicsCompressorNode.threshold);\n\n            setAudioNodeTailTime(this, 0.006);\n        }\n\n        get attack(): IAudioParam {\n            return this._attack;\n        }\n\n        // Bug #108: Safari allows a channelCount of three and above which is why the getter and setter needs to be overwritten here.\n        get channelCount(): number {\n            return this._nativeDynamicsCompressorNode.channelCount;\n        }\n\n        set channelCount(value) {\n            const previousChannelCount = this._nativeDynamicsCompressorNode.channelCount;\n\n            this._nativeDynamicsCompressorNode.channelCount = value;\n\n            if (value > 2) {\n                this._nativeDynamicsCompressorNode.channelCount = previousChannelCount;\n\n                throw createNotSupportedError();\n            }\n        }\n\n        /*\n         * Bug #109: Only Chrome and Firefox disallow a channelCountMode of 'max' yet which is why the getter and setter needs to be\n         * overwritten here.\n         */\n        get channelCountMode(): TChannelCountMode {\n            return this._nativeDynamicsCompressorNode.channelCountMode;\n        }\n\n        set channelCountMode(value) {\n            const previousChannelCount = this._nativeDynamicsCompressorNode.channelCountMode;\n\n            this._nativeDynamicsCompressorNode.channelCountMode = value;\n\n            if (value === 'max') {\n                this._nativeDynamicsCompressorNode.channelCountMode = previousChannelCount;\n\n                throw createNotSupportedError();\n            }\n        }\n\n        get knee(): IAudioParam {\n            return this._knee;\n        }\n\n        get ratio(): IAudioParam {\n            return this._ratio;\n        }\n\n        get reduction(): number {\n            // Bug #111: Safari returns an AudioParam instead of a number.\n            if (typeof (<TNativeAudioParam>(<any>this._nativeDynamicsCompressorNode.reduction)).value === 'number') {\n                return (<TNativeAudioParam>(<any>this._nativeDynamicsCompressorNode.reduction)).value;\n            }\n\n            return this._nativeDynamicsCompressorNode.reduction;\n        }\n\n        get release(): IAudioParam {\n            return this._release;\n        }\n\n        get threshold(): IAudioParam {\n            return this._threshold;\n        }\n    };\n};\n", "import { isOwnedByContext } from '../helpers/is-owned-by-context';\nimport { IDynamicsCompressorNode, IMinimalOfflineAudioContext, IOfflineAudioContext } from '../interfaces';\nimport { TDynamicsCompressorNodeRendererFactoryFactory, TNativeDynamicsCompressorNode, TNativeOfflineAudioContext } from '../types';\n\nexport const createDynamicsCompressorNodeRendererFactory: TDynamicsCompressorNodeRendererFactoryFactory = (\n    connectAudioParam,\n    createNativeDynamicsCompressorNode,\n    getNativeAudioNode,\n    renderAutomation,\n    renderInputsOfAudioNode\n) => {\n    return <T extends IMinimalOfflineAudioContext | IOfflineAudioContext>() => {\n        const renderedNativeDynamicsCompressorNodes = new WeakMap<TNativeOfflineAudioContext, TNativeDynamicsCompressorNode>();\n\n        const createDynamicsCompressorNode = async (\n            proxy: IDynamicsCompressorNode<T>,\n            nativeOfflineAudioContext: TNativeOfflineAudioContext\n        ) => {\n            let nativeDynamicsCompressorNode = getNativeAudioNode<T, TNativeDynamicsCompressorNode>(proxy);\n\n            /*\n             * If the initially used nativeDynamicsCompressorNode was not constructed on the same OfflineAudioContext it needs to be\n             * created again.\n             */\n            const nativeDynamicsCompressorNodeIsOwnedByContext = isOwnedByContext(nativeDynamicsCompressorNode, nativeOfflineAudioContext);\n\n            if (!nativeDynamicsCompressorNodeIsOwnedByContext) {\n                const options = {\n                    attack: nativeDynamicsCompressorNode.attack.value,\n                    channelCount: nativeDynamicsCompressorNode.channelCount,\n                    channelCountMode: nativeDynamicsCompressorNode.channelCountMode,\n                    channelInterpretation: nativeDynamicsCompressorNode.channelInterpretation,\n                    knee: nativeDynamicsCompressorNode.knee.value,\n                    ratio: nativeDynamicsCompressorNode.ratio.value,\n                    release: nativeDynamicsCompressorNode.release.value,\n                    threshold: nativeDynamicsCompressorNode.threshold.value\n                };\n\n                nativeDynamicsCompressorNode = createNativeDynamicsCompressorNode(nativeOfflineAudioContext, options);\n            }\n\n            renderedNativeDynamicsCompressorNodes.set(nativeOfflineAudioContext, nativeDynamicsCompressorNode);\n\n            if (!nativeDynamicsCompressorNodeIsOwnedByContext) {\n                await renderAutomation(nativeOfflineAudioContext, proxy.attack, nativeDynamicsCompressorNode.attack);\n                await renderAutomation(nativeOfflineAudioContext, proxy.knee, nativeDynamicsCompressorNode.knee);\n                await renderAutomation(nativeOfflineAudioContext, proxy.ratio, nativeDynamicsCompressorNode.ratio);\n                await renderAutomation(nativeOfflineAudioContext, proxy.release, nativeDynamicsCompressorNode.release);\n                await renderAutomation(nativeOfflineAudioContext, proxy.threshold, nativeDynamicsCompressorNode.threshold);\n            } else {\n                await connectAudioParam(nativeOfflineAudioContext, proxy.attack, nativeDynamicsCompressorNode.attack);\n                await connectAudioParam(nativeOfflineAudioContext, proxy.knee, nativeDynamicsCompressorNode.knee);\n                await connectAudioParam(nativeOfflineAudioContext, proxy.ratio, nativeDynamicsCompressorNode.ratio);\n                await connectAudioParam(nativeOfflineAudioContext, proxy.release, nativeDynamicsCompressorNode.release);\n                await connectAudioParam(nativeOfflineAudioContext, proxy.threshold, nativeDynamicsCompressorNode.threshold);\n            }\n\n            await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeDynamicsCompressorNode);\n\n            return nativeDynamicsCompressorNode;\n        };\n\n        return {\n            render(\n                proxy: IDynamicsCompressorNode<T>,\n                nativeOfflineAudioContext: TNativeOfflineAudioContext\n            ): Promise<TNativeDynamicsCompressorNode> {\n                const renderedNativeDynamicsCompressorNode = renderedNativeDynamicsCompressorNodes.get(nativeOfflineAudioContext);\n\n                if (renderedNativeDynamicsCompressorNode !== undefined) {\n                    return Promise.resolve(renderedNativeDynamicsCompressorNode);\n                }\n\n                return createDynamicsCompressorNode(proxy, nativeOfflineAudioContext);\n            }\n        };\n    };\n};\n", "import { TEncodingErrorFactory } from '../types';\n\nexport const createEncodingError: TEncodingErrorFactory = () => new DOMException('', 'EncodingError');\n", "import { TEvaluateSourceFactory } from '../types';\n\nexport const createEvaluateSource: TEvaluateSourceFactory = (window) => {\n    return (source) =>\n        new Promise((resolve, reject) => {\n            if (window === null) {\n                // Bug #182 Chrome and Edge do throw an instance of a SyntaxError instead of a DOMException.\n                reject(new SyntaxError());\n\n                return;\n            }\n\n            const head = window.document.head;\n\n            if (head === null) {\n                // Bug #182 Chrome and Edge do throw an instance of a SyntaxError instead of a DOMException.\n                reject(new SyntaxError());\n            } else {\n                const script = window.document.createElement('script');\n                // @todo Safari doesn't like URLs with a type of 'application/javascript; charset=utf-8'.\n                const blob = new Blob([source], { type: 'application/javascript' });\n                const url = URL.createObjectURL(blob);\n\n                const originalOnErrorHandler = window.onerror;\n\n                const removeErrorEventListenerAndRevokeUrl = () => {\n                    window.onerror = originalOnErrorHandler;\n\n                    URL.revokeObjectURL(url);\n                };\n\n                window.onerror = (message, src, lineno, colno, error) => {\n                    // @todo Edge thinks the source is the one of the html document.\n                    if (src === url || (src === window.location.href && lineno === 1 && colno === 1)) {\n                        removeErrorEventListenerAndRevokeUrl();\n                        reject(error);\n\n                        return false;\n                    }\n\n                    if (originalOnErrorHandler !== null) {\n                        return originalOnErrorHandler(message, src, lineno, colno, error);\n                    }\n                };\n\n                script.onerror = () => {\n                    removeErrorEventListenerAndRevokeUrl();\n                    // Bug #182 Chrome and Edge do throw an instance of a SyntaxError instead of a DOMException.\n                    reject(new SyntaxError());\n                };\n                script.onload = () => {\n                    removeErrorEventListenerAndRevokeUrl();\n                    resolve();\n                };\n                script.src = url;\n                script.type = 'module';\n\n                head.appendChild(script);\n            }\n        });\n};\n", "import { IEventTarget } from '../interfaces';\nimport { TEventHandler, TEventTargetConstructorFactory, TNativeEventTarget } from '../types';\n\nexport const createEventTargetConstructor: TEventTargetConstructorFactory = (wrapEventListener) => {\n    return class EventTarget<EventMap extends Record<string, Event>> implements IEventTarget<EventMap> {\n        private _listeners: WeakMap<EventListenerOrEventListenerObject, EventListenerOrEventListenerObject>;\n\n        constructor(private _nativeEventTarget: TNativeEventTarget) {\n            this._listeners = new WeakMap();\n        }\n\n        public addEventListener(\n            type: string,\n            listener: null | TEventHandler<this> | EventListenerOrEventListenerObject,\n            options?: boolean | AddEventListenerOptions\n        ): void {\n            if (listener !== null) {\n                let wrappedEventListener = this._listeners.get(listener);\n\n                if (wrappedEventListener === undefined) {\n                    wrappedEventListener = wrapEventListener(this, listener);\n\n                    if (typeof listener === 'function') {\n                        this._listeners.set(listener, wrappedEventListener);\n                    }\n                }\n\n                this._nativeEventTarget.addEventListener(type, wrappedEventListener, options);\n            }\n        }\n\n        public dispatchEvent(event: Event): boolean {\n            return this._nativeEventTarget.dispatchEvent(event);\n        }\n\n        public removeEventListener(\n            type: string,\n            listener: null | TEventHandler<this> | EventListenerOrEventListenerObject,\n            options?: boolean | EventListenerOptions\n        ): void {\n            const wrappedEventListener = listener === null ? undefined : this._listeners.get(listener);\n\n            this._nativeEventTarget.removeEventListener(type, wrappedEventListener === undefined ? null : wrappedEventListener, options);\n        }\n    };\n};\n", "import { TExposeCurrentFrameAndCurrentTimeFactory } from '../types';\n\nexport const createExposeCurrentFrameAndCurrentTime: TExposeCurrentFrameAndCurrentTimeFactory = (window) => {\n    return (currentTime, sampleRate, fn) => {\n        Object.defineProperties(window, {\n            currentFrame: {\n                configurable: true,\n                get(): number {\n                    return Math.round(currentTime * sampleRate);\n                }\n            },\n            currentTime: {\n                configurable: true,\n                get(): number {\n                    return currentTime;\n                }\n            }\n        });\n\n        try {\n            return fn();\n        } finally {\n            if (window !== null) {\n                delete (<any>window).currentFrame;\n                delete (<any>window).currentTime;\n            }\n        }\n    };\n};\n", "import { TFetchSourceFactory } from '../types';\n\nexport const createFetchSource: TFetchSourceFactory = (createAbortError) => {\n    return async (url) => {\n        try {\n            const response = await fetch(url);\n\n            if (response.ok) {\n                return [await response.text(), response.url];\n            }\n        } catch {\n            // Ignore errors.\n        } // tslint:disable-line:no-empty\n\n        throw createAbortError();\n    };\n};\n", "import { MOST_NEGATIVE_SINGLE_FLOAT, MOST_POSITIVE_SINGLE_FLOAT } from '../constants';\nimport { IAudioParam, IGainNode, IGainOptions } from '../interfaces';\nimport { TAudioNodeRenderer, TContext, TGainNodeConstructorFactory } from '../types';\n\nconst DEFAULT_OPTIONS = {\n    channelCount: 2,\n    channelCountMode: 'max',\n    channelInterpretation: 'speakers',\n    gain: 1\n} as const;\n\nexport const createGainNodeConstructor: TGainNodeConstructorFactory = (\n    audioNodeConstructor,\n    createAudioParam,\n    createGainNodeRenderer,\n    createNativeGainNode,\n    getNativeContext,\n    isNativeOfflineAudioContext\n) => {\n    return class GainNode<T extends TContext> extends audioNodeConstructor<T> implements IGainNode<T> {\n        private _gain: IAudioParam;\n\n        constructor(context: T, options?: Partial<IGainOptions>) {\n            const nativeContext = getNativeContext(context);\n            const mergedOptions = { ...DEFAULT_OPTIONS, ...options };\n            const nativeGainNode = createNativeGainNode(nativeContext, mergedOptions);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            const gainNodeRenderer = <TAudioNodeRenderer<T, this>>(isOffline ? createGainNodeRenderer() : null);\n\n            super(context, false, nativeGainNode, gainNodeRenderer);\n\n            // Bug #74: Safari does not export the correct values for maxValue and minValue.\n            this._gain = createAudioParam(this, isOffline, nativeGainNode.gain, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);\n        }\n\n        get gain(): IAudioParam {\n            return this._gain;\n        }\n    };\n};\n", "import { isOwnedByContext } from '../helpers/is-owned-by-context';\nimport { IGainNode, IMinimalOfflineAudioContext, IOfflineAudioContext } from '../interfaces';\nimport { TGainNodeRendererFactoryFactory, TNativeGainNode, TNativeOfflineAudioContext } from '../types';\n\nexport const createGainNodeRendererFactory: TGainNodeRendererFactoryFactory = (\n    connectAudioParam,\n    createNativeGainNode,\n    getNativeAudioNode,\n    renderAutomation,\n    renderInputsOfAudioNode\n) => {\n    return <T extends IMinimalOfflineAudioContext | IOfflineAudioContext>() => {\n        const renderedNativeGainNodes = new WeakMap<TNativeOfflineAudioContext, TNativeGainNode>();\n\n        const createGainNode = async (proxy: IGainNode<T>, nativeOfflineAudioContext: TNativeOfflineAudioContext) => {\n            let nativeGainNode = getNativeAudioNode<T, TNativeGainNode>(proxy);\n\n            // If the initially used nativeGainNode was not constructed on the same OfflineAudioContext it needs to be created again.\n            const nativeGainNodeIsOwnedByContext = isOwnedByContext(nativeGainNode, nativeOfflineAudioContext);\n\n            if (!nativeGainNodeIsOwnedByContext) {\n                const options = {\n                    channelCount: nativeGainNode.channelCount,\n                    channelCountMode: nativeGainNode.channelCountMode,\n                    channelInterpretation: nativeGainNode.channelInterpretation,\n                    gain: nativeGainNode.gain.value\n                };\n\n                nativeGainNode = createNativeGainNode(nativeOfflineAudioContext, options);\n            }\n\n            renderedNativeGainNodes.set(nativeOfflineAudioContext, nativeGainNode);\n\n            if (!nativeGainNodeIsOwnedByContext) {\n                await renderAutomation(nativeOfflineAudioContext, proxy.gain, nativeGainNode.gain);\n            } else {\n                await connectAudioParam(nativeOfflineAudioContext, proxy.gain, nativeGainNode.gain);\n            }\n\n            await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeGainNode);\n\n            return nativeGainNode;\n        };\n\n        return {\n            render(proxy: IGainNode<T>, nativeOfflineAudioContext: TNativeOfflineAudioContext): Promise<TNativeGainNode> {\n                const renderedNativeGainNode = renderedNativeGainNodes.get(nativeOfflineAudioContext);\n\n                if (renderedNativeGainNode !== undefined) {\n                    return Promise.resolve(renderedNativeGainNode);\n                }\n\n                return createGainNode(proxy, nativeOfflineAudioContext);\n            }\n        };\n    };\n};\n", "import { TActiveInputConnection, TContext, TGetActiveAudioWorkletNodeInputsFactory, TNativeAudioWorkletNode } from '../types';\n\nexport const createGetActiveAudioWorkletNodeInputs: TGetActiveAudioWorkletNodeInputsFactory = (\n    activeAudioWorkletNodeInputsStore,\n    getValueForKey\n) => {\n    return <T extends TContext>(nativeAudioWorkletNode: TNativeAudioWorkletNode) =>\n        <Set<TActiveInputConnection<T>>[]>getValueForKey(activeAudioWorkletNodeInputsStore, nativeAudioWorkletNode);\n};\n", "import { IAudioNode, IAudioNodeRenderer, IMinimalOfflineAudioContext, IOfflineAudioContext } from '../interfaces';\nimport { TGetAudioNodeRendererFactory } from '../types';\n\nexport const createGetAudioNodeRenderer: TGetAudioNodeRendererFactory = (getAudioNodeConnections) => {\n    return <T extends IMinimalOfflineAudioContext | IOfflineAudioContext>(\n        audioNode: IAudioNode<T>\n    ): IAudioNodeRenderer<T, IAudioNode<T>> => {\n        const audioNodeConnections = getAudioNodeConnections(audioNode);\n\n        if (audioNodeConnections.renderer === null) {\n            throw new Error('Missing the renderer of the given AudioNode in the audio graph.');\n        }\n\n        return <IAudioNodeRenderer<T, IAudioNode<T>>>audioNodeConnections.renderer;\n    };\n};\n", "import { TGetAudioNodeTailTimeFactory } from '../types';\n\nexport const createGetAudioNodeTailTime: TGetAudioNodeTailTimeFactory = (audioNodeTailTimeStore) => {\n    return (audioNode) => audioNodeTailTimeStore.get(audioNode) ?? 0;\n};\n", "import { IMinimalOfflineAudioContext } from '../interfaces';\nimport { TGetAudioParamRendererFactory } from '../types';\n\nexport const createGetAudioParamRenderer: TGetAudioParamRendererFactory = (getAudioParamConnections) => {\n    return (audioParam) => {\n        const audioParamConnections = getAudioParamConnections<IMinimalOfflineAudioContext>(audioParam);\n\n        if (audioParamConnections.renderer === null) {\n            throw new Error('Missing the renderer of the given AudioParam in the audio graph.');\n        }\n\n        return audioParamConnections.renderer;\n    };\n};\n", "import { TGetBackupOfflineAudioContextFactory } from '../types';\n\nexport const createGetBackupOfflineAudioContext: TGetBackupOfflineAudioContextFactory = (backupOfflineAudioContextStore) => {\n    return (nativeContext) => {\n        return backupOfflineAudioContextStore.get(nativeContext);\n    };\n};\n", "import { TInvalidStateErrorFactory } from '../types';\n\nexport const createInvalidStateError: TInvalidStateErrorFactory = () => new DOMException('', 'InvalidStateError');\n", "import { IMinimalOfflineAudioContext, IOfflineAudioContext } from '../interfaces';\nimport { TContext, TGetNativeContextFactory, TNativeAudioContext, TNativeOfflineAudioContext } from '../types';\nimport { createInvalidStateError } from './invalid-state-error';\n\nexport const createGetNativeContext: TGetNativeContextFactory = (contextStore) => {\n    return <T extends TContext>(\n        context: T\n    ): T extends IMinimalOfflineAudioContext | IOfflineAudioContext ? TNativeOfflineAudioContext : TNativeAudioContext => {\n        const nativeContext = contextStore.get(context);\n\n        if (nativeContext === undefined) {\n            throw createInvalidStateError();\n        }\n\n        return <T extends IMinimalOfflineAudioContext | IOfflineAudioContext ? TNativeOfflineAudioContext : TNativeAudioContext>(\n            nativeContext\n        );\n    };\n};\n", "import { TGetOrCreateBackupOfflineAudioContextFactory } from '../types';\n\nexport const createGetOrCreateBackupOfflineAudioContext: TGetOrCreateBackupOfflineAudioContextFactory = (\n    backupOfflineAudioContextStore,\n    nativeOfflineAudioContextConstructor\n) => {\n    return (nativeContext) => {\n        let backupOfflineAudioContext = backupOfflineAudioContextStore.get(nativeContext);\n\n        if (backupOfflineAudioContext !== undefined) {\n            return backupOfflineAudioContext;\n        }\n\n        if (nativeOfflineAudioContextConstructor === null) {\n            throw new Error('Missing the native OfflineAudioContext constructor.');\n        }\n\n        // Bug #141: Safari does not support creating an OfflineAudioContext with less than 44100 Hz.\n        backupOfflineAudioContext = new nativeOfflineAudioContextConstructor(1, 1, 44100);\n\n        backupOfflineAudioContextStore.set(nativeContext, backupOfflineAudioContext);\n\n        return backupOfflineAudioContext;\n    };\n};\n", "import { TGetUnrenderedAudioWorkletNodesFactory } from '../types';\n\nexport const createGetUnrenderedAudioWorkletNodes: TGetUnrenderedAudioWorkletNodesFactory = (unrenderedAudioWorkletNodeStore) => {\n    return (nativeContext) => {\n        const unrenderedAudioWorkletNodes = unrenderedAudioWorkletNodeStore.get(nativeContext);\n\n        if (unrenderedAudioWorkletNodes === undefined) {\n            throw new Error('The context has no set of AudioWorkletNodes.');\n        }\n\n        return unrenderedAudioWorkletNodes;\n    };\n};\n", "import { TInvalidAccessErrorFactory } from '../types';\n\nexport const createInvalidAccessError: TInvalidAccessErrorFactory = () => new DOMException('', 'InvalidAccessError');\n", "import { createInvalidAccessError } from '../factories/invalid-access-error';\nimport { TNativeIIRFilterNode } from '../types';\n\nexport const wrapIIRFilterNodeGetFrequencyResponseMethod = (nativeIIRFilterNode: TNativeIIRFilterNode): void => {\n    nativeIIRFilterNode.getFrequencyResponse = ((getFrequencyResponse) => {\n        return (frequencyHz: Float32Array, magResponse: Float32Array, phaseResponse: Float32Array) => {\n            if (frequencyHz.length !== magResponse.length || magResponse.length !== phaseResponse.length) {\n                throw createInvalidAccessError();\n            }\n\n            return getFrequencyResponse.call(nativeIIRFilterNode, frequencyHz, magResponse, phaseResponse);\n        };\n    })(nativeIIRFilterNode.getFrequencyResponse);\n};\n", "import { wrapIIRFilterNodeGetFrequencyResponseMethod } from '../helpers/wrap-iir-filter-node-get-frequency-response-method';\nimport { IIIRFilterNode, IIIRFilterOptions, IMinimalAudioContext } from '../interfaces';\nimport { TAudioNodeRenderer, TContext, TIIRFilterNodeConstructorFactory, TNativeIIRFilterNode } from '../types';\n\nconst DEFAULT_OPTIONS = {\n    channelCount: 2,\n    channelCountMode: 'max',\n    channelInterpretation: 'speakers'\n} as const;\n\nexport const createIIRFilterNodeConstructor: TIIRFilterNodeConstructorFactory = (\n    audioNodeConstructor,\n    createNativeIIRFilterNode,\n    createIIRFilterNodeRenderer,\n    getNativeContext,\n    isNativeOfflineAudioContext,\n    setAudioNodeTailTime\n) => {\n    return class IIRFilterNode<T extends TContext> extends audioNodeConstructor<T> implements IIIRFilterNode<T> {\n        private _nativeIIRFilterNode: TNativeIIRFilterNode;\n\n        constructor(\n            context: T,\n            options: { feedback: IIIRFilterOptions['feedback']; feedforward: IIIRFilterOptions['feedforward'] } & Partial<IIIRFilterOptions>\n        ) {\n            const nativeContext = getNativeContext(context);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            const mergedOptions = { ...DEFAULT_OPTIONS, ...options };\n            const nativeIIRFilterNode = createNativeIIRFilterNode(\n                nativeContext,\n                isOffline ? null : (<IMinimalAudioContext>(<any>context)).baseLatency,\n                mergedOptions\n            );\n            const iirFilterNodeRenderer = <TAudioNodeRenderer<T, this>>(\n                (isOffline ? createIIRFilterNodeRenderer(mergedOptions.feedback, mergedOptions.feedforward) : null)\n            );\n\n            super(context, false, nativeIIRFilterNode, iirFilterNodeRenderer);\n\n            // Bug #23 & #24: FirefoxDeveloper does not throw an InvalidAccessError.\n            // @todo Write a test which allows other browsers to remain unpatched.\n            wrapIIRFilterNodeGetFrequencyResponseMethod(nativeIIRFilterNode);\n\n            this._nativeIIRFilterNode = nativeIIRFilterNode;\n\n            // @todo Determine a meaningful tail-time instead of just using one second.\n            setAudioNodeTailTime(this, 1);\n        }\n\n        public getFrequencyResponse(frequencyHz: Float32Array, magResponse: Float32Array, phaseResponse: Float32Array): void {\n            return this._nativeIIRFilterNode.getFrequencyResponse(frequencyHz, magResponse, phaseResponse);\n        }\n    };\n};\n", "// This implementation as shamelessly inspired by source code of\n// tslint:disable-next-line:max-line-length\n// {@link https://chromium.googlesource.com/chromium/src.git/+/master/third_party/WebKit/Source/platform/audio/IIRFilter.cpp|Chromium's IIRFilter}.\nexport const filterBuffer = (\n    feedback: Float64Array,\n    feedbackLength: number,\n    feedforward: Float64Array,\n    feedforwardLength: number,\n    minLength: number,\n    xBuffer: Float32Array,\n    yBuffer: Float32Array,\n    bufferIndex: number,\n    bufferLength: number,\n    input: Float32Array,\n    output: Float32Array\n) => {\n    const inputLength = input.length;\n\n    let i = bufferIndex;\n\n    for (let j = 0; j < inputLength; j += 1) {\n        let y = feedforward[0] * input[j];\n\n        for (let k = 1; k < minLength; k += 1) {\n            const x = (i - k) & (bufferLength - 1); // tslint:disable-line:no-bitwise\n\n            y += feedforward[k] * xBuffer[x];\n            y -= feedback[k] * yBuffer[x];\n        }\n\n        for (let k = minLength; k < feedforwardLength; k += 1) {\n            y += feedforward[k] * xBuffer[(i - k) & (bufferLength - 1)]; // tslint:disable-line:no-bitwise\n        }\n\n        for (let k = minLength; k < feedbackLength; k += 1) {\n            y -= feedback[k] * yBuffer[(i - k) & (bufferLength - 1)]; // tslint:disable-line:no-bitwise\n        }\n\n        xBuffer[i] = input[j];\n        yBuffer[i] = y;\n\n        i = (i + 1) & (bufferLength - 1); // tslint:disable-line:no-bitwise\n\n        output[j] = y;\n    }\n\n    return i;\n};\n", "import { filterBuffer } from '../helpers/filter-buffer';\nimport { isOwnedByContext } from '../helpers/is-owned-by-context';\nimport { IIIRFilterNode, IMinimalOfflineAudioContext, IOfflineAudioContext } from '../interfaces';\nimport {\n    TIIRFilterNodeRendererFactoryFactory,\n    TNativeAudioBuffer,\n    TNativeAudioBufferSourceNode,\n    TNativeIIRFilterNode,\n    TNativeOfflineAudioContext\n} from '../types';\n\nconst filterFullBuffer = (\n    renderedBuffer: TNativeAudioBuffer,\n    nativeOfflineAudioContext: TNativeOfflineAudioContext,\n    feedback: Iterable<number>,\n    feedforward: Iterable<number>\n) => {\n    const convertedFeedback = feedback instanceof Float64Array ? feedback : new Float64Array(feedback);\n    const convertedFeedforward = feedforward instanceof Float64Array ? feedforward : new Float64Array(feedforward);\n    const feedbackLength = convertedFeedback.length;\n    const feedforwardLength = convertedFeedforward.length;\n    const minLength = Math.min(feedbackLength, feedforwardLength);\n\n    if (convertedFeedback[0] !== 1) {\n        for (let i = 0; i < feedbackLength; i += 1) {\n            convertedFeedforward[i] /= convertedFeedback[0];\n        }\n\n        for (let i = 1; i < feedforwardLength; i += 1) {\n            convertedFeedback[i] /= convertedFeedback[0];\n        }\n    }\n\n    const bufferLength = 32;\n    const xBuffer = new Float32Array(bufferLength);\n    const yBuffer = new Float32Array(bufferLength);\n\n    const filteredBuffer = nativeOfflineAudioContext.createBuffer(\n        renderedBuffer.numberOfChannels,\n        renderedBuffer.length,\n        renderedBuffer.sampleRate\n    );\n\n    const numberOfChannels = renderedBuffer.numberOfChannels;\n\n    for (let i = 0; i < numberOfChannels; i += 1) {\n        const input = renderedBuffer.getChannelData(i);\n        const output = filteredBuffer.getChannelData(i);\n\n        xBuffer.fill(0);\n        yBuffer.fill(0);\n\n        filterBuffer(\n            convertedFeedback,\n            feedbackLength,\n            convertedFeedforward,\n            feedforwardLength,\n            minLength,\n            xBuffer,\n            yBuffer,\n            0,\n            bufferLength,\n            input,\n            output\n        );\n    }\n\n    return filteredBuffer;\n};\n\nexport const createIIRFilterNodeRendererFactory: TIIRFilterNodeRendererFactoryFactory = (\n    createNativeAudioBufferSourceNode,\n    getNativeAudioNode,\n    nativeOfflineAudioContextConstructor,\n    renderInputsOfAudioNode,\n    renderNativeOfflineAudioContext\n) => {\n    return <T extends IMinimalOfflineAudioContext | IOfflineAudioContext>(feedback: Iterable<number>, feedforward: Iterable<number>) => {\n        const renderedNativeAudioNodes = new WeakMap<TNativeOfflineAudioContext, TNativeAudioBufferSourceNode | TNativeIIRFilterNode>();\n\n        let filteredBufferPromise: null | Promise<null | TNativeAudioBuffer> = null;\n\n        const createAudioNode = async (proxy: IIIRFilterNode<T>, nativeOfflineAudioContext: TNativeOfflineAudioContext) => {\n            let nativeAudioBufferSourceNode: null | TNativeAudioBufferSourceNode = null;\n            let nativeIIRFilterNode = getNativeAudioNode<T, TNativeIIRFilterNode>(proxy);\n\n            // If the initially used nativeIIRFilterNode was not constructed on the same OfflineAudioContext it needs to be created again.\n            const nativeIIRFilterNodeIsOwnedByContext = isOwnedByContext(nativeIIRFilterNode, nativeOfflineAudioContext);\n\n            // Bug #9: Safari does not support IIRFilterNodes.\n            if (nativeOfflineAudioContext.createIIRFilter === undefined) {\n                nativeAudioBufferSourceNode = createNativeAudioBufferSourceNode(nativeOfflineAudioContext, {\n                    buffer: null,\n                    channelCount: 2,\n                    channelCountMode: 'max',\n                    channelInterpretation: 'speakers',\n                    loop: false,\n                    loopEnd: 0,\n                    loopStart: 0,\n                    playbackRate: 1\n                });\n            } else if (!nativeIIRFilterNodeIsOwnedByContext) {\n                // @todo TypeScript defines the parameters of createIIRFilter() as arrays of numbers.\n                nativeIIRFilterNode = nativeOfflineAudioContext.createIIRFilter(<number[]>feedforward, <number[]>feedback);\n            }\n\n            renderedNativeAudioNodes.set(\n                nativeOfflineAudioContext,\n                nativeAudioBufferSourceNode === null ? nativeIIRFilterNode : nativeAudioBufferSourceNode\n            );\n\n            if (nativeAudioBufferSourceNode !== null) {\n                if (filteredBufferPromise === null) {\n                    if (nativeOfflineAudioContextConstructor === null) {\n                        throw new Error('Missing the native OfflineAudioContext constructor.');\n                    }\n\n                    const partialOfflineAudioContext = new nativeOfflineAudioContextConstructor(\n                        // Bug #47: The AudioDestinationNode in Safari gets not initialized correctly.\n                        proxy.context.destination.channelCount,\n                        // Bug #17: Safari does not yet expose the length.\n                        proxy.context.length,\n                        nativeOfflineAudioContext.sampleRate\n                    );\n\n                    filteredBufferPromise = (async () => {\n                        await renderInputsOfAudioNode(proxy, partialOfflineAudioContext, partialOfflineAudioContext.destination);\n\n                        const renderedBuffer = await renderNativeOfflineAudioContext(partialOfflineAudioContext);\n\n                        return filterFullBuffer(renderedBuffer, nativeOfflineAudioContext, feedback, feedforward);\n                    })();\n                }\n\n                const filteredBuffer = await filteredBufferPromise;\n\n                nativeAudioBufferSourceNode.buffer = filteredBuffer;\n                nativeAudioBufferSourceNode.start(0);\n\n                return nativeAudioBufferSourceNode;\n            }\n\n            await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeIIRFilterNode);\n\n            return nativeIIRFilterNode;\n        };\n\n        return {\n            render(\n                proxy: IIIRFilterNode<T>,\n                nativeOfflineAudioContext: TNativeOfflineAudioContext\n            ): Promise<TNativeAudioBufferSourceNode | TNativeIIRFilterNode> {\n                const renderedNativeAudioNode = renderedNativeAudioNodes.get(nativeOfflineAudioContext);\n\n                if (renderedNativeAudioNode !== undefined) {\n                    return Promise.resolve(renderedNativeAudioNode);\n                }\n\n                return createAudioNode(proxy, nativeOfflineAudioContext);\n            }\n        };\n    };\n};\n", "import { isAudioNodeOutputConnection } from '../guards/audio-node-output-connection';\nimport { TIncrementCycleCounterFactoryFactory } from '../types';\n\nexport const createIncrementCycleCounterFactory: TIncrementCycleCounterFactoryFactory = (\n    cycleCounters,\n    disconnectNativeAudioNodeFromNativeAudioNode,\n    getAudioNodeConnections,\n    getNativeAudioNode,\n    getNativeAudioParam,\n    isActiveAudioNode\n) => {\n    return (isOffline) => {\n        return (audioNode, count) => {\n            const cycleCounter = cycleCounters.get(audioNode);\n\n            if (cycleCounter === undefined) {\n                if (!isOffline && isActiveAudioNode(audioNode)) {\n                    const nativeSourceAudioNode = getNativeAudioNode(audioNode);\n                    const { outputs } = getAudioNodeConnections(audioNode);\n\n                    for (const output of outputs) {\n                        if (isAudioNodeOutputConnection(output)) {\n                            const nativeDestinationAudioNode = getNativeAudioNode(output[0]);\n\n                            disconnectNativeAudioNodeFromNativeAudioNode(\n                                nativeSourceAudioNode,\n                                nativeDestinationAudioNode,\n                                output[1],\n                                output[2]\n                            );\n                        } else {\n                            const nativeDestinationAudioParam = getNativeAudioParam(output[0]);\n\n                            nativeSourceAudioNode.disconnect(nativeDestinationAudioParam, output[1]);\n                        }\n                    }\n                }\n\n                cycleCounters.set(audioNode, count);\n            } else {\n                cycleCounters.set(audioNode, cycleCounter + count);\n            }\n        };\n    };\n};\n", "import { IAudioContext, IMinimalAudioContext } from '../interfaces';\nimport { TIsAnyAudioContextFactory, TNativeAudioContext } from '../types';\n\nexport const createIsAnyAudioContext: TIsAnyAudioContextFactory = (contextStore, isNativeAudioContext) => {\n    return (anything): anything is IAudioContext | IMinimalAudioContext | TNativeAudioContext => {\n        const nativeContext = contextStore.get(<any>anything);\n\n        return isNativeAudioContext(nativeContext) || isNativeAudioContext(anything);\n    };\n};\n", "import { IAudioNode } from '../interfaces';\nimport { TIsAnyAudioNodeFactory, TNativeAudioNode } from '../types';\n\nexport const createIsAnyAudioNode: TIsAnyAudioNodeFactory = (audioNodeStore, isNativeAudioNode) => {\n    return (anything): anything is IAudioNode<any> | TNativeAudioNode => audioNodeStore.has(<any>anything) || isNativeAudioNode(anything);\n};\n", "import { IAudioParam } from '../interfaces';\nimport { TIsAnyAudioParamFactory, TNativeAudioParam } from '../types';\n\nexport const createIsAnyAudioParam: TIsAnyAudioParamFactory = (audioParamStore, isNativeAudioParam) => {\n    return (anything): anything is IAudioParam | TNativeAudioParam => audioParamStore.has(<any>anything) || isNativeAudioParam(anything);\n};\n", "import { IMinimalOfflineAudioContext, IOfflineAudioContext } from '../interfaces';\nimport { TIsAnyOfflineAudioContextFactory, TNativeOfflineAudioContext } from '../types';\n\nexport const createIsAnyOfflineAudioContext: TIsAnyOfflineAudioContextFactory = (contextStore, isNativeOfflineAudioContext) => {\n    return (anything): anything is IMinimalOfflineAudioContext | IOfflineAudioContext | TNativeOfflineAudioContext => {\n        const nativeContext = contextStore.get(<any>anything);\n\n        return isNativeOfflineAudioContext(nativeContext) || isNativeOfflineAudioContext(anything);\n    };\n};\n", "import { TIsNativeAudioContextFactory, TNativeAudioContext } from '../types';\n\nexport const createIsNativeAudioContext: TIsNativeAudioContextFactory = (nativeAudioContextConstructor) => {\n    return (anything): anything is TNativeAudioContext => {\n        return nativeAudioContextConstructor !== null && anything instanceof nativeAudioContextConstructor;\n    };\n};\n", "import { TIsNativeAudioNodeFactory, TNativeAudioNode } from '../types';\n\nexport const createIsNativeAudioNode: TIsNativeAudioNodeFactory = (window) => {\n    return (anything): anything is TNativeAudioNode => {\n        return window !== null && typeof window.AudioNode === 'function' && anything instanceof window.AudioNode;\n    };\n};\n", "import { TIsNativeAudioParamFactory, TNativeAudioParam } from '../types';\n\nexport const createIsNativeAudioParam: TIsNativeAudioParamFactory = (window) => {\n    return (anything): anything is TNativeAudioParam => {\n        return window !== null && typeof window.AudioParam === 'function' && anything instanceof window.AudioParam;\n    };\n};\n", "import { TIsNativeContextFactory, TNativeAudioContext } from '../types';\n\nexport const createIsNativeContext: TIsNativeContextFactory = (isNativeAudioContext, isNativeOfflineAudioContext) => {\n    return (anything): anything is TNativeAudioContext => {\n        return isNativeAudioContext(anything) || isNativeOfflineAudioContext(anything);\n    };\n};\n", "import { TIsNativeOfflineAudioContextFactory, TNativeOfflineAudioContext } from '../types';\n\nexport const createIsNativeOfflineAudioContext: TIsNativeOfflineAudioContextFactory = (nativeOfflineAudioContextConstructor) => {\n    return (anything): anything is TNativeOfflineAudioContext => {\n        return nativeOfflineAudioContextConstructor !== null && anything instanceof nativeOfflineAudioContextConstructor;\n    };\n};\n", "import { TIsSecureContextFactory } from '../types';\n\nexport const createIsSecureContext: TIsSecureContextFactory = (window) => window !== null && window.isSecureContext;\n", "import { IAudioContext, IMediaElementAudioSourceNode, IMediaElementAudioSourceOptions, IMinimalAudioContext } from '../interfaces';\nimport { TAudioNodeRenderer, TMediaElementAudioSourceNodeConstructorFactory, TNativeMediaElementAudioSourceNode } from '../types';\n\nexport const createMediaElementAudioSourceNodeConstructor: TMediaElementAudioSourceNodeConstructorFactory = (\n    audioNodeConstructor,\n    createNativeMediaElementAudioSourceNode,\n    getNativeContext,\n    isNativeOfflineAudioContext\n) => {\n    return class MediaElementAudioSourceNode<T extends IAudioContext | IMinimalAudioContext> extends audioNodeConstructor<T>\n        implements IMediaElementAudioSourceNode<T> {\n        private _nativeMediaElementAudioSourceNode: TNativeMediaElementAudioSourceNode;\n\n        constructor(context: T, options: IMediaElementAudioSourceOptions) {\n            const nativeContext = getNativeContext(context);\n            const nativeMediaElementAudioSourceNode = createNativeMediaElementAudioSourceNode(nativeContext, options);\n\n            // Bug #171: Safari allows to create a MediaElementAudioSourceNode with an OfflineAudioContext.\n            if (isNativeOfflineAudioContext(nativeContext)) {\n                throw TypeError();\n            }\n\n            super(context, true, nativeMediaElementAudioSourceNode, <TAudioNodeRenderer<T>>null);\n\n            this._nativeMediaElementAudioSourceNode = nativeMediaElementAudioSourceNode;\n        }\n\n        get mediaElement(): HTMLMediaElement {\n            return this._nativeMediaElementAudioSourceNode.mediaElement;\n        }\n    };\n};\n", "import { IAudioContext, IAudioNodeOptions, IMediaStreamAudioDestinationNode, IMinimalAudioContext } from '../interfaces';\nimport { TAudioNodeRenderer, TMediaStreamAudioDestinationNodeConstructorFactory, TNativeMediaStreamAudioDestinationNode } from '../types';\n\nconst DEFAULT_OPTIONS = {\n    channelCount: 2,\n    channelCountMode: 'explicit',\n    channelInterpretation: 'speakers'\n} as const;\n\nexport const createMediaStreamAudioDestinationNodeConstructor: TMediaStreamAudioDestinationNodeConstructorFactory = (\n    audioNodeConstructor,\n    createNativeMediaStreamAudioDestinationNode,\n    getNativeContext,\n    isNativeOfflineAudioContext\n) => {\n    return class MediaStreamAudioDestinationNode<T extends IAudioContext | IMinimalAudioContext> extends audioNodeConstructor<T>\n        implements IMediaStreamAudioDestinationNode<T> {\n        private _nativeMediaStreamAudioDestinationNode: TNativeMediaStreamAudioDestinationNode;\n\n        constructor(context: T, options?: Partial<IAudioNodeOptions>) {\n            const nativeContext = getNativeContext(context);\n\n            // Bug #173: Safari allows to create a MediaStreamAudioDestinationNode with an OfflineAudioContext.\n            if (isNativeOfflineAudioContext(nativeContext)) {\n                throw new TypeError();\n            }\n\n            const mergedOptions = { ...DEFAULT_OPTIONS, ...options };\n            const nativeMediaStreamAudioDestinationNode = createNativeMediaStreamAudioDestinationNode(nativeContext, mergedOptions);\n\n            super(context, false, nativeMediaStreamAudioDestinationNode, <TAudioNodeRenderer<T>>null);\n\n            this._nativeMediaStreamAudioDestinationNode = nativeMediaStreamAudioDestinationNode;\n        }\n\n        get stream(): MediaStream {\n            return this._nativeMediaStreamAudioDestinationNode.stream;\n        }\n    };\n};\n", "import { IAudioContext, IMediaStreamAudioSourceNode, IMediaStreamAudioSourceOptions, IMinimalAudioContext } from '../interfaces';\nimport { TAudioNodeRenderer, TMediaStreamAudioSourceNodeConstructorFactory, TNativeMediaStreamAudioSourceNode } from '../types';\n\nexport const createMediaStreamAudioSourceNodeConstructor: TMediaStreamAudioSourceNodeConstructorFactory = (\n    audioNodeConstructor,\n    createNativeMediaStreamAudioSourceNode,\n    getNativeContext,\n    isNativeOfflineAudioContext\n) => {\n    return class MediaStreamAudioSourceNode<T extends IAudioContext | IMinimalAudioContext> extends audioNodeConstructor<T>\n        implements IMediaStreamAudioSourceNode<T> {\n        private _nativeMediaStreamAudioSourceNode: TNativeMediaStreamAudioSourceNode;\n\n        constructor(context: T, options: IMediaStreamAudioSourceOptions) {\n            const nativeContext = getNativeContext(context);\n            const nativeMediaStreamAudioSourceNode = createNativeMediaStreamAudioSourceNode(nativeContext, options);\n\n            // Bug #172: Safari allows to create a MediaStreamAudioSourceNode with an OfflineAudioContext.\n            if (isNativeOfflineAudioContext(nativeContext)) {\n                throw new TypeError();\n            }\n\n            super(context, true, nativeMediaStreamAudioSourceNode, <TAudioNodeRenderer<T>>null);\n\n            this._nativeMediaStreamAudioSourceNode = nativeMediaStreamAudioSourceNode;\n        }\n\n        get mediaStream(): MediaStream {\n            return this._nativeMediaStreamAudioSourceNode.mediaStream;\n        }\n    };\n};\n", "import { IAudioContext, IMediaStreamTrackAudioSourceNode, IMediaStreamTrackAudioSourceOptions, IMinimalAudioContext } from '../interfaces';\nimport { TAudioNodeRenderer, TMediaStreamTrackAudioSourceNodeConstructorFactory } from '../types';\n\nexport const createMediaStreamTrackAudioSourceNodeConstructor: TMediaStreamTrackAudioSourceNodeConstructorFactory = (\n    audioNodeConstructor,\n    createNativeMediaStreamTrackAudioSourceNode,\n    getNativeContext\n) => {\n    return class MediaStreamTrackAudioSourceNode<T extends IAudioContext | IMinimalAudioContext> extends audioNodeConstructor<T>\n        implements IMediaStreamTrackAudioSourceNode<T> {\n        constructor(context: T, options: IMediaStreamTrackAudioSourceOptions) {\n            const nativeContext = getNativeContext(context);\n            const nativeMediaStreamTrackAudioSourceNode = createNativeMediaStreamTrackAudioSourceNode(nativeContext, options);\n\n            super(context, true, nativeMediaStreamTrackAudioSourceNode, <TAudioNodeRenderer<T>>null);\n        }\n    };\n};\n", "import { deactivateAudioGraph } from '../helpers/deactivate-audio-graph';\nimport { isValidLatencyHint } from '../helpers/is-valid-latency-hint';\nimport { IAudioContextOptions, IMinimalAudioContext } from '../interfaces';\nimport {\n    TAudioContextState,\n    TMinimalAudioContextConstructorFactory,\n    TNativeAudioContext,\n    TNativeGainNode,\n    TNativeOscillatorNode\n} from '../types';\n\nexport const createMinimalAudioContextConstructor: TMinimalAudioContextConstructorFactory = (\n    createInvalidStateError,\n    createNotSupportedError,\n    createUnknownError,\n    minimalBaseAudioContextConstructor,\n    nativeAudioContextConstructor\n) => {\n    return class MinimalAudioContext extends minimalBaseAudioContextConstructor<IMinimalAudioContext> implements IMinimalAudioContext {\n        private _baseLatency: number;\n\n        private _nativeAudioContext: TNativeAudioContext;\n\n        private _nativeGainNode: null | TNativeGainNode;\n\n        private _nativeOscillatorNode: null | TNativeOscillatorNode;\n\n        private _state: null | 'suspended';\n\n        constructor(options: IAudioContextOptions = {}) {\n            if (nativeAudioContextConstructor === null) {\n                throw new Error('Missing the native AudioContext constructor.');\n            }\n\n            let nativeAudioContext: TNativeAudioContext;\n\n            try {\n                nativeAudioContext = new nativeAudioContextConstructor(options);\n            } catch (err) {\n                // Bug #192 Safari does throw a SyntaxError if the sampleRate is not supported.\n                if (err.code === 12 && err.message === 'sampleRate is not in range') {\n                    throw createNotSupportedError();\n                }\n\n                throw err;\n            }\n\n            // Bug #131 Safari returns null when there are four other AudioContexts running already.\n            if (nativeAudioContext === null) {\n                throw createUnknownError();\n            }\n\n            // Bug #51 Only Chrome and Edge throw an error if the given latencyHint is invalid.\n            if (!isValidLatencyHint(options.latencyHint)) {\n                throw new TypeError(\n                    `The provided value '${options.latencyHint}' is not a valid enum value of type AudioContextLatencyCategory.`\n                );\n            }\n\n            // Bug #150 Safari does not support setting the sampleRate.\n            if (options.sampleRate !== undefined && nativeAudioContext.sampleRate !== options.sampleRate) {\n                throw createNotSupportedError();\n            }\n\n            super(nativeAudioContext, 2);\n\n            const { latencyHint } = options;\n            const { sampleRate } = nativeAudioContext;\n\n            // @todo The values for 'balanced', 'interactive' and 'playback' are just copied from Chrome's implementation.\n            this._baseLatency =\n                typeof nativeAudioContext.baseLatency === 'number'\n                    ? nativeAudioContext.baseLatency\n                    : latencyHint === 'balanced'\n                    ? 512 / sampleRate\n                    : latencyHint === 'interactive' || latencyHint === undefined\n                    ? 256 / sampleRate\n                    : latencyHint === 'playback'\n                    ? 1024 / sampleRate\n                    : /*\n                       * @todo The min (256) and max (16384) values are taken from the allowed bufferSize values of a\n                       * ScriptProcessorNode.\n                       */\n                      (Math.max(2, Math.min(128, Math.round((latencyHint * sampleRate) / 128))) * 128) / sampleRate;\n            this._nativeAudioContext = nativeAudioContext;\n\n            // Bug #188: Safari will set the context's state to 'interrupted' in case the user switches tabs.\n            if (nativeAudioContextConstructor.name === 'webkitAudioContext') {\n                this._nativeGainNode = nativeAudioContext.createGain();\n                this._nativeOscillatorNode = nativeAudioContext.createOscillator();\n\n                this._nativeGainNode.gain.value = 1e-37;\n\n                this._nativeOscillatorNode.connect(this._nativeGainNode).connect(nativeAudioContext.destination);\n                this._nativeOscillatorNode.start();\n            } else {\n                this._nativeGainNode = null;\n                this._nativeOscillatorNode = null;\n            }\n\n            this._state = null;\n\n            /*\n             * Bug #34: Chrome and Edge pretend to be running right away, but fire an onstatechange event when the state actually changes\n             * to 'running'.\n             */\n            if (nativeAudioContext.state === 'running') {\n                this._state = 'suspended';\n\n                const revokeState = () => {\n                    if (this._state === 'suspended') {\n                        this._state = null;\n                    }\n\n                    nativeAudioContext.removeEventListener('statechange', revokeState);\n                };\n\n                nativeAudioContext.addEventListener('statechange', revokeState);\n            }\n        }\n\n        get baseLatency(): number {\n            return this._baseLatency;\n        }\n\n        get state(): TAudioContextState {\n            return this._state !== null ? this._state : this._nativeAudioContext.state;\n        }\n\n        public close(): Promise<void> {\n            // Bug #35: Firefox does not throw an error if the AudioContext was closed before.\n            if (this.state === 'closed') {\n                return this._nativeAudioContext.close().then(() => {\n                    throw createInvalidStateError();\n                });\n            }\n\n            // Bug #34: If the state was set to suspended before it should be revoked now.\n            if (this._state === 'suspended') {\n                this._state = null;\n            }\n\n            return this._nativeAudioContext.close().then(() => {\n                if (this._nativeGainNode !== null && this._nativeOscillatorNode !== null) {\n                    this._nativeOscillatorNode.stop();\n\n                    this._nativeGainNode.disconnect();\n                    this._nativeOscillatorNode.disconnect();\n                }\n\n                deactivateAudioGraph(this);\n            });\n        }\n\n        public resume(): Promise<void> {\n            if (this._state === 'suspended') {\n                return new Promise((resolve, reject) => {\n                    const resolvePromise = () => {\n                        this._nativeAudioContext.removeEventListener('statechange', resolvePromise);\n\n                        if (this._nativeAudioContext.state === 'running') {\n                            resolve();\n                        } else {\n                            this.resume().then(resolve, reject);\n                        }\n                    };\n\n                    this._nativeAudioContext.addEventListener('statechange', resolvePromise);\n                });\n            }\n\n            return this._nativeAudioContext.resume().catch((err) => {\n                // Bug #55: Chrome and Edge do throw an InvalidAccessError instead of an InvalidStateError.\n                // Bug #56: Safari invokes the catch handler but without an error.\n                if (err === undefined || err.code === 15) {\n                    throw createInvalidStateError();\n                }\n\n                throw err;\n            });\n        }\n\n        public suspend(): Promise<void> {\n            return this._nativeAudioContext.suspend().catch((err) => {\n                // Bug #56: Safari invokes the catch handler but without an error.\n                if (err === undefined) {\n                    throw createInvalidStateError();\n                }\n\n                throw err;\n            });\n        }\n    };\n};\n", "import { CONTEXT_STORE } from '../globals';\nimport { IAudioDestinationNode, IAudioListener, IMinimalBaseAudioContext, IMinimalBaseAudioContextEventMap } from '../interfaces';\nimport { TAudioContextState, TContext, TEventHandler, TMinimalBaseAudioContextConstructorFactory, TNativeContext } from '../types';\n\nexport const createMinimalBaseAudioContextConstructor: TMinimalBaseAudioContextConstructorFactory = (\n    audioDestinationNodeConstructor,\n    createAudioListener,\n    eventTargetConstructor,\n    isNativeOfflineAudioContext,\n    unrenderedAudioWorkletNodeStore,\n    wrapEventListener\n) => {\n    return class MinimalBaseAudioContext<T extends TContext>\n        extends eventTargetConstructor<IMinimalBaseAudioContextEventMap>\n        implements IMinimalBaseAudioContext<T>\n    {\n        private _destination: IAudioDestinationNode<T>;\n\n        private _listener: IAudioListener;\n\n        private _onstatechange: null | TEventHandler<T>;\n\n        constructor(private _nativeContext: TNativeContext, numberOfChannels: number) {\n            super(_nativeContext);\n\n            CONTEXT_STORE.set(<T>(<unknown>this), _nativeContext);\n\n            if (isNativeOfflineAudioContext(_nativeContext)) {\n                unrenderedAudioWorkletNodeStore.set(_nativeContext, new Set());\n            }\n\n            this._destination = new audioDestinationNodeConstructor(<T>(<unknown>this), numberOfChannels);\n            this._listener = createAudioListener(<T>(<unknown>this), _nativeContext);\n            this._onstatechange = null;\n        }\n\n        get currentTime(): number {\n            return this._nativeContext.currentTime;\n        }\n\n        get destination(): IAudioDestinationNode<T> {\n            return this._destination;\n        }\n\n        get listener(): IAudioListener {\n            return this._listener;\n        }\n\n        get onstatechange(): null | TEventHandler<T> {\n            return this._onstatechange;\n        }\n\n        set onstatechange(value) {\n            const wrappedListener = typeof value === 'function' ? wrapEventListener(this, value) : null;\n\n            this._nativeContext.onstatechange = wrappedListener;\n\n            const nativeOnStateChange = this._nativeContext.onstatechange;\n\n            this._onstatechange = nativeOnStateChange !== null && nativeOnStateChange === wrappedListener ? value : nativeOnStateChange;\n        }\n\n        get sampleRate(): number {\n            return this._nativeContext.sampleRate;\n        }\n\n        get state(): TAudioContextState {\n            return this._nativeContext.state;\n        }\n    };\n};\n", "import { TNativeContext } from '../types';\n\nexport const testPromiseSupport = (nativeContext: TNativeContext): boolean => {\n    // This 12 numbers represent the 48 bytes of an empty WAVE file with a single sample.\n    const uint32Array = new Uint32Array([1179011410, 40, 1163280727, 544501094, 16, 131073, 44100, 176400, 1048580, 1635017060, 4, 0]);\n\n    try {\n        // Bug #1: Safari requires a successCallback.\n        const promise = nativeContext.decodeAudioData(<ArrayBuffer>uint32Array.buffer, () => {\n            // Ignore the success callback.\n        });\n\n        if (promise === undefined) {\n            return false;\n        }\n\n        promise.catch(() => {\n            // Ignore rejected errors.\n        });\n\n        return true;\n    } catch {\n        // Ignore errors.\n    }\n\n    return false;\n};\n", "import { deactivateAudioGraph } from '../helpers/deactivate-audio-graph';\nimport { testPromiseSupport } from '../helpers/test-promise-support';\nimport { IAudioBuffer, IMinimalOfflineAudioContext, IOfflineAudioContextOptions } from '../interfaces';\nimport { TAudioContextState, TMinimalOfflineAudioContextConstructorFactory, TNativeOfflineAudioContext } from '../types';\n\nconst DEFAULT_OPTIONS = {\n    numberOfChannels: 1\n} as const;\n\nexport const createMinimalOfflineAudioContextConstructor: TMinimalOfflineAudioContextConstructorFactory = (\n    cacheTestResult,\n    createInvalidStateError,\n    createNativeOfflineAudioContext,\n    minimalBaseAudioContextConstructor,\n    startRendering\n) => {\n    return class MinimalOfflineAudioContext extends minimalBaseAudioContextConstructor<IMinimalOfflineAudioContext>\n        implements IMinimalOfflineAudioContext {\n        private _length: number;\n\n        private _nativeOfflineAudioContext: TNativeOfflineAudioContext;\n\n        private _state: null | TAudioContextState;\n\n        constructor(options: IOfflineAudioContextOptions) {\n            const { length, numberOfChannels, sampleRate } = { ...DEFAULT_OPTIONS, ...options };\n\n            const nativeOfflineAudioContext = createNativeOfflineAudioContext(numberOfChannels, length, sampleRate);\n\n            // #21 Safari does not support promises and therefore would fire the statechange event before the promise can be resolved.\n            if (!cacheTestResult(testPromiseSupport, () => testPromiseSupport(nativeOfflineAudioContext))) {\n                nativeOfflineAudioContext.addEventListener(\n                    'statechange',\n                    (() => {\n                        let i = 0;\n\n                        const delayStateChangeEvent = (event: Event) => {\n                            if (this._state === 'running') {\n                                if (i > 0) {\n                                    nativeOfflineAudioContext.removeEventListener('statechange', delayStateChangeEvent);\n                                    event.stopImmediatePropagation();\n\n                                    this._waitForThePromiseToSettle(event);\n                                } else {\n                                    i += 1;\n                                }\n                            }\n                        };\n\n                        return delayStateChangeEvent;\n                    })()\n                );\n            }\n\n            super(nativeOfflineAudioContext, numberOfChannels);\n\n            this._length = length;\n            this._nativeOfflineAudioContext = nativeOfflineAudioContext;\n            this._state = null;\n        }\n\n        get length(): number {\n            // Bug #17: Safari does not yet expose the length.\n            if (this._nativeOfflineAudioContext.length === undefined) {\n                return this._length;\n            }\n\n            return this._nativeOfflineAudioContext.length;\n        }\n\n        get state(): TAudioContextState {\n            return this._state === null ? this._nativeOfflineAudioContext.state : this._state;\n        }\n\n        public startRendering(): Promise<IAudioBuffer> {\n            /*\n             * Bug #9 & #59: It is theoretically possible that startRendering() will first render a partialOfflineAudioContext. Therefore\n             * the state of the nativeOfflineAudioContext might no transition to running immediately.\n             */\n            if (this._state === 'running') {\n                return Promise.reject(createInvalidStateError());\n            }\n\n            this._state = 'running';\n\n            return startRendering(this.destination, this._nativeOfflineAudioContext).finally(() => {\n                this._state = null;\n\n                deactivateAudioGraph(this);\n            });\n        }\n\n        private _waitForThePromiseToSettle(event: Event): void {\n            if (this._state === null) {\n                this._nativeOfflineAudioContext.dispatchEvent(event);\n            } else {\n                setTimeout(() => this._waitForThePromiseToSettle(event));\n            }\n        }\n    };\n};\n", "import { TMonitorConnectionsFactory, TNativeAudioNode, TNativeAudioParam } from '../types';\n\nexport const createMonitorConnections: TMonitorConnectionsFactory = (insertElementInSet, isNativeAudioNode) => {\n    return (nativeAudioNode, whenConnected, whenDisconnected) => {\n        const connections = new Set<[TNativeAudioNode, number, number] | [TNativeAudioParam, number]>();\n\n        nativeAudioNode.connect = <TNativeAudioNode['connect']>((connect) => {\n            // tslint:disable-next-line:invalid-void no-inferrable-types\n            return (destination: TNativeAudioNode | TNativeAudioParam, output = 0, input: number = 0): void | TNativeAudioNode => {\n                const wasDisconnected = connections.size === 0;\n\n                if (isNativeAudioNode(destination)) {\n                    // @todo TypeScript cannot infer the overloaded signature with 3 arguments yet.\n                    (<(destination: TNativeAudioNode, output?: number, input?: number) => TNativeAudioNode>connect).call(\n                        nativeAudioNode,\n                        destination,\n                        output,\n                        input\n                    );\n\n                    insertElementInSet(\n                        connections,\n                        [destination, output, input],\n                        (connection) => connection[0] === destination && connection[1] === output && connection[2] === input,\n                        true\n                    );\n\n                    if (wasDisconnected) {\n                        whenConnected();\n                    }\n\n                    return destination;\n                }\n\n                connect.call(nativeAudioNode, destination, output);\n\n                insertElementInSet(\n                    connections,\n                    [destination, output],\n                    (connection) => connection[0] === destination && connection[1] === output,\n                    true\n                );\n\n                if (wasDisconnected) {\n                    whenConnected();\n                }\n\n                return;\n            };\n        })(nativeAudioNode.connect);\n\n        nativeAudioNode.disconnect = ((disconnect) => {\n            return (destinationOrOutput?: number | TNativeAudioNode | TNativeAudioParam, output?: number, input?: number): void => {\n                const wasConnected = connections.size > 0;\n\n                if (destinationOrOutput === undefined) {\n                    disconnect.apply(nativeAudioNode);\n\n                    connections.clear();\n                } else if (typeof destinationOrOutput === 'number') {\n                    // @todo TypeScript cannot infer the overloaded signature with 1 argument yet.\n                    (<(output: number) => void>disconnect).call(nativeAudioNode, destinationOrOutput);\n\n                    for (const connection of connections) {\n                        if (connection[1] === destinationOrOutput) {\n                            connections.delete(connection);\n                        }\n                    }\n                } else {\n                    if (isNativeAudioNode(destinationOrOutput)) {\n                        // @todo TypeScript cannot infer the overloaded signature with 3 arguments yet.\n                        (<(destination: TNativeAudioNode, output?: number, input?: number) => void>disconnect).call(\n                            nativeAudioNode,\n                            destinationOrOutput,\n                            output,\n                            input\n                        );\n                    } else {\n                        // @todo TypeScript cannot infer the overloaded signature with 2 arguments yet.\n                        (<(destination: TNativeAudioParam, output?: number) => void>disconnect).call(\n                            nativeAudioNode,\n                            destinationOrOutput,\n                            output\n                        );\n                    }\n\n                    for (const connection of connections) {\n                        if (\n                            connection[0] === destinationOrOutput &&\n                            (output === undefined || connection[1] === output) &&\n                            (input === undefined || connection[2] === input)\n                        ) {\n                            connections.delete(connection);\n                        }\n                    }\n                }\n\n                const isDisconnected = connections.size === 0;\n\n                if (wasConnected && isDisconnected) {\n                    whenDisconnected();\n                }\n            };\n        })(nativeAudioNode.disconnect);\n\n        return nativeAudioNode;\n    };\n};\n", "export const assignNativeAudioNodeOption = <T extends keyof any, U extends any>(\n    nativeAudioNode: Record<T, U>,\n    options: Record<T, U>,\n    option: T\n) => {\n    const value = options[option];\n\n    if (value !== undefined && value !== nativeAudioNode[option]) {\n        nativeAudioNode[option] = value;\n    }\n};\n", "import { IAudioNodeOptions } from '../interfaces';\nimport { TNativeAudioNode } from '../types';\nimport { assignNativeAudioNodeOption } from './assign-native-audio-node-option';\n\nexport const assignNativeAudioNodeOptions = (nativeAudioNode: TNativeAudioNode, options: IAudioNodeOptions): void => {\n    assignNativeAudioNodeOption(nativeAudioNode, options, 'channelCount');\n    assignNativeAudioNodeOption(nativeAudioNode, options, 'channelCountMode');\n    assignNativeAudioNodeOption(nativeAudioNode, options, 'channelInterpretation');\n};\n", "import { TNativeAnalyserNode } from '../types';\n\nexport const testAnalyserNodeGetFloatTimeDomainDataMethodSupport = (nativeAnalyserNode: TNativeAnalyserNode): boolean => {\n    return typeof nativeAnalyserNode.getFloatTimeDomainData === 'function';\n};\n", "import { TNativeAnalyserNode } from '../types';\n\nexport const wrapAnalyserNodeGetFloatTimeDomainDataMethod = (nativeAnalyserNode: TNativeAnalyserNode): void => {\n    nativeAnalyserNode.getFloatTimeDomainData = (array: Float32Array) => {\n        const byteTimeDomainData = new Uint8Array(array.length);\n\n        nativeAnalyserNode.getByteTimeDomainData(byteTimeDomainData);\n\n        const length = Math.max(byteTimeDomainData.length, nativeAnalyserNode.fftSize);\n\n        for (let i = 0; i < length; i += 1) {\n            array[i] = (byteTimeDomainData[i] - 128) * 0.0078125;\n        }\n\n        return array;\n    };\n};\n", "import { assignNativeAudioNodeOption } from '../helpers/assign-native-audio-node-option';\nimport { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nimport { testAnalyserNodeGetFloatTimeDomainDataMethodSupport } from '../helpers/test-analyser-node-get-float-time-domain-data-method-support';\nimport { wrapAnalyserNodeGetFloatTimeDomainDataMethod } from '../helpers/wrap-analyser-node-get-float-time-domain-data-method';\nimport { TNativeAnalyserNodeFactoryFactory } from '../types';\n\nexport const createNativeAnalyserNodeFactory: TNativeAnalyserNodeFactoryFactory = (cacheTestResult, createIndexSizeError) => {\n    return (nativeContext, options) => {\n        const nativeAnalyserNode = nativeContext.createAnalyser();\n\n        // Bug #37: Firefox does not create an AnalyserNode with the default properties.\n        assignNativeAudioNodeOptions(nativeAnalyserNode, options);\n\n        // Bug #118: Safari does not throw an error if maxDecibels is not more than minDecibels.\n        if (!(options.maxDecibels > options.minDecibels)) {\n            throw createIndexSizeError();\n        }\n\n        assignNativeAudioNodeOption(nativeAnalyserNode, options, 'fftSize');\n        assignNativeAudioNodeOption(nativeAnalyserNode, options, 'maxDecibels');\n        assignNativeAudioNodeOption(nativeAnalyserNode, options, 'minDecibels');\n        assignNativeAudioNodeOption(nativeAnalyserNode, options, 'smoothingTimeConstant');\n\n        // Bug #36: Safari does not support getFloatTimeDomainData() yet.\n        if (\n            !cacheTestResult(testAnalyserNodeGetFloatTimeDomainDataMethodSupport, () =>\n                testAnalyserNodeGetFloatTimeDomainDataMethodSupport(nativeAnalyserNode)\n            )\n        ) {\n            wrapAnalyserNodeGetFloatTimeDomainDataMethod(nativeAnalyserNode);\n        }\n\n        return nativeAnalyserNode;\n    };\n};\n", "import { TNativeAudioBufferConstructorFactory } from '../types';\n\nexport const createNativeAudioBufferConstructor: TNativeAudioBufferConstructorFactory = (window) => {\n    if (window === null) {\n        return null;\n    }\n\n    if (window.hasOwnProperty('AudioBuffer')) {\n        return window.AudioBuffer;\n    }\n\n    return null;\n};\n", "export const assignNativeAudioNodeAudioParamValue = <T extends { [key: string]: any }, U extends { [key: string]: any }>(\n    nativeAudioNode: T,\n    options: U,\n    audioParam: keyof T & keyof U\n) => {\n    const value = options[audioParam];\n\n    if (value !== undefined && value !== nativeAudioNode[audioParam].value) {\n        nativeAudioNode[audioParam].value = value;\n    }\n};\n", "import { createInvalidStateError } from '../factories/invalid-state-error';\nimport { TNativeAudioBufferSourceNode } from '../types';\n\nexport const wrapAudioBufferSourceNodeStartMethodConsecutiveCalls = (nativeAudioBufferSourceNode: TNativeAudioBufferSourceNode): void => {\n    nativeAudioBufferSourceNode.start = ((start) => {\n        let isScheduled = false;\n\n        return (when = 0, offset = 0, duration?: number) => {\n            if (isScheduled) {\n                throw createInvalidStateError();\n            }\n\n            start.call(nativeAudioBufferSourceNode, when, offset, duration);\n\n            isScheduled = true;\n        };\n    })(nativeAudioBufferSourceNode.start);\n};\n", "import { TNativeAudioBufferSourceNode, TNativeConstantSourceNode, TNativeOscillatorNode } from '../types';\n\nexport const wrapAudioScheduledSourceNodeStartMethodNegativeParameters = (\n    nativeAudioScheduledSourceNode: TNativeAudioBufferSourceNode | TNativeConstantSourceNode | TNativeOscillatorNode\n): void => {\n    nativeAudioScheduledSourceNode.start = ((start) => {\n        return (when = 0, offset = 0, duration?: number) => {\n            if ((typeof duration === 'number' && duration < 0) || offset < 0 || when < 0) {\n                throw new RangeError(\"The parameters can't be negative.\");\n            }\n\n            // @todo TypeScript cannot infer the overloaded signature with 3 arguments yet.\n            (<(when: number, offset: number, duration?: number) => void>start).call(nativeAudioScheduledSourceNode, when, offset, duration);\n        };\n    })(nativeAudioScheduledSourceNode.start);\n};\n", "import { TNativeAudioBufferSourceNode, TNativeConstantSourceNode, TNativeOscillatorNode } from '../types';\n\nexport const wrapAudioScheduledSourceNodeStopMethodNegativeParameters = (\n    nativeAudioScheduledSourceNode: TNativeAudioBufferSourceNode | TNativeConstantSourceNode | TNativeOscillatorNode\n): void => {\n    nativeAudioScheduledSourceNode.stop = ((stop) => {\n        return (when = 0) => {\n            if (when < 0) {\n                throw new RangeError(\"The parameter can't be negative.\");\n            }\n\n            stop.call(nativeAudioScheduledSourceNode, when);\n        };\n    })(nativeAudioScheduledSourceNode.stop);\n};\n", "import { assignNativeAudioNodeAudioParamValue } from '../helpers/assign-native-audio-node-audio-param-value';\nimport { assignNativeAudioNodeOption } from '../helpers/assign-native-audio-node-option';\nimport { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nimport { wrapAudioBufferSourceNodeStartMethodConsecutiveCalls } from '../helpers/wrap-audio-buffer-source-node-start-method-consecutive-calls';\nimport { wrapAudioScheduledSourceNodeStartMethodNegativeParameters } from '../helpers/wrap-audio-scheduled-source-node-start-method-negative-parameters';\nimport { wrapAudioScheduledSourceNodeStopMethodNegativeParameters } from '../helpers/wrap-audio-scheduled-source-node-stop-method-negative-parameters';\nimport { TNativeAudioBufferSourceNodeFactoryFactory } from '../types';\n\nexport const createNativeAudioBufferSourceNodeFactory: TNativeAudioBufferSourceNodeFactoryFactory = (\n    addSilentConnection,\n    cacheTestResult,\n    testAudioBufferSourceNodeStartMethodConsecutiveCallsSupport,\n    testAudioBufferSourceNodeStartMethodOffsetClampingSupport,\n    testAudioBufferSourceNodeStopMethodNullifiedBufferSupport,\n    testAudioScheduledSourceNodeStartMethodNegativeParametersSupport,\n    testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport,\n    testAudioScheduledSourceNodeStopMethodNegativeParametersSupport,\n    wrapAudioBufferSourceNodeStartMethodOffsetClampling,\n    wrapAudioBufferSourceNodeStopMethodNullifiedBuffer,\n    wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls\n) => {\n    return (nativeContext, options) => {\n        const nativeAudioBufferSourceNode = nativeContext.createBufferSource();\n\n        assignNativeAudioNodeOptions(nativeAudioBufferSourceNode, options);\n\n        assignNativeAudioNodeAudioParamValue(nativeAudioBufferSourceNode, options, 'playbackRate');\n\n        assignNativeAudioNodeOption(nativeAudioBufferSourceNode, options, 'buffer');\n\n        // Bug #149: Safari does not yet support the detune AudioParam.\n\n        assignNativeAudioNodeOption(nativeAudioBufferSourceNode, options, 'loop');\n        assignNativeAudioNodeOption(nativeAudioBufferSourceNode, options, 'loopEnd');\n        assignNativeAudioNodeOption(nativeAudioBufferSourceNode, options, 'loopStart');\n\n        // Bug #69: Safari does allow calls to start() of an already scheduled AudioBufferSourceNode.\n        if (\n            !cacheTestResult(testAudioBufferSourceNodeStartMethodConsecutiveCallsSupport, () =>\n                testAudioBufferSourceNodeStartMethodConsecutiveCallsSupport(nativeContext)\n            )\n        ) {\n            wrapAudioBufferSourceNodeStartMethodConsecutiveCalls(nativeAudioBufferSourceNode);\n        }\n\n        // Bug #154 & #155: Safari does not handle offsets which are equal to or greater than the duration of the buffer.\n        if (\n            !cacheTestResult(testAudioBufferSourceNodeStartMethodOffsetClampingSupport, () =>\n                testAudioBufferSourceNodeStartMethodOffsetClampingSupport(nativeContext)\n            )\n        ) {\n            wrapAudioBufferSourceNodeStartMethodOffsetClampling(nativeAudioBufferSourceNode);\n        }\n\n        // Bug #162: Safari does throw an error when stop() is called on an AudioBufferSourceNode which has no buffer assigned to it.\n        if (\n            !cacheTestResult(testAudioBufferSourceNodeStopMethodNullifiedBufferSupport, () =>\n                testAudioBufferSourceNodeStopMethodNullifiedBufferSupport(nativeContext)\n            )\n        ) {\n            wrapAudioBufferSourceNodeStopMethodNullifiedBuffer(nativeAudioBufferSourceNode, nativeContext);\n        }\n\n        // Bug #44: Safari does not throw a RangeError yet.\n        if (\n            !cacheTestResult(testAudioScheduledSourceNodeStartMethodNegativeParametersSupport, () =>\n                testAudioScheduledSourceNodeStartMethodNegativeParametersSupport(nativeContext)\n            )\n        ) {\n            wrapAudioScheduledSourceNodeStartMethodNegativeParameters(nativeAudioBufferSourceNode);\n        }\n\n        // Bug #19: Safari does not ignore calls to stop() of an already stopped AudioBufferSourceNode.\n        if (\n            !cacheTestResult(testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport, () =>\n                testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport(nativeContext)\n            )\n        ) {\n            wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls(nativeAudioBufferSourceNode, nativeContext);\n        }\n\n        // Bug #44: Only Firefox does not throw a RangeError yet.\n        if (\n            !cacheTestResult(testAudioScheduledSourceNodeStopMethodNegativeParametersSupport, () =>\n                testAudioScheduledSourceNodeStopMethodNegativeParametersSupport(nativeContext)\n            )\n        ) {\n            wrapAudioScheduledSourceNodeStopMethodNegativeParameters(nativeAudioBufferSourceNode);\n        }\n\n        // Bug #175: Safari will not fire an ended event if the AudioBufferSourceNode is unconnected.\n        addSilentConnection(nativeContext, nativeAudioBufferSourceNode);\n\n        return nativeAudioBufferSourceNode;\n    };\n};\n", "import { TNativeAudioContextConstructorFactory } from '../types';\n\nexport const createNativeAudioContextConstructor: TNativeAudioContextConstructorFactory = (window) => {\n    if (window === null) {\n        return null;\n    }\n\n    if (window.hasOwnProperty('AudioContext')) {\n        return window.AudioContext;\n    }\n\n    return window.hasOwnProperty('webkitAudioContext') ? (<any>window).webkitAudioContext : null;\n};\n", "import { TNativeAudioDestinationNode, TNativeAudioDestinationNodeFactoryFactory, TNativeGainNode } from '../types';\n\nexport const createNativeAudioDestinationNodeFactory: TNativeAudioDestinationNodeFactoryFactory = (\n    createNativeGainNode,\n    overwriteAccessors\n) => {\n    return (nativeContext, channelCount, isNodeOfNativeOfflineAudioContext) => {\n        const nativeAudioDestinationNode = nativeContext.destination;\n\n        // Bug #132: Safari does not have the correct channelCount.\n        if (nativeAudioDestinationNode.channelCount !== channelCount) {\n            try {\n                nativeAudioDestinationNode.channelCount = channelCount;\n            } catch {\n                // Bug #169: Safari throws an error on each attempt to change the channelCount.\n            }\n        }\n\n        // Bug #83: Safari does not have the correct channelCountMode.\n        if (isNodeOfNativeOfflineAudioContext && nativeAudioDestinationNode.channelCountMode !== 'explicit') {\n            nativeAudioDestinationNode.channelCountMode = 'explicit';\n        }\n\n        // Bug #47: The AudioDestinationNode in Safari does not initialize the maxChannelCount property correctly.\n        if (nativeAudioDestinationNode.maxChannelCount === 0) {\n            Object.defineProperty(nativeAudioDestinationNode, 'maxChannelCount', {\n                value: channelCount\n            });\n        }\n\n        // Bug #168: No browser does yet have an AudioDestinationNode with an output.\n        const gainNode = createNativeGainNode(nativeContext, {\n            channelCount,\n            channelCountMode: nativeAudioDestinationNode.channelCountMode,\n            channelInterpretation: nativeAudioDestinationNode.channelInterpretation,\n            gain: 1\n        });\n\n        overwriteAccessors(\n            gainNode,\n            'channelCount',\n            (get) => () => get.call(gainNode),\n            (set) => (value) => {\n                set.call(gainNode, value);\n\n                try {\n                    nativeAudioDestinationNode.channelCount = value;\n                } catch (err) {\n                    // Bug #169: Safari throws an error on each attempt to change the channelCount.\n                    if (value > nativeAudioDestinationNode.maxChannelCount) {\n                        throw err;\n                    }\n                }\n            }\n        );\n\n        overwriteAccessors(\n            gainNode,\n            'channelCountMode',\n            (get) => () => get.call(gainNode),\n            (set) => (value) => {\n                set.call(gainNode, value);\n                nativeAudioDestinationNode.channelCountMode = value;\n            }\n        );\n\n        overwriteAccessors(\n            gainNode,\n            'channelInterpretation',\n            (get) => () => get.call(gainNode),\n            (set) => (value) => {\n                set.call(gainNode, value);\n                nativeAudioDestinationNode.channelInterpretation = value;\n            }\n        );\n\n        Object.defineProperty(gainNode, 'maxChannelCount', {\n            get: () => nativeAudioDestinationNode.maxChannelCount\n        });\n\n        // @todo This should be disconnected when the context is closed.\n        gainNode.connect(nativeAudioDestinationNode);\n\n        return <{ maxChannelCount: TNativeAudioDestinationNode['maxChannelCount'] } & TNativeGainNode>gainNode;\n    };\n};\n", "import { TNativeAudioWorkletNodeConstructorFactory } from '../types';\n\nexport const createNativeAudioWorkletNodeConstructor: TNativeAudioWorkletNodeConstructorFactory = (window) => {\n    if (window === null) {\n        return null;\n    }\n\n    return window.hasOwnProperty('AudioWorkletNode') ? window.AudioWorkletNode : null;\n};\n", "import { IAudioWorkletNodeOptions } from '../interfaces';\n\nexport const testClonabilityOfAudioWorkletNodeOptions = (audioWorkletNodeOptions: IAudioWorkletNodeOptions): void => {\n    const { port1 } = new MessageChannel();\n\n    try {\n        // This will throw an error if the audioWorkletNodeOptions are not clonable.\n        port1.postMessage(audioWorkletNodeOptions);\n    } finally {\n        port1.close();\n    }\n};\n", "import { testClonabilityOfAudioWorkletNodeOptions } from '../helpers/test-clonability-of-audio-worklet-node-options';\nimport { TNativeAudioWorkletNode, TNativeAudioWorkletNodeFactoryFactory, TNativeAudioWorkletNodeOptions } from '../types';\n\nexport const createNativeAudioWorkletNodeFactory: TNativeAudioWorkletNodeFactoryFactory = (\n    createInvalidStateError,\n    createNativeAudioWorkletNodeFaker,\n    createNativeGainNode,\n    createNotSupportedError,\n    monitorConnections\n) => {\n    return (nativeContext, baseLatency, nativeAudioWorkletNodeConstructor, name, processorConstructor, options) => {\n        if (nativeAudioWorkletNodeConstructor !== null) {\n            try {\n                const nativeAudioWorkletNode = new nativeAudioWorkletNodeConstructor(\n                    nativeContext,\n                    name,\n                    <TNativeAudioWorkletNodeOptions>options\n                );\n                const patchedEventListeners: Map<\n                    EventListenerOrEventListenerObject,\n                    NonNullable<TNativeAudioWorkletNode['onprocessorerror']>\n                > = new Map();\n\n                let onprocessorerror: TNativeAudioWorkletNode['onprocessorerror'] = null;\n\n                Object.defineProperties(nativeAudioWorkletNode, {\n                    /*\n                     * Bug #61: Overwriting the property accessors for channelCount and channelCountMode is necessary as long as some\n                     * browsers have no native implementation to achieve a consistent behavior.\n                     */\n                    channelCount: {\n                        get: () => options.channelCount,\n                        set: () => {\n                            throw createInvalidStateError();\n                        }\n                    },\n                    channelCountMode: {\n                        get: () => 'explicit',\n                        set: () => {\n                            throw createInvalidStateError();\n                        }\n                    },\n                    // Bug #156: Chrome and Edge do not yet fire an ErrorEvent.\n                    onprocessorerror: {\n                        get: () => onprocessorerror,\n                        set: (value) => {\n                            if (typeof onprocessorerror === 'function') {\n                                nativeAudioWorkletNode.removeEventListener('processorerror', onprocessorerror);\n                            }\n\n                            onprocessorerror = typeof value === 'function' ? value : null;\n\n                            if (typeof onprocessorerror === 'function') {\n                                nativeAudioWorkletNode.addEventListener('processorerror', onprocessorerror);\n                            }\n                        }\n                    }\n                });\n\n                nativeAudioWorkletNode.addEventListener = ((addEventListener) => {\n                    return (...args: [string, EventListenerOrEventListenerObject, (boolean | AddEventListenerOptions)?]): void => {\n                        if (args[0] === 'processorerror') {\n                            const unpatchedEventListener =\n                                typeof args[1] === 'function'\n                                    ? args[1]\n                                    : typeof args[1] === 'object' && args[1] !== null && typeof args[1].handleEvent === 'function'\n                                    ? args[1].handleEvent\n                                    : null;\n\n                            if (unpatchedEventListener !== null) {\n                                const patchedEventListener = patchedEventListeners.get(args[1]);\n\n                                if (patchedEventListener !== undefined) {\n                                    args[1] = patchedEventListener;\n                                } else {\n                                    args[1] = (event: Event) => {\n                                        // Bug #178: Chrome and Edge do fire an event of type error.\n                                        if (event.type === 'error') {\n                                            Object.defineProperties(event, {\n                                                type: { value: 'processorerror' }\n                                            });\n\n                                            unpatchedEventListener(event);\n                                        } else {\n                                            unpatchedEventListener(new ErrorEvent(args[0], { ...event }));\n                                        }\n                                    };\n\n                                    patchedEventListeners.set(unpatchedEventListener, args[1]);\n                                }\n                            }\n                        }\n\n                        // Bug #178: Chrome and Edge do fire an event of type error.\n                        addEventListener.call(nativeAudioWorkletNode, 'error', args[1], args[2]);\n\n                        return addEventListener.call(nativeAudioWorkletNode, ...args);\n                    };\n                })(nativeAudioWorkletNode.addEventListener);\n\n                nativeAudioWorkletNode.removeEventListener = ((removeEventListener) => {\n                    return (...args: any[]): void => {\n                        if (args[0] === 'processorerror') {\n                            const patchedEventListener = patchedEventListeners.get(args[1]);\n\n                            if (patchedEventListener !== undefined) {\n                                patchedEventListeners.delete(args[1]);\n\n                                args[1] = patchedEventListener;\n                            }\n                        }\n\n                        // Bug #178: Chrome and Edge do fire an event of type error.\n                        removeEventListener.call(nativeAudioWorkletNode, 'error', args[1], args[2]);\n\n                        return removeEventListener.call(nativeAudioWorkletNode, args[0], args[1], args[2]);\n                    };\n                })(nativeAudioWorkletNode.removeEventListener);\n\n                /*\n                 * Bug #86: Chrome and Edge do not invoke the process() function if the corresponding AudioWorkletNode is unconnected but\n                 * has an output.\n                 */\n                if (options.numberOfOutputs !== 0) {\n                    const nativeGainNode = createNativeGainNode(nativeContext, {\n                        channelCount: 1,\n                        channelCountMode: 'explicit',\n                        channelInterpretation: 'discrete',\n                        gain: 0\n                    });\n\n                    nativeAudioWorkletNode.connect(nativeGainNode).connect(nativeContext.destination);\n\n                    const whenConnected = () => nativeGainNode.disconnect();\n                    const whenDisconnected = () => nativeGainNode.connect(nativeContext.destination);\n\n                    // @todo Disconnect the connection when the process() function of the AudioWorkletNode returns false.\n                    return monitorConnections(nativeAudioWorkletNode, whenConnected, whenDisconnected);\n                }\n\n                return nativeAudioWorkletNode;\n            } catch (err) {\n                // Bug #60: Chrome & Edge throw an InvalidStateError instead of a NotSupportedError.\n                if (err.code === 11) {\n                    throw createNotSupportedError();\n                }\n\n                throw err;\n            }\n        }\n\n        // Bug #61: Only Chrome & Edge have an implementation of the AudioWorkletNode yet.\n        if (processorConstructor === undefined) {\n            throw createNotSupportedError();\n        }\n\n        testClonabilityOfAudioWorkletNodeOptions(options);\n\n        return createNativeAudioWorkletNodeFaker(nativeContext, baseLatency, processorConstructor, options);\n    };\n};\n", "export const computeBufferSize = (baseLatency: null | number, sampleRate: number) => {\n    if (baseLatency === null) {\n        return 512;\n    }\n\n    return Math.max(512, Math.min(16384, Math.pow(2, Math.round(Math.log2(baseLatency * sampleRate)))));\n};\n", "import { IAudioWorkletNodeOptions } from '../interfaces';\n\nexport const cloneAudioWorkletNodeOptions = (audioWorkletNodeOptions: IAudioWorkletNodeOptions): Promise<IAudioWorkletNodeOptions> => {\n    return new Promise((resolve, reject) => {\n        const { port1, port2 } = new MessageChannel();\n\n        port1.onmessage = ({ data }) => {\n            port1.close();\n            port2.close();\n\n            resolve(data);\n        };\n        port1.onmessageerror = ({ data }) => {\n            port1.close();\n            port2.close();\n\n            reject(data);\n        };\n\n        // This will throw an error if the audioWorkletNodeOptions are not clonable.\n        port2.postMessage(audioWorkletNodeOptions);\n    });\n};\n", "import { IAudioWorkletNodeOptions, IAudioWorkletProcessor, IAudioWorkletProcessorConstructor } from '../interfaces';\nimport { cloneAudioWorkletNodeOptions } from './clone-audio-worklet-node-options';\n\nexport const createAudioWorkletProcessorPromise = async (\n    processorConstructor: IAudioWorkletProcessorConstructor,\n    audioWorkletNodeOptions: IAudioWorkletNodeOptions\n): Promise<IAudioWorkletProcessor> => {\n    const clonedAudioWorkletNodeOptions = await cloneAudioWorkletNodeOptions(audioWorkletNodeOptions);\n\n    return new processorConstructor(clonedAudioWorkletNodeOptions);\n};\n", "import { NODE_TO_PROCESSOR_MAPS } from '../globals';\nimport { IAudioWorkletNodeOptions, IAudioWorkletProcessor, IAudioWorkletProcessorConstructor } from '../interfaces';\nimport { TNativeAudioWorkletNode, TNativeContext } from '../types';\nimport { createAudioWorkletProcessorPromise } from './create-audio-worklet-processor-promise';\n\nexport const createAudioWorkletProcessor = (\n    nativeContext: TNativeContext,\n    nativeAudioWorkletNode: TNativeAudioWorkletNode,\n    processorConstructor: IAudioWorkletProcessorConstructor,\n    audioWorkletNodeOptions: IAudioWorkletNodeOptions\n): Promise<IAudioWorkletProcessor> => {\n    let nodeToProcessorMap = NODE_TO_PROCESSOR_MAPS.get(nativeContext);\n\n    if (nodeToProcessorMap === undefined) {\n        nodeToProcessorMap = new WeakMap();\n\n        NODE_TO_PROCESSOR_MAPS.set(nativeContext, nodeToProcessorMap);\n    }\n\n    const audioWorkletProcessorPromise = createAudioWorkletProcessorPromise(processorConstructor, audioWorkletNodeOptions);\n\n    nodeToProcessorMap.set(nativeAudioWorkletNode, audioWorkletProcessorPromise);\n\n    return audioWorkletProcessorPromise;\n};\n", "import { MOST_NEGATIVE_SINGLE_FLOAT, MOST_POSITIVE_SINGLE_FLOAT } from '../constants';\nimport { computeBufferSize } from '../helpers/compute-buffer-size';\nimport { copyFromChannel } from '../helpers/copy-from-channel';\nimport { copyToChannel } from '../helpers/copy-to-channel';\nimport { createAudioWorkletProcessor } from '../helpers/create-audio-worklet-processor';\nimport { createNestedArrays } from '../helpers/create-nested-arrays';\nimport { IAudioWorkletProcessor } from '../interfaces';\nimport { ReadOnlyMap } from '../read-only-map';\nimport {\n    TNativeAudioNode,\n    TNativeAudioParam,\n    TNativeAudioWorkletNode,\n    TNativeAudioWorkletNodeFakerFactoryFactory,\n    TNativeChannelMergerNode,\n    TNativeChannelSplitterNode,\n    TNativeConstantSourceNode,\n    TNativeGainNode\n} from '../types';\n\nexport const createNativeAudioWorkletNodeFakerFactory: TNativeAudioWorkletNodeFakerFactoryFactory = (\n    connectMultipleOutputs,\n    createIndexSizeError,\n    createInvalidStateError,\n    createNativeChannelMergerNode,\n    createNativeChannelSplitterNode,\n    createNativeConstantSourceNode,\n    createNativeGainNode,\n    createNativeScriptProcessorNode,\n    createNotSupportedError,\n    disconnectMultipleOutputs,\n    exposeCurrentFrameAndCurrentTime,\n    getActiveAudioWorkletNodeInputs,\n    monitorConnections\n) => {\n    return (nativeContext, baseLatency, processorConstructor, options) => {\n        if (options.numberOfInputs === 0 && options.numberOfOutputs === 0) {\n            throw createNotSupportedError();\n        }\n\n        const outputChannelCount = Array.isArray(options.outputChannelCount)\n            ? options.outputChannelCount\n            : Array.from(options.outputChannelCount);\n\n        // @todo Check if any of the channelCount values is greater than the implementation's maximum number of channels.\n        if (outputChannelCount.some((channelCount) => channelCount < 1)) {\n            throw createNotSupportedError();\n        }\n\n        if (outputChannelCount.length !== options.numberOfOutputs) {\n            throw createIndexSizeError();\n        }\n\n        // Bug #61: This is not part of the standard but required for the faker to work.\n        if (options.channelCountMode !== 'explicit') {\n            throw createNotSupportedError();\n        }\n\n        const numberOfInputChannels = options.channelCount * options.numberOfInputs;\n        const numberOfOutputChannels = outputChannelCount.reduce((sum, value) => sum + value, 0);\n        const numberOfParameters =\n            processorConstructor.parameterDescriptors === undefined ? 0 : processorConstructor.parameterDescriptors.length;\n\n        // Bug #61: This is not part of the standard but required for the faker to work.\n        if (numberOfInputChannels + numberOfParameters > 6 || numberOfOutputChannels > 6) {\n            throw createNotSupportedError();\n        }\n\n        const messageChannel = new MessageChannel();\n        const gainNodes: TNativeGainNode[] = [];\n        const inputChannelSplitterNodes: TNativeChannelSplitterNode[] = [];\n\n        for (let i = 0; i < options.numberOfInputs; i += 1) {\n            gainNodes.push(\n                createNativeGainNode(nativeContext, {\n                    channelCount: options.channelCount,\n                    channelCountMode: options.channelCountMode,\n                    channelInterpretation: options.channelInterpretation,\n                    gain: 1\n                })\n            );\n            inputChannelSplitterNodes.push(\n                createNativeChannelSplitterNode(nativeContext, {\n                    channelCount: options.channelCount,\n                    channelCountMode: 'explicit',\n                    channelInterpretation: 'discrete',\n                    numberOfOutputs: options.channelCount\n                })\n            );\n        }\n\n        const constantSourceNodes: TNativeConstantSourceNode[] = [];\n\n        if (processorConstructor.parameterDescriptors !== undefined) {\n            for (const { defaultValue, maxValue, minValue, name } of processorConstructor.parameterDescriptors) {\n                const constantSourceNode = createNativeConstantSourceNode(nativeContext, {\n                    channelCount: 1,\n                    channelCountMode: 'explicit',\n                    channelInterpretation: 'discrete',\n                    offset:\n                        options.parameterData[name] !== undefined\n                            ? options.parameterData[name]\n                            : defaultValue === undefined\n                            ? 0\n                            : defaultValue\n                });\n\n                Object.defineProperties(constantSourceNode.offset, {\n                    defaultValue: {\n                        get: () => (defaultValue === undefined ? 0 : defaultValue)\n                    },\n                    maxValue: {\n                        get: () => (maxValue === undefined ? MOST_POSITIVE_SINGLE_FLOAT : maxValue)\n                    },\n                    minValue: {\n                        get: () => (minValue === undefined ? MOST_NEGATIVE_SINGLE_FLOAT : minValue)\n                    }\n                });\n\n                constantSourceNodes.push(constantSourceNode);\n            }\n        }\n\n        const inputChannelMergerNode = createNativeChannelMergerNode(nativeContext, {\n            channelCount: 1,\n            channelCountMode: 'explicit',\n            channelInterpretation: 'speakers',\n            numberOfInputs: Math.max(1, numberOfInputChannels + numberOfParameters)\n        });\n        const bufferSize = computeBufferSize(baseLatency, nativeContext.sampleRate);\n        const scriptProcessorNode = createNativeScriptProcessorNode(\n            nativeContext,\n            bufferSize,\n            numberOfInputChannels + numberOfParameters,\n            // Bug #87: Only Firefox will fire an AudioProcessingEvent if there is no connected output.\n            Math.max(1, numberOfOutputChannels)\n        );\n        const outputChannelSplitterNode = createNativeChannelSplitterNode(nativeContext, {\n            channelCount: Math.max(1, numberOfOutputChannels),\n            channelCountMode: 'explicit',\n            channelInterpretation: 'discrete',\n            numberOfOutputs: Math.max(1, numberOfOutputChannels)\n        });\n        const outputChannelMergerNodes: TNativeChannelMergerNode[] = [];\n\n        for (let i = 0; i < options.numberOfOutputs; i += 1) {\n            outputChannelMergerNodes.push(\n                createNativeChannelMergerNode(nativeContext, {\n                    channelCount: 1,\n                    channelCountMode: 'explicit',\n                    channelInterpretation: 'speakers',\n                    numberOfInputs: outputChannelCount[i]\n                })\n            );\n        }\n\n        for (let i = 0; i < options.numberOfInputs; i += 1) {\n            gainNodes[i].connect(inputChannelSplitterNodes[i]);\n\n            for (let j = 0; j < options.channelCount; j += 1) {\n                inputChannelSplitterNodes[i].connect(inputChannelMergerNode, j, i * options.channelCount + j);\n            }\n        }\n\n        const parameterMap = new ReadOnlyMap(\n            processorConstructor.parameterDescriptors === undefined\n                ? []\n                : processorConstructor.parameterDescriptors.map(({ name }, index) => {\n                      const constantSourceNode = constantSourceNodes[index];\n\n                      constantSourceNode.connect(inputChannelMergerNode, 0, numberOfInputChannels + index);\n                      constantSourceNode.start(0);\n\n                      return <[string, TNativeAudioParam]>[name, constantSourceNode.offset];\n                  })\n        );\n\n        inputChannelMergerNode.connect(scriptProcessorNode);\n\n        let channelInterpretation = options.channelInterpretation;\n        let onprocessorerror: TNativeAudioWorkletNode['onprocessorerror'] = null;\n\n        // Bug #87: Expose at least one output to make this node connectable.\n        const outputAudioNodes = options.numberOfOutputs === 0 ? [scriptProcessorNode] : outputChannelMergerNodes;\n        const nativeAudioWorkletNodeFaker = {\n            get bufferSize(): number {\n                return bufferSize;\n            },\n            get channelCount(): number {\n                return options.channelCount;\n            },\n            set channelCount(_) {\n                // Bug #61: This is not part of the standard but required for the faker to work.\n                throw createInvalidStateError();\n            },\n            get channelCountMode(): TNativeAudioWorkletNode['channelCountMode'] {\n                return options.channelCountMode;\n            },\n            set channelCountMode(_) {\n                // Bug #61: This is not part of the standard but required for the faker to work.\n                throw createInvalidStateError();\n            },\n            get channelInterpretation(): TNativeAudioWorkletNode['channelInterpretation'] {\n                return channelInterpretation;\n            },\n            set channelInterpretation(value) {\n                for (const gainNode of gainNodes) {\n                    gainNode.channelInterpretation = value;\n                }\n\n                channelInterpretation = value;\n            },\n            get context(): TNativeAudioWorkletNode['context'] {\n                return scriptProcessorNode.context;\n            },\n            get inputs(): TNativeAudioNode[] {\n                return gainNodes;\n            },\n            get numberOfInputs(): number {\n                return options.numberOfInputs;\n            },\n            get numberOfOutputs(): number {\n                return options.numberOfOutputs;\n            },\n            get onprocessorerror(): TNativeAudioWorkletNode['onprocessorerror'] {\n                return onprocessorerror;\n            },\n            set onprocessorerror(value) {\n                if (typeof onprocessorerror === 'function') {\n                    nativeAudioWorkletNodeFaker.removeEventListener('processorerror', onprocessorerror);\n                }\n\n                onprocessorerror = typeof value === 'function' ? value : null;\n\n                if (typeof onprocessorerror === 'function') {\n                    nativeAudioWorkletNodeFaker.addEventListener('processorerror', onprocessorerror);\n                }\n            },\n            get parameters(): TNativeAudioWorkletNode['parameters'] {\n                return parameterMap;\n            },\n            get port(): TNativeAudioWorkletNode['port'] {\n                return messageChannel.port2;\n            },\n            addEventListener(...args: any[]): void {\n                return scriptProcessorNode.addEventListener(args[0], args[1], args[2]);\n            },\n            connect: <TNativeAudioNode['connect']>connectMultipleOutputs.bind(null, outputAudioNodes),\n            disconnect: <TNativeAudioNode['disconnect']>disconnectMultipleOutputs.bind(null, outputAudioNodes),\n            dispatchEvent(...args: any[]): boolean {\n                return scriptProcessorNode.dispatchEvent(args[0]);\n            },\n            removeEventListener(...args: any[]): void {\n                return scriptProcessorNode.removeEventListener(args[0], args[1], args[2]);\n            }\n        };\n\n        const patchedEventListeners: Map<EventListenerOrEventListenerObject, NonNullable<MessagePort['onmessage']>> = new Map();\n\n        messageChannel.port1.addEventListener = ((addEventListener) => {\n            return (...args: [string, EventListenerOrEventListenerObject, (boolean | AddEventListenerOptions)?]): void => {\n                if (args[0] === 'message') {\n                    const unpatchedEventListener =\n                        typeof args[1] === 'function'\n                            ? args[1]\n                            : typeof args[1] === 'object' && args[1] !== null && typeof args[1].handleEvent === 'function'\n                            ? args[1].handleEvent\n                            : null;\n\n                    if (unpatchedEventListener !== null) {\n                        const patchedEventListener = patchedEventListeners.get(args[1]);\n\n                        if (patchedEventListener !== undefined) {\n                            args[1] = <EventListenerOrEventListenerObject>patchedEventListener;\n                        } else {\n                            args[1] = (event: Event) => {\n                                exposeCurrentFrameAndCurrentTime(nativeContext.currentTime, nativeContext.sampleRate, () =>\n                                    unpatchedEventListener(event)\n                                );\n                            };\n\n                            patchedEventListeners.set(unpatchedEventListener, args[1]);\n                        }\n                    }\n                }\n\n                return addEventListener.call(messageChannel.port1, args[0], args[1], args[2]);\n            };\n        })(messageChannel.port1.addEventListener);\n\n        messageChannel.port1.removeEventListener = ((removeEventListener) => {\n            return (...args: any[]): void => {\n                if (args[0] === 'message') {\n                    const patchedEventListener = patchedEventListeners.get(args[1]);\n\n                    if (patchedEventListener !== undefined) {\n                        patchedEventListeners.delete(args[1]);\n\n                        args[1] = patchedEventListener;\n                    }\n                }\n\n                return removeEventListener.call(messageChannel.port1, args[0], args[1], args[2]);\n            };\n        })(messageChannel.port1.removeEventListener);\n\n        let onmessage: MessagePort['onmessage'] = null;\n\n        Object.defineProperty(messageChannel.port1, 'onmessage', {\n            get: () => onmessage,\n            set: (value) => {\n                if (typeof onmessage === 'function') {\n                    messageChannel.port1.removeEventListener('message', onmessage);\n                }\n\n                onmessage = typeof value === 'function' ? value : null;\n\n                if (typeof onmessage === 'function') {\n                    messageChannel.port1.addEventListener('message', onmessage);\n                    messageChannel.port1.start();\n                }\n            }\n        });\n\n        processorConstructor.prototype.port = messageChannel.port1;\n\n        let audioWorkletProcessor: null | IAudioWorkletProcessor = null;\n\n        const audioWorkletProcessorPromise = createAudioWorkletProcessor(\n            nativeContext,\n            nativeAudioWorkletNodeFaker,\n            processorConstructor,\n            options\n        );\n\n        audioWorkletProcessorPromise.then((dWrkltPrcssr) => (audioWorkletProcessor = dWrkltPrcssr));\n\n        const inputs = createNestedArrays(options.numberOfInputs, options.channelCount);\n        const outputs = createNestedArrays(options.numberOfOutputs, outputChannelCount);\n        const parameters: { [name: string]: Float32Array } =\n            processorConstructor.parameterDescriptors === undefined\n                ? []\n                : processorConstructor.parameterDescriptors.reduce(\n                      (prmtrs, { name }) => ({ ...prmtrs, [name]: new Float32Array(128) }),\n                      {}\n                  );\n\n        let isActive = true;\n\n        const disconnectOutputsGraph = () => {\n            if (options.numberOfOutputs > 0) {\n                scriptProcessorNode.disconnect(outputChannelSplitterNode);\n            }\n\n            for (let i = 0, outputChannelSplitterNodeOutput = 0; i < options.numberOfOutputs; i += 1) {\n                const outputChannelMergerNode = outputChannelMergerNodes[i];\n\n                for (let j = 0; j < outputChannelCount[i]; j += 1) {\n                    outputChannelSplitterNode.disconnect(outputChannelMergerNode, outputChannelSplitterNodeOutput + j, j);\n                }\n\n                outputChannelSplitterNodeOutput += outputChannelCount[i];\n            }\n        };\n\n        const activeInputIndexes = new Map<number, number>();\n\n        // tslint:disable-next-line:deprecation\n        scriptProcessorNode.onaudioprocess = ({ inputBuffer, outputBuffer }: AudioProcessingEvent) => {\n            if (audioWorkletProcessor !== null) {\n                const activeInputs = getActiveAudioWorkletNodeInputs(nativeAudioWorkletNodeFaker);\n\n                for (let i = 0; i < bufferSize; i += 128) {\n                    for (let j = 0; j < options.numberOfInputs; j += 1) {\n                        for (let k = 0; k < options.channelCount; k += 1) {\n                            copyFromChannel(inputBuffer, inputs[j], k, k, i);\n                        }\n                    }\n\n                    if (processorConstructor.parameterDescriptors !== undefined) {\n                        processorConstructor.parameterDescriptors.forEach(({ name }, index) => {\n                            copyFromChannel(inputBuffer, parameters, name, numberOfInputChannels + index, i);\n                        });\n                    }\n\n                    for (let j = 0; j < options.numberOfInputs; j += 1) {\n                        for (let k = 0; k < outputChannelCount[j]; k += 1) {\n                            // The byteLength will be 0 when the ArrayBuffer was transferred.\n                            if (outputs[j][k].byteLength === 0) {\n                                outputs[j][k] = new Float32Array(128);\n                            }\n                        }\n                    }\n\n                    try {\n                        const potentiallyEmptyInputs = inputs.map((input, index) => {\n                            const activeInput = activeInputs[index];\n\n                            if (activeInput.size > 0) {\n                                activeInputIndexes.set(index, bufferSize / 128);\n\n                                return input;\n                            }\n\n                            const count = activeInputIndexes.get(index);\n\n                            if (count === undefined) {\n                                return [];\n                            }\n\n                            if (input.every((channelData) => channelData.every((sample) => sample === 0))) {\n                                if (count === 1) {\n                                    activeInputIndexes.delete(index);\n                                } else {\n                                    activeInputIndexes.set(index, count - 1);\n                                }\n                            }\n\n                            return input;\n                        });\n\n                        const activeSourceFlag = exposeCurrentFrameAndCurrentTime(\n                            nativeContext.currentTime + i / nativeContext.sampleRate,\n                            nativeContext.sampleRate,\n                            () => (<IAudioWorkletProcessor>audioWorkletProcessor).process(potentiallyEmptyInputs, outputs, parameters)\n                        );\n\n                        isActive = activeSourceFlag;\n\n                        for (let j = 0, outputChannelSplitterNodeOutput = 0; j < options.numberOfOutputs; j += 1) {\n                            for (let k = 0; k < outputChannelCount[j]; k += 1) {\n                                copyToChannel(outputBuffer, outputs[j], k, outputChannelSplitterNodeOutput + k, i);\n                            }\n\n                            outputChannelSplitterNodeOutput += outputChannelCount[j];\n                        }\n                    } catch (error) {\n                        isActive = false;\n\n                        nativeAudioWorkletNodeFaker.dispatchEvent(\n                            new ErrorEvent('processorerror', {\n                                colno: error.colno,\n                                filename: error.filename,\n                                lineno: error.lineno,\n                                message: error.message\n                            })\n                        );\n                    }\n\n                    if (!isActive) {\n                        for (let j = 0; j < options.numberOfInputs; j += 1) {\n                            gainNodes[j].disconnect(inputChannelSplitterNodes[j]);\n\n                            for (let k = 0; k < options.channelCount; k += 1) {\n                                inputChannelSplitterNodes[i].disconnect(inputChannelMergerNode, k, j * options.channelCount + k);\n                            }\n                        }\n\n                        if (processorConstructor.parameterDescriptors !== undefined) {\n                            const length = processorConstructor.parameterDescriptors.length;\n\n                            for (let j = 0; j < length; j += 1) {\n                                const constantSourceNode = constantSourceNodes[j];\n\n                                constantSourceNode.disconnect(inputChannelMergerNode, 0, numberOfInputChannels + j);\n                                constantSourceNode.stop();\n                            }\n                        }\n\n                        inputChannelMergerNode.disconnect(scriptProcessorNode);\n\n                        scriptProcessorNode.onaudioprocess = null; // tslint:disable-line:deprecation\n\n                        if (isConnected) {\n                            disconnectOutputsGraph();\n                        } else {\n                            disconnectFakeGraph();\n                        }\n\n                        break;\n                    }\n                }\n            }\n        };\n\n        let isConnected = false;\n\n        // Bug #87: Only Firefox will fire an AudioProcessingEvent if there is no connected output.\n        const nativeGainNode = createNativeGainNode(nativeContext, {\n            channelCount: 1,\n            channelCountMode: 'explicit',\n            channelInterpretation: 'discrete',\n            gain: 0\n        });\n\n        const connectFakeGraph = () => scriptProcessorNode.connect(nativeGainNode).connect(nativeContext.destination);\n        const disconnectFakeGraph = () => {\n            scriptProcessorNode.disconnect(nativeGainNode);\n            nativeGainNode.disconnect();\n        };\n        const whenConnected = () => {\n            if (isActive) {\n                disconnectFakeGraph();\n\n                if (options.numberOfOutputs > 0) {\n                    scriptProcessorNode.connect(outputChannelSplitterNode);\n                }\n\n                for (let i = 0, outputChannelSplitterNodeOutput = 0; i < options.numberOfOutputs; i += 1) {\n                    const outputChannelMergerNode = outputChannelMergerNodes[i];\n\n                    for (let j = 0; j < outputChannelCount[i]; j += 1) {\n                        outputChannelSplitterNode.connect(outputChannelMergerNode, outputChannelSplitterNodeOutput + j, j);\n                    }\n\n                    outputChannelSplitterNodeOutput += outputChannelCount[i];\n                }\n            }\n\n            isConnected = true;\n        };\n        const whenDisconnected = () => {\n            if (isActive) {\n                connectFakeGraph();\n                disconnectOutputsGraph();\n            }\n\n            isConnected = false;\n        };\n\n        connectFakeGraph();\n\n        return monitorConnections(nativeAudioWorkletNodeFaker, whenConnected, whenDisconnected);\n    };\n};\n", "import { assignNativeAudioNodeAudioParamValue } from '../helpers/assign-native-audio-node-audio-param-value';\nimport { assignNativeAudioNodeOption } from '../helpers/assign-native-audio-node-option';\nimport { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nimport { TNativeBiquadFilterNodeFactory } from '../types';\n\nexport const createNativeBiquadFilterNode: TNativeBiquadFilterNodeFactory = (nativeContext, options) => {\n    const nativeBiquadFilterNode = nativeContext.createBiquadFilter();\n\n    assignNativeAudioNodeOptions(nativeBiquadFilterNode, options);\n\n    assignNativeAudioNodeAudioParamValue(nativeBiquadFilterNode, options, 'Q');\n    assignNativeAudioNodeAudioParamValue(nativeBiquadFilterNode, options, 'detune');\n    assignNativeAudioNodeAudioParamValue(nativeBiquadFilterNode, options, 'frequency');\n    assignNativeAudioNodeAudioParamValue(nativeBiquadFilterNode, options, 'gain');\n\n    assignNativeAudioNodeOption(nativeBiquadFilterNode, options, 'type');\n\n    return nativeBiquadFilterNode;\n};\n", "import { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nimport { TNativeChannelMergerNodeFactoryFactory } from '../types';\n\nexport const createNativeChannelMergerNodeFactory: TNativeChannelMergerNodeFactoryFactory = (\n    nativeAudioContextConstructor,\n    wrapChannelMergerNode\n) => {\n    return (nativeContext, options) => {\n        const nativeChannelMergerNode = nativeContext.createChannelMerger(options.numberOfInputs);\n\n        /*\n         * Bug #20: Safari requires a connection of any kind to treat the input signal correctly.\n         * @todo Unfortunately there is no way to test for this behavior in a synchronous fashion which is why testing for the existence of\n         * the webkitAudioContext is used as a workaround here.\n         */\n        if (nativeAudioContextConstructor !== null && nativeAudioContextConstructor.name === 'webkitAudioContext') {\n            wrapChannelMergerNode(nativeContext, nativeChannelMergerNode);\n        }\n\n        assignNativeAudioNodeOptions(nativeChannelMergerNode, options);\n\n        return nativeChannelMergerNode;\n    };\n};\n", "import { createInvalidStateError } from '../factories/invalid-state-error';\nimport { TNativeChannelSplitterNode } from '../types';\n\nexport const wrapChannelSplitterNode = (channelSplitterNode: TNativeChannelSplitterNode): void => {\n    const channelCount = channelSplitterNode.numberOfOutputs;\n\n    // Bug #97: Safari does not throw an error when attempting to change the channelCount to something other than its initial value.\n    Object.defineProperty(channelSplitterNode, 'channelCount', {\n        get: () => channelCount,\n        set: (value) => {\n            if (value !== channelCount) {\n                throw createInvalidStateError();\n            }\n        }\n    });\n\n    // Bug #30: Safari does not throw an error when attempting to change the channelCountMode to something other than explicit.\n    Object.defineProperty(channelSplitterNode, 'channelCountMode', {\n        get: () => 'explicit',\n        set: (value) => {\n            if (value !== 'explicit') {\n                throw createInvalidStateError();\n            }\n        }\n    });\n\n    // Bug #32: Safari does not throw an error when attempting to change the channelInterpretation to something other than discrete.\n    Object.defineProperty(channelSplitterNode, 'channelInterpretation', {\n        get: () => 'discrete',\n        set: (value) => {\n            if (value !== 'discrete') {\n                throw createInvalidStateError();\n            }\n        }\n    });\n};\n", "import { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nimport { wrapChannelSplitterNode } from '../helpers/wrap-channel-splitter-node';\nimport { TNativeChannelSplitterNodeFactory } from '../types';\n\nexport const createNativeChannelSplitterNode: TNativeChannelSplitterNodeFactory = (nativeContext, options) => {\n    const nativeChannelSplitterNode = nativeContext.createChannelSplitter(options.numberOfOutputs);\n\n    // Bug #96: Safari does not have the correct channelCount.\n    // Bug #29: Safari does not have the correct channelCountMode.\n    // Bug #31: Safari does not have the correct channelInterpretation.\n    assignNativeAudioNodeOptions(nativeChannelSplitterNode, options);\n\n    // Bug #29, #30, #31, #32, #96 & #97: Only Chrome, Edge & Firefox partially support the spec yet.\n    wrapChannelSplitterNode(nativeChannelSplitterNode);\n\n    return nativeChannelSplitterNode;\n};\n", "import { assignNativeAudioNodeAudioParamValue } from '../helpers/assign-native-audio-node-audio-param-value';\nimport { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nimport { wrapAudioScheduledSourceNodeStartMethodNegativeParameters } from '../helpers/wrap-audio-scheduled-source-node-start-method-negative-parameters';\nimport { wrapAudioScheduledSourceNodeStopMethodNegativeParameters } from '../helpers/wrap-audio-scheduled-source-node-stop-method-negative-parameters';\nimport { TNativeConstantSourceNodeFactoryFactory } from '../types';\n\nexport const createNativeConstantSourceNodeFactory: TNativeConstantSourceNodeFactoryFactory = (\n    addSilentConnection,\n    cacheTestResult,\n    createNativeConstantSourceNodeFaker,\n    testAudioScheduledSourceNodeStartMethodNegativeParametersSupport,\n    testAudioScheduledSourceNodeStopMethodNegativeParametersSupport\n) => {\n    return (nativeContext, options) => {\n        // Bug #62: Safari does not support ConstantSourceNodes.\n        if (nativeContext.createConstantSource === undefined) {\n            return createNativeConstantSourceNodeFaker(nativeContext, options);\n        }\n\n        const nativeConstantSourceNode = nativeContext.createConstantSource();\n\n        assignNativeAudioNodeOptions(nativeConstantSourceNode, options);\n\n        assignNativeAudioNodeAudioParamValue(nativeConstantSourceNode, options, 'offset');\n\n        // Bug #44: Safari does not throw a RangeError yet.\n        if (\n            !cacheTestResult(testAudioScheduledSourceNodeStartMethodNegativeParametersSupport, () =>\n                testAudioScheduledSourceNodeStartMethodNegativeParametersSupport(nativeContext)\n            )\n        ) {\n            wrapAudioScheduledSourceNodeStartMethodNegativeParameters(nativeConstantSourceNode);\n        }\n\n        // Bug #44: Only Firefox does not throw a RangeError yet.\n        if (\n            !cacheTestResult(testAudioScheduledSourceNodeStopMethodNegativeParametersSupport, () =>\n                testAudioScheduledSourceNodeStopMethodNegativeParametersSupport(nativeContext)\n            )\n        ) {\n            wrapAudioScheduledSourceNodeStopMethodNegativeParameters(nativeConstantSourceNode);\n        }\n\n        // Bug #175: Safari will not fire an ended event if the ConstantSourceNode is unconnected.\n        addSilentConnection(nativeContext, nativeConstantSourceNode);\n\n        return nativeConstantSourceNode;\n    };\n};\n", "import { TNativeAudioNode } from '../types';\n\nexport const interceptConnections = <T extends object>(\n    original: T,\n    interceptor: TNativeAudioNode\n): T & { connect: TNativeAudioNode['connect']; disconnect: TNativeAudioNode['disconnect'] } => {\n    (<T & { connect: TNativeAudioNode['connect'] }>original).connect = interceptor.connect.bind(interceptor);\n\n    (<T & { disconnect: TNativeAudioNode['disconnect'] }>original).disconnect = interceptor.disconnect.bind(interceptor);\n\n    return <T & { connect: TNativeAudioNode['connect']; disconnect: TNativeAudioNode['disconnect'] }>original;\n};\n", "import { interceptConnections } from '../helpers/intercept-connections';\nimport {\n    TNativeAudioBufferSourceNode,\n    TNativeAudioNode,\n    TNativeConstantSourceNode,\n    TNativeConstantSourceNodeFakerFactoryFactory\n} from '../types';\n\nexport const createNativeConstantSourceNodeFakerFactory: TNativeConstantSourceNodeFakerFactoryFactory = (\n    addSilentConnection,\n    createNativeAudioBufferSourceNode,\n    createNativeGainNode,\n    monitorConnections\n) => {\n    return (nativeContext, { offset, ...audioNodeOptions }) => {\n        const audioBuffer = nativeContext.createBuffer(1, 2, 44100);\n        const audioBufferSourceNode = createNativeAudioBufferSourceNode(nativeContext, {\n            buffer: null,\n            channelCount: 2,\n            channelCountMode: 'max',\n            channelInterpretation: 'speakers',\n            loop: false,\n            loopEnd: 0,\n            loopStart: 0,\n            playbackRate: 1\n        });\n        const gainNode = createNativeGainNode(nativeContext, { ...audioNodeOptions, gain: offset });\n\n        // Bug #5: Safari does not support copyFromChannel() and copyToChannel().\n        const channelData = audioBuffer.getChannelData(0);\n\n        // Bug #95: Safari does not play or loop one sample buffers.\n        channelData[0] = 1;\n        channelData[1] = 1;\n\n        audioBufferSourceNode.buffer = audioBuffer;\n        audioBufferSourceNode.loop = true;\n\n        const nativeConstantSourceNodeFaker = {\n            get bufferSize(): undefined {\n                return undefined;\n            },\n            get channelCount(): number {\n                return gainNode.channelCount;\n            },\n            set channelCount(value) {\n                gainNode.channelCount = value;\n            },\n            get channelCountMode(): TNativeConstantSourceNode['channelCountMode'] {\n                return gainNode.channelCountMode;\n            },\n            set channelCountMode(value) {\n                gainNode.channelCountMode = value;\n            },\n            get channelInterpretation(): TNativeConstantSourceNode['channelInterpretation'] {\n                return gainNode.channelInterpretation;\n            },\n            set channelInterpretation(value) {\n                gainNode.channelInterpretation = value;\n            },\n            get context(): TNativeConstantSourceNode['context'] {\n                return gainNode.context;\n            },\n            get inputs(): TNativeAudioNode[] {\n                return [];\n            },\n            get numberOfInputs(): number {\n                return audioBufferSourceNode.numberOfInputs;\n            },\n            get numberOfOutputs(): number {\n                return gainNode.numberOfOutputs;\n            },\n            get offset(): TNativeConstantSourceNode['offset'] {\n                return gainNode.gain;\n            },\n            get onended(): TNativeConstantSourceNode['onended'] {\n                return audioBufferSourceNode.onended;\n            },\n            set onended(value) {\n                audioBufferSourceNode.onended = <TNativeAudioBufferSourceNode['onended']>value;\n            },\n            addEventListener(...args: any[]): void {\n                return audioBufferSourceNode.addEventListener(args[0], args[1], args[2]);\n            },\n            dispatchEvent(...args: any[]): boolean {\n                return audioBufferSourceNode.dispatchEvent(args[0]);\n            },\n            removeEventListener(...args: any[]): void {\n                return audioBufferSourceNode.removeEventListener(args[0], args[1], args[2]);\n            },\n            start(when = 0): void {\n                audioBufferSourceNode.start.call(audioBufferSourceNode, when);\n            },\n            stop(when = 0): void {\n                audioBufferSourceNode.stop.call(audioBufferSourceNode, when);\n            }\n        };\n\n        const whenConnected = () => audioBufferSourceNode.connect(gainNode);\n        const whenDisconnected = () => audioBufferSourceNode.disconnect(gainNode);\n\n        // Bug #175: Safari will not fire an ended event if the AudioBufferSourceNode is unconnected.\n        addSilentConnection(nativeContext, audioBufferSourceNode);\n\n        return monitorConnections(interceptConnections(nativeConstantSourceNodeFaker, gainNode), whenConnected, whenDisconnected);\n    };\n};\n", "import { assignNativeAudioNodeOption } from '../helpers/assign-native-audio-node-option';\nimport { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nimport { TNativeConvolverNodeFactoryFactory } from '../types';\n\nexport const createNativeConvolverNodeFactory: TNativeConvolverNodeFactoryFactory = (createNotSupportedError, overwriteAccessors) => {\n    return (nativeContext, options) => {\n        const nativeConvolverNode = nativeContext.createConvolver();\n\n        assignNativeAudioNodeOptions(nativeConvolverNode, options);\n\n        // The normalize property needs to be set before setting the buffer.\n        if (options.disableNormalization === nativeConvolverNode.normalize) {\n            nativeConvolverNode.normalize = !options.disableNormalization;\n        }\n\n        assignNativeAudioNodeOption(nativeConvolverNode, options, 'buffer');\n\n        // Bug #113: Safari does allow to set the channelCount to a value larger than 2.\n        if (options.channelCount > 2) {\n            throw createNotSupportedError();\n        }\n\n        overwriteAccessors(\n            nativeConvolverNode,\n            'channelCount',\n            (get) => () => get.call(nativeConvolverNode),\n            (set) => (value) => {\n                if (value > 2) {\n                    throw createNotSupportedError();\n                }\n\n                return set.call(nativeConvolverNode, value);\n            }\n        );\n\n        // Bug #114: Safari allows to set the channelCountMode to 'max'.\n        if (options.channelCountMode === 'max') {\n            throw createNotSupportedError();\n        }\n\n        overwriteAccessors(\n            nativeConvolverNode,\n            'channelCountMode',\n            (get) => () => get.call(nativeConvolverNode),\n            (set) => (value) => {\n                if (value === 'max') {\n                    throw createNotSupportedError();\n                }\n\n                return set.call(nativeConvolverNode, value);\n            }\n        );\n\n        return nativeConvolverNode;\n    };\n};\n", "import { assignNativeAudioNodeAudioParamValue } from '../helpers/assign-native-audio-node-audio-param-value';\nimport { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nimport { TNativeDelayNodeFactory } from '../types';\n\nexport const createNativeDelayNode: TNativeDelayNodeFactory = (nativeContext, options) => {\n    const nativeDelayNode = nativeContext.createDelay(options.maxDelayTime);\n\n    assignNativeAudioNodeOptions(nativeDelayNode, options);\n\n    assignNativeAudioNodeAudioParamValue(nativeDelayNode, options, 'delayTime');\n\n    return nativeDelayNode;\n};\n", "import { assignNativeAudioNodeAudioParamValue } from '../helpers/assign-native-audio-node-audio-param-value';\nimport { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nimport { TNativeDynamicsCompressorNodeFactoryFactory } from '../types';\n\nexport const createNativeDynamicsCompressorNodeFactory: TNativeDynamicsCompressorNodeFactoryFactory = (createNotSupportedError) => {\n    return (nativeContext, options) => {\n        const nativeDynamicsCompressorNode = nativeContext.createDynamicsCompressor();\n\n        assignNativeAudioNodeOptions(nativeDynamicsCompressorNode, options);\n\n        // Bug #108: Safari allows a channelCount of three and above.\n        if (options.channelCount > 2) {\n            throw createNotSupportedError();\n        }\n\n        // Bug #109: Only Chrome and Firefox disallow a channelCountMode of 'max'.\n        if (options.channelCountMode === 'max') {\n            throw createNotSupportedError();\n        }\n\n        assignNativeAudioNodeAudioParamValue(nativeDynamicsCompressorNode, options, 'attack');\n        assignNativeAudioNodeAudioParamValue(nativeDynamicsCompressorNode, options, 'knee');\n        assignNativeAudioNodeAudioParamValue(nativeDynamicsCompressorNode, options, 'ratio');\n        assignNativeAudioNodeAudioParamValue(nativeDynamicsCompressorNode, options, 'release');\n        assignNativeAudioNodeAudioParamValue(nativeDynamicsCompressorNode, options, 'threshold');\n\n        return nativeDynamicsCompressorNode;\n    };\n};\n", "import { assignNativeAudioNodeAudioParamValue } from '../helpers/assign-native-audio-node-audio-param-value';\nimport { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nimport { TNativeGainNodeFactory } from '../types';\n\nexport const createNativeGainNode: TNativeGainNodeFactory = (nativeContext, options) => {\n    const nativeGainNode = nativeContext.createGain();\n\n    assignNativeAudioNodeOptions(nativeGainNode, options);\n\n    assignNativeAudioNodeAudioParamValue(nativeGainNode, options, 'gain');\n\n    return nativeGainNode;\n};\n", "import { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nimport { TNativeIIRFilterNodeFactoryFactory } from '../types';\n\nexport const createNativeIIRFilterNodeFactory: TNativeIIRFilterNodeFactoryFactory = (createNativeIIRFilterNodeFaker) => {\n    return (nativeContext, baseLatency, options) => {\n        // Bug #9: Safari does not support IIRFilterNodes.\n        if (nativeContext.createIIRFilter === undefined) {\n            return createNativeIIRFilterNodeFaker(nativeContext, baseLatency, options);\n        }\n\n        // @todo TypeScript defines the parameters of createIIRFilter() as arrays of numbers.\n        const nativeIIRFilterNode = nativeContext.createIIRFilter(<number[]>options.feedforward, <number[]>options.feedback);\n\n        assignNativeAudioNodeOptions(nativeIIRFilterNode, options);\n\n        return nativeIIRFilterNode;\n    };\n};\n", "import { computeBufferSize } from '../helpers/compute-buffer-size';\nimport { filterBuffer } from '../helpers/filter-buffer';\nimport { interceptConnections } from '../helpers/intercept-connections';\nimport { TNativeAudioNode, TNativeIIRFilterNode, TNativeIIRFilterNodeFakerFactoryFactory } from '../types';\n\nfunction divide(a: [number, number], b: [number, number]): [number, number] {\n    const denominator = b[0] * b[0] + b[1] * b[1];\n\n    return [(a[0] * b[0] + a[1] * b[1]) / denominator, (a[1] * b[0] - a[0] * b[1]) / denominator];\n}\n\nfunction multiply(a: [number, number], b: [number, number]): [number, number] {\n    return [a[0] * b[0] - a[1] * b[1], a[0] * b[1] + a[1] * b[0]];\n}\n\nfunction evaluatePolynomial(coefficient: Float64Array, z: [number, number]): [number, number] {\n    let result: [number, number] = [0, 0];\n\n    for (let i = coefficient.length - 1; i >= 0; i -= 1) {\n        result = multiply(result, z);\n\n        result[0] += coefficient[i];\n    }\n\n    return result;\n}\n\nexport const createNativeIIRFilterNodeFakerFactory: TNativeIIRFilterNodeFakerFactoryFactory = (\n    createInvalidAccessError,\n    createInvalidStateError,\n    createNativeScriptProcessorNode,\n    createNotSupportedError\n) => {\n    return (nativeContext, baseLatency, { channelCount, channelCountMode, channelInterpretation, feedback, feedforward }) => {\n        const bufferSize = computeBufferSize(baseLatency, nativeContext.sampleRate);\n        const convertedFeedback = feedback instanceof Float64Array ? feedback : new Float64Array(feedback);\n        const convertedFeedforward = feedforward instanceof Float64Array ? feedforward : new Float64Array(feedforward);\n        const feedbackLength = convertedFeedback.length;\n        const feedforwardLength = convertedFeedforward.length;\n        const minLength = Math.min(feedbackLength, feedforwardLength);\n\n        if (feedbackLength === 0 || feedbackLength > 20) {\n            throw createNotSupportedError();\n        }\n\n        if (convertedFeedback[0] === 0) {\n            throw createInvalidStateError();\n        }\n\n        if (feedforwardLength === 0 || feedforwardLength > 20) {\n            throw createNotSupportedError();\n        }\n\n        if (convertedFeedforward[0] === 0) {\n            throw createInvalidStateError();\n        }\n\n        if (convertedFeedback[0] !== 1) {\n            for (let i = 0; i < feedforwardLength; i += 1) {\n                convertedFeedforward[i] /= convertedFeedback[0];\n            }\n\n            for (let i = 1; i < feedbackLength; i += 1) {\n                convertedFeedback[i] /= convertedFeedback[0];\n            }\n        }\n\n        const scriptProcessorNode = createNativeScriptProcessorNode(nativeContext, bufferSize, channelCount, channelCount);\n\n        scriptProcessorNode.channelCount = channelCount;\n        scriptProcessorNode.channelCountMode = channelCountMode;\n        scriptProcessorNode.channelInterpretation = channelInterpretation;\n\n        const bufferLength = 32;\n        const bufferIndexes: number[] = [];\n        const xBuffers: Float32Array[] = [];\n        const yBuffers: Float32Array[] = [];\n\n        for (let i = 0; i < channelCount; i += 1) {\n            bufferIndexes.push(0);\n\n            const xBuffer = new Float32Array(bufferLength);\n            const yBuffer = new Float32Array(bufferLength);\n\n            xBuffer.fill(0);\n            yBuffer.fill(0);\n\n            xBuffers.push(xBuffer);\n            yBuffers.push(yBuffer);\n        }\n\n        // tslint:disable-next-line:deprecation\n        scriptProcessorNode.onaudioprocess = (event: AudioProcessingEvent) => {\n            const inputBuffer = event.inputBuffer;\n            const outputBuffer = event.outputBuffer;\n\n            const numberOfChannels = inputBuffer.numberOfChannels;\n\n            for (let i = 0; i < numberOfChannels; i += 1) {\n                const input = inputBuffer.getChannelData(i);\n                const output = outputBuffer.getChannelData(i);\n\n                bufferIndexes[i] = filterBuffer(\n                    convertedFeedback,\n                    feedbackLength,\n                    convertedFeedforward,\n                    feedforwardLength,\n                    minLength,\n                    xBuffers[i],\n                    yBuffers[i],\n                    bufferIndexes[i],\n                    bufferLength,\n                    input,\n                    output\n                );\n            }\n        };\n\n        const nyquist = nativeContext.sampleRate / 2;\n\n        const nativeIIRFilterNodeFaker = {\n            get bufferSize(): number {\n                return bufferSize;\n            },\n            get channelCount(): number {\n                return scriptProcessorNode.channelCount;\n            },\n            set channelCount(value) {\n                scriptProcessorNode.channelCount = value;\n            },\n            get channelCountMode(): TNativeIIRFilterNode['channelCountMode'] {\n                return scriptProcessorNode.channelCountMode;\n            },\n            set channelCountMode(value) {\n                scriptProcessorNode.channelCountMode = value;\n            },\n            get channelInterpretation(): TNativeIIRFilterNode['channelInterpretation'] {\n                return scriptProcessorNode.channelInterpretation;\n            },\n            set channelInterpretation(value) {\n                scriptProcessorNode.channelInterpretation = value;\n            },\n            get context(): TNativeIIRFilterNode['context'] {\n                return scriptProcessorNode.context;\n            },\n            get inputs(): TNativeAudioNode[] {\n                return [scriptProcessorNode];\n            },\n            get numberOfInputs(): number {\n                return scriptProcessorNode.numberOfInputs;\n            },\n            get numberOfOutputs(): number {\n                return scriptProcessorNode.numberOfOutputs;\n            },\n            addEventListener(...args: any[]): void {\n                // @todo Dissallow adding an audioprocess listener.\n                return scriptProcessorNode.addEventListener(args[0], args[1], args[2]);\n            },\n            dispatchEvent(...args: any[]): boolean {\n                return scriptProcessorNode.dispatchEvent(args[0]);\n            },\n            getFrequencyResponse(frequencyHz: Float32Array, magResponse: Float32Array, phaseResponse: Float32Array): void {\n                if (frequencyHz.length !== magResponse.length || magResponse.length !== phaseResponse.length) {\n                    throw createInvalidAccessError();\n                }\n\n                const length = frequencyHz.length;\n\n                for (let i = 0; i < length; i += 1) {\n                    const omega = -Math.PI * (frequencyHz[i] / nyquist);\n                    const z: [number, number] = [Math.cos(omega), Math.sin(omega)];\n                    const numerator = evaluatePolynomial(convertedFeedforward, z);\n                    const denominator = evaluatePolynomial(convertedFeedback, z);\n                    const response = divide(numerator, denominator);\n\n                    magResponse[i] = Math.sqrt(response[0] * response[0] + response[1] * response[1]);\n                    phaseResponse[i] = Math.atan2(response[1], response[0]);\n                }\n            },\n            removeEventListener(...args: any[]): void {\n                return scriptProcessorNode.removeEventListener(args[0], args[1], args[2]);\n            }\n        };\n\n        return interceptConnections(nativeIIRFilterNodeFaker, scriptProcessorNode);\n    };\n};\n", "import { TNativeMediaElementAudioSourceNodeFactory } from '../types';\n\nexport const createNativeMediaElementAudioSourceNode: TNativeMediaElementAudioSourceNodeFactory = (nativeAudioContext, options) => {\n    return nativeAudioContext.createMediaElementSource(options.mediaElement);\n};\n", "import { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nimport { TNativeMediaStreamAudioDestinationNodeFactory } from '../types';\n\nexport const createNativeMediaStreamAudioDestinationNode: TNativeMediaStreamAudioDestinationNodeFactory = (nativeAudioContext, options) => {\n    const nativeMediaStreamAudioDestinationNode = nativeAudioContext.createMediaStreamDestination();\n\n    assignNativeAudioNodeOptions(nativeMediaStreamAudioDestinationNode, options);\n\n    // Bug #174: Safari does expose a wrong numberOfOutputs.\n    if (nativeMediaStreamAudioDestinationNode.numberOfOutputs === 1) {\n        Object.defineProperty(nativeMediaStreamAudioDestinationNode, 'numberOfOutputs', { get: () => 0 });\n    }\n\n    return nativeMediaStreamAudioDestinationNode;\n};\n", "import { TNativeMediaStreamAudioSourceNodeFactory } from '../types';\n\nexport const createNativeMediaStreamAudioSourceNode: TNativeMediaStreamAudioSourceNodeFactory = (nativeAudioContext, { mediaStream }) => {\n    const audioStreamTracks = mediaStream.getAudioTracks();\n    /*\n     * Bug #151: Safari does not use the audio track as input anymore if it gets removed from the mediaStream after construction.\n     * Bug #159: Safari picks the first audio track if the MediaStream has more than one audio track.\n     */\n    audioStreamTracks.sort((a, b) => (a.id < b.id ? -1 : a.id > b.id ? 1 : 0));\n\n    const filteredAudioStreamTracks = audioStreamTracks.slice(0, 1);\n\n    const nativeMediaStreamAudioSourceNode = nativeAudioContext.createMediaStreamSource(new MediaStream(filteredAudioStreamTracks));\n\n    /*\n     * Bug #151 & #159: The given mediaStream gets reconstructed before it gets passed to the native node which is why the accessor needs\n     * to be overwritten as it would otherwise expose the reconstructed version.\n     */\n    Object.defineProperty(nativeMediaStreamAudioSourceNode, 'mediaStream', { value: mediaStream });\n\n    return nativeMediaStreamAudioSourceNode;\n};\n", "import { TNativeMediaStreamTrackAudioSourceNodeFactoryFactory } from '../types';\n\nexport const createNativeMediaStreamTrackAudioSourceNodeFactory: TNativeMediaStreamTrackAudioSourceNodeFactoryFactory = (\n    createInvalidStateError,\n    isNativeOfflineAudioContext\n) => {\n    return (nativeAudioContext, { mediaStreamTrack }) => {\n        // Bug #121: Only Firefox does yet support the MediaStreamTrackAudioSourceNode.\n        if (typeof nativeAudioContext.createMediaStreamTrackSource === 'function') {\n            return nativeAudioContext.createMediaStreamTrackSource(mediaStreamTrack);\n        }\n\n        const mediaStream = new MediaStream([mediaStreamTrack]);\n        const nativeMediaStreamAudioSourceNode = nativeAudioContext.createMediaStreamSource(mediaStream);\n\n        // Bug #120: Firefox does not throw an error if the mediaStream has no audio track.\n        if (mediaStreamTrack.kind !== 'audio') {\n            throw createInvalidStateError();\n        }\n\n        // Bug #172: Safari allows to create a MediaStreamAudioSourceNode with an OfflineAudioContext.\n        if (isNativeOfflineAudioContext(nativeAudioContext)) {\n            throw new TypeError();\n        }\n\n        return nativeMediaStreamAudioSourceNode;\n    };\n};\n", "import { TNativeOfflineAudioContextConstructorFactory } from '../types';\n\nexport const createNativeOfflineAudioContextConstructor: TNativeOfflineAudioContextConstructorFactory = (window) => {\n    if (window === null) {\n        return null;\n    }\n\n    if (window.hasOwnProperty('OfflineAudioContext')) {\n        return window.OfflineAudioContext;\n    }\n\n    return window.hasOwnProperty('webkitOfflineAudioContext') ? (<any>window).webkitOfflineAudioContext : null;\n};\n", "import { assignNativeAudioNodeAudioParamValue } from '../helpers/assign-native-audio-node-audio-param-value';\nimport { assignNativeAudioNodeOption } from '../helpers/assign-native-audio-node-option';\nimport { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nimport { wrapAudioScheduledSourceNodeStartMethodNegativeParameters } from '../helpers/wrap-audio-scheduled-source-node-start-method-negative-parameters';\nimport { wrapAudioScheduledSourceNodeStopMethodNegativeParameters } from '../helpers/wrap-audio-scheduled-source-node-stop-method-negative-parameters';\nimport { TNativeOscillatorNodeFactoryFactory } from '../types';\n\nexport const createNativeOscillatorNodeFactory: TNativeOscillatorNodeFactoryFactory = (\n    addSilentConnection,\n    cacheTestResult,\n    testAudioScheduledSourceNodeStartMethodNegativeParametersSupport,\n    testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport,\n    testAudioScheduledSourceNodeStopMethodNegativeParametersSupport,\n    wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls\n) => {\n    return (nativeContext, options) => {\n        const nativeOscillatorNode = nativeContext.createOscillator();\n\n        assignNativeAudioNodeOptions(nativeOscillatorNode, options);\n\n        assignNativeAudioNodeAudioParamValue(nativeOscillatorNode, options, 'detune');\n        assignNativeAudioNodeAudioParamValue(nativeOscillatorNode, options, 'frequency');\n\n        if (options.periodicWave !== undefined) {\n            nativeOscillatorNode.setPeriodicWave(options.periodicWave);\n        } else {\n            assignNativeAudioNodeOption(nativeOscillatorNode, options, 'type');\n        }\n\n        // Bug #44: Only Chrome & Edge throw a RangeError yet.\n        if (\n            !cacheTestResult(testAudioScheduledSourceNodeStartMethodNegativeParametersSupport, () =>\n                testAudioScheduledSourceNodeStartMethodNegativeParametersSupport(nativeContext)\n            )\n        ) {\n            wrapAudioScheduledSourceNodeStartMethodNegativeParameters(nativeOscillatorNode);\n        }\n\n        // Bug #19: Safari does not ignore calls to stop() of an already stopped AudioBufferSourceNode.\n        if (\n            !cacheTestResult(testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport, () =>\n                testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport(nativeContext)\n            )\n        ) {\n            wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls(nativeOscillatorNode, nativeContext);\n        }\n\n        // Bug #44: Only Firefox does not throw a RangeError yet.\n        if (\n            !cacheTestResult(testAudioScheduledSourceNodeStopMethodNegativeParametersSupport, () =>\n                testAudioScheduledSourceNodeStopMethodNegativeParametersSupport(nativeContext)\n            )\n        ) {\n            wrapAudioScheduledSourceNodeStopMethodNegativeParameters(nativeOscillatorNode);\n        }\n\n        // Bug #175: Safari will not fire an ended event if the OscillatorNode is unconnected.\n        addSilentConnection(nativeContext, nativeOscillatorNode);\n\n        return nativeOscillatorNode;\n    };\n};\n", "import { assignNativeAudioNodeAudioParamValue } from '../helpers/assign-native-audio-node-audio-param-value';\nimport { assignNativeAudioNodeOption } from '../helpers/assign-native-audio-node-option';\nimport { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nimport { TNativePannerNodeFactoryFactory } from '../types';\n\nexport const createNativePannerNodeFactory: TNativePannerNodeFactoryFactory = (createNativePannerNodeFaker) => {\n    return (nativeContext, options) => {\n        const nativePannerNode = nativeContext.createPanner();\n\n        // Bug #124: Safari does not support modifying the orientation and the position with AudioParams.\n        if (nativePannerNode.orientationX === undefined) {\n            return createNativePannerNodeFaker(nativeContext, options);\n        }\n\n        assignNativeAudioNodeOptions(nativePannerNode, options);\n\n        assignNativeAudioNodeAudioParamValue(nativePannerNode, options, 'orientationX');\n        assignNativeAudioNodeAudioParamValue(nativePannerNode, options, 'orientationY');\n        assignNativeAudioNodeAudioParamValue(nativePannerNode, options, 'orientationZ');\n        assignNativeAudioNodeAudioParamValue(nativePannerNode, options, 'positionX');\n        assignNativeAudioNodeAudioParamValue(nativePannerNode, options, 'positionY');\n        assignNativeAudioNodeAudioParamValue(nativePannerNode, options, 'positionZ');\n\n        assignNativeAudioNodeOption(nativePannerNode, options, 'coneInnerAngle');\n        assignNativeAudioNodeOption(nativePannerNode, options, 'coneOuterAngle');\n        assignNativeAudioNodeOption(nativePannerNode, options, 'coneOuterGain');\n        assignNativeAudioNodeOption(nativePannerNode, options, 'distanceModel');\n        assignNativeAudioNodeOption(nativePannerNode, options, 'maxDistance');\n        assignNativeAudioNodeOption(nativePannerNode, options, 'panningModel');\n        assignNativeAudioNodeOption(nativePannerNode, options, 'refDistance');\n        assignNativeAudioNodeOption(nativePannerNode, options, 'rolloffFactor');\n\n        return nativePannerNode;\n    };\n};\n", "import { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nimport { interceptConnections } from '../helpers/intercept-connections';\nimport { TNativeAudioNode, TNativePannerNode, TNativePannerNodeFakerFactoryFactory } from '../types';\n\nexport const createNativePannerNodeFakerFactory: TNativePannerNodeFakerFactoryFactory = (\n    connectNativeAudioNodeToNativeAudioNode,\n    createInvalidStateError,\n    createNativeChannelMergerNode,\n    createNativeGainNode,\n    createNativeScriptProcessorNode,\n    createNativeWaveShaperNode,\n    createNotSupportedError,\n    disconnectNativeAudioNodeFromNativeAudioNode,\n    getFirstSample,\n    monitorConnections\n) => {\n    return (\n        nativeContext,\n        {\n            coneInnerAngle,\n            coneOuterAngle,\n            coneOuterGain,\n            distanceModel,\n            maxDistance,\n            orientationX,\n            orientationY,\n            orientationZ,\n            panningModel,\n            positionX,\n            positionY,\n            positionZ,\n            refDistance,\n            rolloffFactor,\n            ...audioNodeOptions\n        }\n    ) => {\n        const pannerNode = nativeContext.createPanner();\n\n        // Bug #125: Safari does not throw an error yet.\n        if (audioNodeOptions.channelCount > 2) {\n            throw createNotSupportedError();\n        }\n\n        // Bug #126: Safari does not throw an error yet.\n        if (audioNodeOptions.channelCountMode === 'max') {\n            throw createNotSupportedError();\n        }\n\n        assignNativeAudioNodeOptions(pannerNode, audioNodeOptions);\n\n        const SINGLE_CHANNEL_OPTIONS = {\n            channelCount: 1,\n            channelCountMode: 'explicit',\n            channelInterpretation: 'discrete'\n        } as const;\n\n        const channelMergerNode = createNativeChannelMergerNode(nativeContext, {\n            ...SINGLE_CHANNEL_OPTIONS,\n            channelInterpretation: 'speakers',\n            numberOfInputs: 6\n        });\n        const inputGainNode = createNativeGainNode(nativeContext, { ...audioNodeOptions, gain: 1 });\n        const orientationXGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 1 });\n        const orientationYGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });\n        const orientationZGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });\n        const positionXGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });\n        const positionYGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });\n        const positionZGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });\n        const scriptProcessorNode = createNativeScriptProcessorNode(nativeContext, 256, 6, 1);\n        const waveShaperNode = createNativeWaveShaperNode(nativeContext, {\n            ...SINGLE_CHANNEL_OPTIONS,\n            curve: new Float32Array([1, 1]),\n            oversample: 'none'\n        });\n\n        let lastOrientation: [number, number, number] = [orientationX, orientationY, orientationZ];\n        let lastPosition: [number, number, number] = [positionX, positionY, positionZ];\n\n        const buffer = new Float32Array(1);\n\n        // tslint:disable-next-line:deprecation\n        scriptProcessorNode.onaudioprocess = ({ inputBuffer }) => {\n            const orientation: [number, number, number] = [\n                getFirstSample(inputBuffer, buffer, 0),\n                getFirstSample(inputBuffer, buffer, 1),\n                getFirstSample(inputBuffer, buffer, 2)\n            ];\n\n            if (orientation.some((value, index) => value !== lastOrientation[index])) {\n                pannerNode.setOrientation(...orientation); // tslint:disable-line:deprecation\n\n                lastOrientation = orientation;\n            }\n\n            const positon: [number, number, number] = [\n                getFirstSample(inputBuffer, buffer, 3),\n                getFirstSample(inputBuffer, buffer, 4),\n                getFirstSample(inputBuffer, buffer, 5)\n            ];\n\n            if (positon.some((value, index) => value !== lastPosition[index])) {\n                pannerNode.setPosition(...positon); // tslint:disable-line:deprecation\n\n                lastPosition = positon;\n            }\n        };\n\n        Object.defineProperty(orientationYGainNode.gain, 'defaultValue', { get: () => 0 });\n        Object.defineProperty(orientationZGainNode.gain, 'defaultValue', { get: () => 0 });\n        Object.defineProperty(positionXGainNode.gain, 'defaultValue', { get: () => 0 });\n        Object.defineProperty(positionYGainNode.gain, 'defaultValue', { get: () => 0 });\n        Object.defineProperty(positionZGainNode.gain, 'defaultValue', { get: () => 0 });\n\n        const nativePannerNodeFaker = {\n            get bufferSize(): undefined {\n                return undefined;\n            },\n            get channelCount(): number {\n                return pannerNode.channelCount;\n            },\n            set channelCount(value) {\n                // Bug #125: Safari does not throw an error yet.\n                if (value > 2) {\n                    throw createNotSupportedError();\n                }\n\n                inputGainNode.channelCount = value;\n                pannerNode.channelCount = value;\n            },\n            get channelCountMode(): TNativePannerNode['channelCountMode'] {\n                return pannerNode.channelCountMode;\n            },\n            set channelCountMode(value) {\n                // Bug #126: Safari does not throw an error yet.\n                if (value === 'max') {\n                    throw createNotSupportedError();\n                }\n\n                inputGainNode.channelCountMode = value;\n                pannerNode.channelCountMode = value;\n            },\n            get channelInterpretation(): TNativePannerNode['channelInterpretation'] {\n                return pannerNode.channelInterpretation;\n            },\n            set channelInterpretation(value) {\n                inputGainNode.channelInterpretation = value;\n                pannerNode.channelInterpretation = value;\n            },\n            get coneInnerAngle(): TNativePannerNode['coneInnerAngle'] {\n                return pannerNode.coneInnerAngle;\n            },\n            set coneInnerAngle(value) {\n                pannerNode.coneInnerAngle = value;\n            },\n            get coneOuterAngle(): TNativePannerNode['coneOuterAngle'] {\n                return pannerNode.coneOuterAngle;\n            },\n            set coneOuterAngle(value) {\n                pannerNode.coneOuterAngle = value;\n            },\n            get coneOuterGain(): TNativePannerNode['coneOuterGain'] {\n                return pannerNode.coneOuterGain;\n            },\n            set coneOuterGain(value) {\n                // Bug #127: Safari does not throw an InvalidStateError yet.\n                if (value < 0 || value > 1) {\n                    throw createInvalidStateError();\n                }\n\n                pannerNode.coneOuterGain = value;\n            },\n            get context(): TNativePannerNode['context'] {\n                return pannerNode.context;\n            },\n            get distanceModel(): TNativePannerNode['distanceModel'] {\n                return pannerNode.distanceModel;\n            },\n            set distanceModel(value) {\n                pannerNode.distanceModel = value;\n            },\n            get inputs(): TNativeAudioNode[] {\n                return [inputGainNode];\n            },\n            get maxDistance(): TNativePannerNode['maxDistance'] {\n                return pannerNode.maxDistance;\n            },\n            set maxDistance(value) {\n                // Bug #128: Safari does not throw an error yet.\n                if (value < 0) {\n                    throw new RangeError();\n                }\n\n                pannerNode.maxDistance = value;\n            },\n            get numberOfInputs(): number {\n                return pannerNode.numberOfInputs;\n            },\n            get numberOfOutputs(): number {\n                return pannerNode.numberOfOutputs;\n            },\n            get orientationX(): TNativePannerNode['orientationX'] {\n                return orientationXGainNode.gain;\n            },\n            get orientationY(): TNativePannerNode['orientationY'] {\n                return orientationYGainNode.gain;\n            },\n            get orientationZ(): TNativePannerNode['orientationZ'] {\n                return orientationZGainNode.gain;\n            },\n            get panningModel(): TNativePannerNode['panningModel'] {\n                return pannerNode.panningModel;\n            },\n            set panningModel(value) {\n                pannerNode.panningModel = value;\n            },\n            get positionX(): TNativePannerNode['positionX'] {\n                return positionXGainNode.gain;\n            },\n            get positionY(): TNativePannerNode['positionY'] {\n                return positionYGainNode.gain;\n            },\n            get positionZ(): TNativePannerNode['positionZ'] {\n                return positionZGainNode.gain;\n            },\n            get refDistance(): TNativePannerNode['refDistance'] {\n                return pannerNode.refDistance;\n            },\n            set refDistance(value) {\n                // Bug #129: Safari does not throw an error yet.\n                if (value < 0) {\n                    throw new RangeError();\n                }\n\n                pannerNode.refDistance = value;\n            },\n            get rolloffFactor(): TNativePannerNode['rolloffFactor'] {\n                return pannerNode.rolloffFactor;\n            },\n            set rolloffFactor(value) {\n                // Bug #130: Safari does not throw an error yet.\n                if (value < 0) {\n                    throw new RangeError();\n                }\n\n                pannerNode.rolloffFactor = value;\n            },\n            addEventListener(...args: any[]): void {\n                return inputGainNode.addEventListener(args[0], args[1], args[2]);\n            },\n            dispatchEvent(...args: any[]): boolean {\n                return inputGainNode.dispatchEvent(args[0]);\n            },\n            removeEventListener(...args: any[]): void {\n                return inputGainNode.removeEventListener(args[0], args[1], args[2]);\n            }\n        };\n\n        if (coneInnerAngle !== nativePannerNodeFaker.coneInnerAngle) {\n            nativePannerNodeFaker.coneInnerAngle = coneInnerAngle;\n        }\n\n        if (coneOuterAngle !== nativePannerNodeFaker.coneOuterAngle) {\n            nativePannerNodeFaker.coneOuterAngle = coneOuterAngle;\n        }\n\n        if (coneOuterGain !== nativePannerNodeFaker.coneOuterGain) {\n            nativePannerNodeFaker.coneOuterGain = coneOuterGain;\n        }\n\n        if (distanceModel !== nativePannerNodeFaker.distanceModel) {\n            nativePannerNodeFaker.distanceModel = distanceModel;\n        }\n\n        if (maxDistance !== nativePannerNodeFaker.maxDistance) {\n            nativePannerNodeFaker.maxDistance = maxDistance;\n        }\n\n        if (orientationX !== nativePannerNodeFaker.orientationX.value) {\n            nativePannerNodeFaker.orientationX.value = orientationX;\n        }\n\n        if (orientationY !== nativePannerNodeFaker.orientationY.value) {\n            nativePannerNodeFaker.orientationY.value = orientationY;\n        }\n\n        if (orientationZ !== nativePannerNodeFaker.orientationZ.value) {\n            nativePannerNodeFaker.orientationZ.value = orientationZ;\n        }\n\n        if (panningModel !== nativePannerNodeFaker.panningModel) {\n            nativePannerNodeFaker.panningModel = panningModel;\n        }\n\n        if (positionX !== nativePannerNodeFaker.positionX.value) {\n            nativePannerNodeFaker.positionX.value = positionX;\n        }\n\n        if (positionY !== nativePannerNodeFaker.positionY.value) {\n            nativePannerNodeFaker.positionY.value = positionY;\n        }\n\n        if (positionZ !== nativePannerNodeFaker.positionZ.value) {\n            nativePannerNodeFaker.positionZ.value = positionZ;\n        }\n\n        if (refDistance !== nativePannerNodeFaker.refDistance) {\n            nativePannerNodeFaker.refDistance = refDistance;\n        }\n\n        if (rolloffFactor !== nativePannerNodeFaker.rolloffFactor) {\n            nativePannerNodeFaker.rolloffFactor = rolloffFactor;\n        }\n\n        if (lastOrientation[0] !== 1 || lastOrientation[1] !== 0 || lastOrientation[2] !== 0) {\n            pannerNode.setOrientation(...lastOrientation); // tslint:disable-line:deprecation\n        }\n\n        if (lastPosition[0] !== 0 || lastPosition[1] !== 0 || lastPosition[2] !== 0) {\n            pannerNode.setPosition(...lastPosition); // tslint:disable-line:deprecation\n        }\n\n        const whenConnected = () => {\n            inputGainNode.connect(pannerNode);\n\n            // Bug #119: Safari does not fully support the WaveShaperNode.\n            connectNativeAudioNodeToNativeAudioNode(inputGainNode, waveShaperNode, 0, 0);\n\n            waveShaperNode.connect(orientationXGainNode).connect(channelMergerNode, 0, 0);\n            waveShaperNode.connect(orientationYGainNode).connect(channelMergerNode, 0, 1);\n            waveShaperNode.connect(orientationZGainNode).connect(channelMergerNode, 0, 2);\n            waveShaperNode.connect(positionXGainNode).connect(channelMergerNode, 0, 3);\n            waveShaperNode.connect(positionYGainNode).connect(channelMergerNode, 0, 4);\n            waveShaperNode.connect(positionZGainNode).connect(channelMergerNode, 0, 5);\n\n            channelMergerNode.connect(scriptProcessorNode).connect(nativeContext.destination);\n        };\n        const whenDisconnected = () => {\n            inputGainNode.disconnect(pannerNode);\n\n            // Bug #119: Safari does not fully support the WaveShaperNode.\n            disconnectNativeAudioNodeFromNativeAudioNode(inputGainNode, waveShaperNode, 0, 0);\n\n            waveShaperNode.disconnect(orientationXGainNode);\n            orientationXGainNode.disconnect(channelMergerNode);\n            waveShaperNode.disconnect(orientationYGainNode);\n            orientationYGainNode.disconnect(channelMergerNode);\n            waveShaperNode.disconnect(orientationZGainNode);\n            orientationZGainNode.disconnect(channelMergerNode);\n            waveShaperNode.disconnect(positionXGainNode);\n            positionXGainNode.disconnect(channelMergerNode);\n            waveShaperNode.disconnect(positionYGainNode);\n            positionYGainNode.disconnect(channelMergerNode);\n            waveShaperNode.disconnect(positionZGainNode);\n            positionZGainNode.disconnect(channelMergerNode);\n\n            channelMergerNode.disconnect(scriptProcessorNode);\n            scriptProcessorNode.disconnect(nativeContext.destination);\n        };\n\n        return monitorConnections(interceptConnections(nativePannerNodeFaker, pannerNode), whenConnected, whenDisconnected);\n    };\n};\n", "import { TNativePeriodicWaveFactoryFactory } from '../types';\n\nexport const createNativePeriodicWaveFactory: TNativePeriodicWaveFactoryFactory = (createIndexSizeError) => {\n    return (nativeContext, { disableNormalization, imag, real }) => {\n        // Bug #180: Safari does not allow to use ordinary arrays.\n        const convertedImag = imag instanceof Float32Array ? imag : new Float32Array(imag);\n        const convertedReal = real instanceof Float32Array ? real : new Float32Array(real);\n\n        const nativePeriodicWave = nativeContext.createPeriodicWave(convertedReal, convertedImag, { disableNormalization });\n\n        // Bug #181: Safari does not throw an IndexSizeError so far if the given arrays have less than two values.\n        if (Array.from(imag).length < 2) {\n            throw createIndexSizeError();\n        }\n\n        return nativePeriodicWave;\n    };\n};\n", "import { TNativeScriptProcessorNodeFactory } from '../types';\n\nexport const createNativeScriptProcessorNode: TNativeScriptProcessorNodeFactory = (\n    nativeContext,\n    bufferSize,\n    numberOfInputChannels,\n    numberOfOutputChannels\n) => {\n    return nativeContext.createScriptProcessor(bufferSize, numberOfInputChannels, numberOfOutputChannels); // tslint:disable-line deprecation\n};\n", "import { assignNativeAudioNodeAudioParamValue } from '../helpers/assign-native-audio-node-audio-param-value';\nimport { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nimport { TNativeStereoPannerNodeFactoryFactory } from '../types';\n\nexport const createNativeStereoPannerNodeFactory: TNativeStereoPannerNodeFactoryFactory = (\n    createNativeStereoPannerNodeFaker,\n    createNotSupportedError\n) => {\n    return (nativeContext, options) => {\n        const channelCountMode = options.channelCountMode;\n\n        /*\n         * Bug #105: The channelCountMode of 'clamped-max' should be supported. However it is not possible to write a polyfill for Safari\n         * which supports it and therefore it can't be supported at all.\n         */\n        if (channelCountMode === 'clamped-max') {\n            throw createNotSupportedError();\n        }\n\n        // Bug #105: Safari does not support the StereoPannerNode.\n        if (nativeContext.createStereoPanner === undefined) {\n            return createNativeStereoPannerNodeFaker(nativeContext, options);\n        }\n\n        const nativeStereoPannerNode = nativeContext.createStereoPanner();\n\n        assignNativeAudioNodeOptions(nativeStereoPannerNode, options);\n\n        assignNativeAudioNodeAudioParamValue(nativeStereoPannerNode, options, 'pan');\n\n        /*\n         * Bug #105: The channelCountMode of 'clamped-max' should be supported. However it is not possible to write a polyfill for Safari\n         * which supports it and therefore it can't be supported at all.\n         */\n        Object.defineProperty(nativeStereoPannerNode, 'channelCountMode', {\n            get: () => channelCountMode,\n            set: (value) => {\n                if (value !== channelCountMode) {\n                    throw createNotSupportedError();\n                }\n            }\n        });\n\n        return nativeStereoPannerNode;\n    };\n};\n", "import { interceptConnections } from '../helpers/intercept-connections';\nimport { INativeWaveShaperNodeFaker } from '../interfaces';\nimport {\n    TNativeAudioNode,\n    TNativeChannelMergerNode,\n    TNativeContext,\n    TNativeGainNode,\n    TNativeStereoPannerNode,\n    TNativeStereoPannerNodeFakerFactoryFactory\n} from '../types';\n\nexport const createNativeStereoPannerNodeFakerFactory: TNativeStereoPannerNodeFakerFactoryFactory = (\n    createNativeChannelMergerNode,\n    createNativeChannelSplitterNode,\n    createNativeGainNode,\n    createNativeWaveShaperNode,\n    createNotSupportedError,\n    monitorConnections\n) => {\n    // The curve has a size of 14bit plus 1 value to have an exact representation for zero. This value has been determined experimentally.\n    const CURVE_SIZE = 16385;\n    const DC_CURVE = new Float32Array([1, 1]);\n    const HALF_PI = Math.PI / 2;\n    const SINGLE_CHANNEL_OPTIONS = { channelCount: 1, channelCountMode: 'explicit', channelInterpretation: 'discrete' } as const;\n    const SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS = { ...SINGLE_CHANNEL_OPTIONS, oversample: 'none' } as const;\n\n    const buildInternalGraphForMono = (\n        nativeContext: TNativeContext,\n        inputGainNode: TNativeGainNode,\n        panGainNode: TNativeGainNode,\n        channelMergerNode: TNativeChannelMergerNode\n    ) => {\n        const leftWaveShaperCurve = new Float32Array(CURVE_SIZE);\n        const rightWaveShaperCurve = new Float32Array(CURVE_SIZE);\n\n        for (let i = 0; i < CURVE_SIZE; i += 1) {\n            const x = (i / (CURVE_SIZE - 1)) * HALF_PI;\n\n            leftWaveShaperCurve[i] = Math.cos(x);\n            rightWaveShaperCurve[i] = Math.sin(x);\n        }\n\n        const leftGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });\n        // Bug #119: Safari does not fully support the WaveShaperNode.\n        const leftWaveShaperNode = <INativeWaveShaperNodeFaker>(\n            createNativeWaveShaperNode(nativeContext, { ...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS, curve: leftWaveShaperCurve })\n        );\n        // Bug #119: Safari does not fully support the WaveShaperNode.\n        const panWaveShaperNode = <INativeWaveShaperNodeFaker>(\n            createNativeWaveShaperNode(nativeContext, { ...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS, curve: DC_CURVE })\n        );\n        const rightGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });\n        // Bug #119: Safari does not fully support the WaveShaperNode.\n        const rightWaveShaperNode = <INativeWaveShaperNodeFaker>(\n            createNativeWaveShaperNode(nativeContext, { ...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS, curve: rightWaveShaperCurve })\n        );\n\n        return {\n            connectGraph(): void {\n                inputGainNode.connect(leftGainNode);\n                inputGainNode.connect(panWaveShaperNode.inputs === undefined ? panWaveShaperNode : panWaveShaperNode.inputs[0]);\n                inputGainNode.connect(rightGainNode);\n\n                panWaveShaperNode.connect(panGainNode);\n\n                panGainNode.connect(leftWaveShaperNode.inputs === undefined ? leftWaveShaperNode : leftWaveShaperNode.inputs[0]);\n                panGainNode.connect(rightWaveShaperNode.inputs === undefined ? rightWaveShaperNode : rightWaveShaperNode.inputs[0]);\n\n                leftWaveShaperNode.connect(leftGainNode.gain);\n                rightWaveShaperNode.connect(rightGainNode.gain);\n\n                leftGainNode.connect(channelMergerNode, 0, 0);\n                rightGainNode.connect(channelMergerNode, 0, 1);\n            },\n            disconnectGraph(): void {\n                inputGainNode.disconnect(leftGainNode);\n                inputGainNode.disconnect(panWaveShaperNode.inputs === undefined ? panWaveShaperNode : panWaveShaperNode.inputs[0]);\n                inputGainNode.disconnect(rightGainNode);\n\n                panWaveShaperNode.disconnect(panGainNode);\n\n                panGainNode.disconnect(leftWaveShaperNode.inputs === undefined ? leftWaveShaperNode : leftWaveShaperNode.inputs[0]);\n                panGainNode.disconnect(rightWaveShaperNode.inputs === undefined ? rightWaveShaperNode : rightWaveShaperNode.inputs[0]);\n\n                leftWaveShaperNode.disconnect(leftGainNode.gain);\n                rightWaveShaperNode.disconnect(rightGainNode.gain);\n\n                leftGainNode.disconnect(channelMergerNode, 0, 0);\n                rightGainNode.disconnect(channelMergerNode, 0, 1);\n            }\n        };\n    };\n\n    const buildInternalGraphForStereo = (\n        nativeContext: TNativeContext,\n        inputGainNode: TNativeGainNode,\n        panGainNode: TNativeGainNode,\n        channelMergerNode: TNativeChannelMergerNode\n    ) => {\n        const leftInputForLeftOutputWaveShaperCurve = new Float32Array(CURVE_SIZE);\n        const leftInputForRightOutputWaveShaperCurve = new Float32Array(CURVE_SIZE);\n        const rightInputForLeftOutputWaveShaperCurve = new Float32Array(CURVE_SIZE);\n        const rightInputForRightOutputWaveShaperCurve = new Float32Array(CURVE_SIZE);\n\n        const centerIndex = Math.floor(CURVE_SIZE / 2);\n\n        for (let i = 0; i < CURVE_SIZE; i += 1) {\n            if (i > centerIndex) {\n                const x = ((i - centerIndex) / (CURVE_SIZE - 1 - centerIndex)) * HALF_PI;\n\n                leftInputForLeftOutputWaveShaperCurve[i] = Math.cos(x);\n                leftInputForRightOutputWaveShaperCurve[i] = Math.sin(x);\n                rightInputForLeftOutputWaveShaperCurve[i] = 0;\n                rightInputForRightOutputWaveShaperCurve[i] = 1;\n            } else {\n                const x = (i / (CURVE_SIZE - 1 - centerIndex)) * HALF_PI;\n\n                leftInputForLeftOutputWaveShaperCurve[i] = 1;\n                leftInputForRightOutputWaveShaperCurve[i] = 0;\n                rightInputForLeftOutputWaveShaperCurve[i] = Math.cos(x);\n                rightInputForRightOutputWaveShaperCurve[i] = Math.sin(x);\n            }\n        }\n\n        const channelSplitterNode = createNativeChannelSplitterNode(nativeContext, {\n            channelCount: 2,\n            channelCountMode: 'explicit',\n            channelInterpretation: 'discrete',\n            numberOfOutputs: 2\n        });\n        const leftInputForLeftOutputGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });\n        // Bug #119: Safari does not fully support the WaveShaperNode.\n        const leftInputForLeftOutputWaveShaperNode = <INativeWaveShaperNodeFaker>createNativeWaveShaperNode(nativeContext, {\n            ...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS,\n            curve: leftInputForLeftOutputWaveShaperCurve\n        });\n        const leftInputForRightOutputGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });\n        // Bug #119: Safari does not fully support the WaveShaperNode.\n        const leftInputForRightOutputWaveShaperNode = <INativeWaveShaperNodeFaker>createNativeWaveShaperNode(nativeContext, {\n            ...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS,\n            curve: leftInputForRightOutputWaveShaperCurve\n        });\n        // Bug #119: Safari does not fully support the WaveShaperNode.\n        const panWaveShaperNode = <INativeWaveShaperNodeFaker>(\n            createNativeWaveShaperNode(nativeContext, { ...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS, curve: DC_CURVE })\n        );\n        const rightInputForLeftOutputGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });\n        // Bug #119: Safari does not fully support the WaveShaperNode.\n        const rightInputForLeftOutputWaveShaperNode = <INativeWaveShaperNodeFaker>createNativeWaveShaperNode(nativeContext, {\n            ...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS,\n            curve: rightInputForLeftOutputWaveShaperCurve\n        });\n        const rightInputForRightOutputGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });\n        // Bug #119: Safari does not fully support the WaveShaperNode.\n        const rightInputForRightOutputWaveShaperNode = <INativeWaveShaperNodeFaker>createNativeWaveShaperNode(nativeContext, {\n            ...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS,\n            curve: rightInputForRightOutputWaveShaperCurve\n        });\n\n        return {\n            connectGraph(): void {\n                inputGainNode.connect(channelSplitterNode);\n                inputGainNode.connect(panWaveShaperNode.inputs === undefined ? panWaveShaperNode : panWaveShaperNode.inputs[0]);\n\n                channelSplitterNode.connect(leftInputForLeftOutputGainNode, 0);\n                channelSplitterNode.connect(leftInputForRightOutputGainNode, 0);\n                channelSplitterNode.connect(rightInputForLeftOutputGainNode, 1);\n                channelSplitterNode.connect(rightInputForRightOutputGainNode, 1);\n\n                panWaveShaperNode.connect(panGainNode);\n\n                panGainNode.connect(\n                    leftInputForLeftOutputWaveShaperNode.inputs === undefined\n                        ? leftInputForLeftOutputWaveShaperNode\n                        : leftInputForLeftOutputWaveShaperNode.inputs[0]\n                );\n                panGainNode.connect(\n                    leftInputForRightOutputWaveShaperNode.inputs === undefined\n                        ? leftInputForRightOutputWaveShaperNode\n                        : leftInputForRightOutputWaveShaperNode.inputs[0]\n                );\n                panGainNode.connect(\n                    rightInputForLeftOutputWaveShaperNode.inputs === undefined\n                        ? rightInputForLeftOutputWaveShaperNode\n                        : rightInputForLeftOutputWaveShaperNode.inputs[0]\n                );\n                panGainNode.connect(\n                    rightInputForRightOutputWaveShaperNode.inputs === undefined\n                        ? rightInputForRightOutputWaveShaperNode\n                        : rightInputForRightOutputWaveShaperNode.inputs[0]\n                );\n\n                leftInputForLeftOutputWaveShaperNode.connect(leftInputForLeftOutputGainNode.gain);\n                leftInputForRightOutputWaveShaperNode.connect(leftInputForRightOutputGainNode.gain);\n                rightInputForLeftOutputWaveShaperNode.connect(rightInputForLeftOutputGainNode.gain);\n                rightInputForRightOutputWaveShaperNode.connect(rightInputForRightOutputGainNode.gain);\n\n                leftInputForLeftOutputGainNode.connect(channelMergerNode, 0, 0);\n                rightInputForLeftOutputGainNode.connect(channelMergerNode, 0, 0);\n\n                leftInputForRightOutputGainNode.connect(channelMergerNode, 0, 1);\n                rightInputForRightOutputGainNode.connect(channelMergerNode, 0, 1);\n            },\n            disconnectGraph(): void {\n                inputGainNode.disconnect(channelSplitterNode);\n                inputGainNode.disconnect(panWaveShaperNode.inputs === undefined ? panWaveShaperNode : panWaveShaperNode.inputs[0]);\n\n                channelSplitterNode.disconnect(leftInputForLeftOutputGainNode, 0);\n                channelSplitterNode.disconnect(leftInputForRightOutputGainNode, 0);\n                channelSplitterNode.disconnect(rightInputForLeftOutputGainNode, 1);\n                channelSplitterNode.disconnect(rightInputForRightOutputGainNode, 1);\n\n                panWaveShaperNode.disconnect(panGainNode);\n\n                panGainNode.disconnect(\n                    leftInputForLeftOutputWaveShaperNode.inputs === undefined\n                        ? leftInputForLeftOutputWaveShaperNode\n                        : leftInputForLeftOutputWaveShaperNode.inputs[0]\n                );\n                panGainNode.disconnect(\n                    leftInputForRightOutputWaveShaperNode.inputs === undefined\n                        ? leftInputForRightOutputWaveShaperNode\n                        : leftInputForRightOutputWaveShaperNode.inputs[0]\n                );\n                panGainNode.disconnect(\n                    rightInputForLeftOutputWaveShaperNode.inputs === undefined\n                        ? rightInputForLeftOutputWaveShaperNode\n                        : rightInputForLeftOutputWaveShaperNode.inputs[0]\n                );\n                panGainNode.disconnect(\n                    rightInputForRightOutputWaveShaperNode.inputs === undefined\n                        ? rightInputForRightOutputWaveShaperNode\n                        : rightInputForRightOutputWaveShaperNode.inputs[0]\n                );\n\n                leftInputForLeftOutputWaveShaperNode.disconnect(leftInputForLeftOutputGainNode.gain);\n                leftInputForRightOutputWaveShaperNode.disconnect(leftInputForRightOutputGainNode.gain);\n                rightInputForLeftOutputWaveShaperNode.disconnect(rightInputForLeftOutputGainNode.gain);\n                rightInputForRightOutputWaveShaperNode.disconnect(rightInputForRightOutputGainNode.gain);\n\n                leftInputForLeftOutputGainNode.disconnect(channelMergerNode, 0, 0);\n                rightInputForLeftOutputGainNode.disconnect(channelMergerNode, 0, 0);\n\n                leftInputForRightOutputGainNode.disconnect(channelMergerNode, 0, 1);\n                rightInputForRightOutputGainNode.disconnect(channelMergerNode, 0, 1);\n            }\n        };\n    };\n\n    const buildInternalGraph = (\n        nativeContext: TNativeContext,\n        channelCount: number,\n        inputGainNode: TNativeGainNode,\n        panGainNode: TNativeGainNode,\n        channelMergerNode: TNativeChannelMergerNode\n    ) => {\n        if (channelCount === 1) {\n            return buildInternalGraphForMono(nativeContext, inputGainNode, panGainNode, channelMergerNode);\n        }\n\n        if (channelCount === 2) {\n            return buildInternalGraphForStereo(nativeContext, inputGainNode, panGainNode, channelMergerNode);\n        }\n\n        throw createNotSupportedError();\n    };\n\n    return (nativeContext, { channelCount, channelCountMode, pan, ...audioNodeOptions }) => {\n        if (channelCountMode === 'max') {\n            throw createNotSupportedError();\n        }\n\n        const channelMergerNode = createNativeChannelMergerNode(nativeContext, {\n            ...audioNodeOptions,\n            channelCount: 1,\n            channelCountMode,\n            numberOfInputs: 2\n        });\n        const inputGainNode = createNativeGainNode(nativeContext, { ...audioNodeOptions, channelCount, channelCountMode, gain: 1 });\n        const panGainNode = createNativeGainNode(nativeContext, {\n            channelCount: 1,\n            channelCountMode: 'explicit',\n            channelInterpretation: 'discrete',\n            gain: pan\n        });\n\n        let { connectGraph, disconnectGraph } = buildInternalGraph(\n            nativeContext,\n            channelCount,\n            inputGainNode,\n            panGainNode,\n            channelMergerNode\n        );\n\n        Object.defineProperty(panGainNode.gain, 'defaultValue', { get: () => 0 });\n        Object.defineProperty(panGainNode.gain, 'maxValue', { get: () => 1 });\n        Object.defineProperty(panGainNode.gain, 'minValue', { get: () => -1 });\n\n        const nativeStereoPannerNodeFakerFactory = {\n            get bufferSize(): undefined {\n                return undefined;\n            },\n            get channelCount(): number {\n                return inputGainNode.channelCount;\n            },\n            set channelCount(value) {\n                if (inputGainNode.channelCount !== value) {\n                    if (isConnected) {\n                        disconnectGraph();\n                    }\n\n                    ({ connectGraph, disconnectGraph } = buildInternalGraph(\n                        nativeContext,\n                        value,\n                        inputGainNode,\n                        panGainNode,\n                        channelMergerNode\n                    ));\n\n                    if (isConnected) {\n                        connectGraph();\n                    }\n                }\n\n                inputGainNode.channelCount = value;\n            },\n            get channelCountMode(): TNativeStereoPannerNode['channelCountMode'] {\n                return inputGainNode.channelCountMode;\n            },\n            set channelCountMode(value) {\n                if (value === 'clamped-max' || value === 'max') {\n                    throw createNotSupportedError();\n                }\n\n                inputGainNode.channelCountMode = value;\n            },\n            get channelInterpretation(): TNativeStereoPannerNode['channelInterpretation'] {\n                return inputGainNode.channelInterpretation;\n            },\n            set channelInterpretation(value) {\n                inputGainNode.channelInterpretation = value;\n            },\n            get context(): TNativeStereoPannerNode['context'] {\n                return inputGainNode.context;\n            },\n            get inputs(): TNativeAudioNode[] {\n                return [inputGainNode];\n            },\n            get numberOfInputs(): number {\n                return inputGainNode.numberOfInputs;\n            },\n            get numberOfOutputs(): number {\n                return inputGainNode.numberOfOutputs;\n            },\n            get pan(): TNativeStereoPannerNode['pan'] {\n                return panGainNode.gain;\n            },\n            addEventListener(...args: any[]): void {\n                return inputGainNode.addEventListener(args[0], args[1], args[2]);\n            },\n            dispatchEvent(...args: any[]): boolean {\n                return inputGainNode.dispatchEvent(args[0]);\n            },\n            removeEventListener(...args: any[]): void {\n                return inputGainNode.removeEventListener(args[0], args[1], args[2]);\n            }\n        };\n\n        let isConnected = false;\n\n        const whenConnected = () => {\n            connectGraph();\n\n            isConnected = true;\n        };\n        const whenDisconnected = () => {\n            disconnectGraph();\n\n            isConnected = false;\n        };\n\n        return monitorConnections(\n            interceptConnections(nativeStereoPannerNodeFakerFactory, channelMergerNode),\n            whenConnected,\n            whenDisconnected\n        );\n    };\n};\n", "import { assignNativeAudioNodeOption } from '../helpers/assign-native-audio-node-option';\nimport { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nimport { TNativeWaveShaperNodeFactoryFactory } from '../types';\n\nexport const createNativeWaveShaperNodeFactory: TNativeWaveShaperNodeFactoryFactory = (\n    createConnectedNativeAudioBufferSourceNode,\n    createInvalidStateError,\n    createNativeWaveShaperNodeFaker,\n    isDCCurve,\n    monitorConnections,\n    nativeAudioContextConstructor,\n    overwriteAccessors\n) => {\n    return (nativeContext, options) => {\n        const nativeWaveShaperNode = nativeContext.createWaveShaper();\n\n        /*\n         * Bug #119: Safari does not correctly map the values.\n         * @todo Unfortunately there is no way to test for this behavior in a synchronous fashion which is why testing for the existence of\n         * the webkitAudioContext is used as a workaround here. Testing for the automationRate property is necessary because this workaround\n         * isn't necessary anymore since v14.0.2 of Safari.\n         */\n        if (\n            nativeAudioContextConstructor !== null &&\n            nativeAudioContextConstructor.name === 'webkitAudioContext' &&\n            nativeContext.createGain().gain.automationRate === undefined\n        ) {\n            return createNativeWaveShaperNodeFaker(nativeContext, options);\n        }\n\n        assignNativeAudioNodeOptions(nativeWaveShaperNode, options);\n\n        const curve = options.curve === null || options.curve instanceof Float32Array ? options.curve : new Float32Array(options.curve);\n\n        // Bug #104: Chrome and Edge will throw an InvalidAccessError when the curve has less than two samples.\n        if (curve !== null && curve.length < 2) {\n            throw createInvalidStateError();\n        }\n\n        // Only values of type Float32Array can be assigned to the curve property.\n        assignNativeAudioNodeOption(nativeWaveShaperNode, { curve }, 'curve');\n        assignNativeAudioNodeOption(nativeWaveShaperNode, options, 'oversample');\n\n        let disconnectNativeAudioBufferSourceNode: null | (() => void) = null;\n        let isConnected = false;\n\n        overwriteAccessors(\n            nativeWaveShaperNode,\n            'curve',\n            (get) => () => get.call(nativeWaveShaperNode),\n            (set) => (value) => {\n                set.call(nativeWaveShaperNode, value);\n\n                if (isConnected) {\n                    if (isDCCurve(value) && disconnectNativeAudioBufferSourceNode === null) {\n                        disconnectNativeAudioBufferSourceNode = createConnectedNativeAudioBufferSourceNode(\n                            nativeContext,\n                            nativeWaveShaperNode\n                        );\n                    } else if (!isDCCurve(value) && disconnectNativeAudioBufferSourceNode !== null) {\n                        disconnectNativeAudioBufferSourceNode();\n                        disconnectNativeAudioBufferSourceNode = null;\n                    }\n                }\n\n                return value;\n            }\n        );\n\n        const whenConnected = () => {\n            isConnected = true;\n\n            if (isDCCurve(nativeWaveShaperNode.curve)) {\n                disconnectNativeAudioBufferSourceNode = createConnectedNativeAudioBufferSourceNode(nativeContext, nativeWaveShaperNode);\n            }\n        };\n        const whenDisconnected = () => {\n            isConnected = false;\n\n            if (disconnectNativeAudioBufferSourceNode !== null) {\n                disconnectNativeAudioBufferSourceNode();\n                disconnectNativeAudioBufferSourceNode = null;\n            }\n        };\n\n        return monitorConnections(nativeWaveShaperNode, whenConnected, whenDisconnected);\n    };\n};\n", "import { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nimport { interceptConnections } from '../helpers/intercept-connections';\nimport { TNativeAudioNode, TNativeWaveShaperNode, TNativeWaveShaperNodeFakerFactoryFactory } from '../types';\n\nexport const createNativeWaveShaperNodeFakerFactory: TNativeWaveShaperNodeFakerFactoryFactory = (\n    createConnectedNativeAudioBufferSourceNode,\n    createInvalidStateError,\n    createNativeGainNode,\n    isDCCurve,\n    monitorConnections\n) => {\n    return (nativeContext, { curve, oversample, ...audioNodeOptions }) => {\n        const negativeWaveShaperNode = nativeContext.createWaveShaper();\n        const positiveWaveShaperNode = nativeContext.createWaveShaper();\n\n        assignNativeAudioNodeOptions(negativeWaveShaperNode, audioNodeOptions);\n        assignNativeAudioNodeOptions(positiveWaveShaperNode, audioNodeOptions);\n\n        const inputGainNode = createNativeGainNode(nativeContext, { ...audioNodeOptions, gain: 1 });\n        const invertGainNode = createNativeGainNode(nativeContext, { ...audioNodeOptions, gain: -1 });\n        const outputGainNode = createNativeGainNode(nativeContext, { ...audioNodeOptions, gain: 1 });\n        const revertGainNode = createNativeGainNode(nativeContext, { ...audioNodeOptions, gain: -1 });\n\n        let disconnectNativeAudioBufferSourceNode: null | (() => void) = null;\n        let isConnected = false;\n        let unmodifiedCurve: null | TNativeWaveShaperNode['curve'] = null;\n\n        const nativeWaveShaperNodeFaker = {\n            get bufferSize(): undefined {\n                return undefined;\n            },\n            get channelCount(): number {\n                return negativeWaveShaperNode.channelCount;\n            },\n            set channelCount(value) {\n                inputGainNode.channelCount = value;\n                invertGainNode.channelCount = value;\n                negativeWaveShaperNode.channelCount = value;\n                outputGainNode.channelCount = value;\n                positiveWaveShaperNode.channelCount = value;\n                revertGainNode.channelCount = value;\n            },\n            get channelCountMode(): TNativeWaveShaperNode['channelCountMode'] {\n                return negativeWaveShaperNode.channelCountMode;\n            },\n            set channelCountMode(value) {\n                inputGainNode.channelCountMode = value;\n                invertGainNode.channelCountMode = value;\n                negativeWaveShaperNode.channelCountMode = value;\n                outputGainNode.channelCountMode = value;\n                positiveWaveShaperNode.channelCountMode = value;\n                revertGainNode.channelCountMode = value;\n            },\n            get channelInterpretation(): TNativeWaveShaperNode['channelInterpretation'] {\n                return negativeWaveShaperNode.channelInterpretation;\n            },\n            set channelInterpretation(value) {\n                inputGainNode.channelInterpretation = value;\n                invertGainNode.channelInterpretation = value;\n                negativeWaveShaperNode.channelInterpretation = value;\n                outputGainNode.channelInterpretation = value;\n                positiveWaveShaperNode.channelInterpretation = value;\n                revertGainNode.channelInterpretation = value;\n            },\n            get context(): TNativeWaveShaperNode['context'] {\n                return negativeWaveShaperNode.context;\n            },\n            get curve(): TNativeWaveShaperNode['curve'] {\n                return unmodifiedCurve;\n            },\n            set curve(value) {\n                // Bug #102: Safari does not throw an InvalidStateError when the curve has less than two samples.\n                if (value !== null && value.length < 2) {\n                    throw createInvalidStateError();\n                }\n\n                if (value === null) {\n                    negativeWaveShaperNode.curve = value;\n                    positiveWaveShaperNode.curve = value;\n                } else {\n                    const curveLength = value.length;\n\n                    const negativeCurve = new Float32Array(curveLength + 2 - (curveLength % 2));\n                    const positiveCurve = new Float32Array(curveLength + 2 - (curveLength % 2));\n\n                    negativeCurve[0] = value[0];\n                    positiveCurve[0] = -value[curveLength - 1];\n\n                    const length = Math.ceil((curveLength + 1) / 2);\n                    const centerIndex = (curveLength + 1) / 2 - 1;\n\n                    for (let i = 1; i < length; i += 1) {\n                        const theoreticIndex = (i / length) * centerIndex;\n\n                        const lowerIndex = Math.floor(theoreticIndex);\n                        const upperIndex = Math.ceil(theoreticIndex);\n\n                        negativeCurve[i] =\n                            lowerIndex === upperIndex\n                                ? value[lowerIndex]\n                                : (1 - (theoreticIndex - lowerIndex)) * value[lowerIndex] +\n                                  (1 - (upperIndex - theoreticIndex)) * value[upperIndex];\n                        positiveCurve[i] =\n                            lowerIndex === upperIndex\n                                ? -value[curveLength - 1 - lowerIndex]\n                                : -((1 - (theoreticIndex - lowerIndex)) * value[curveLength - 1 - lowerIndex]) -\n                                  (1 - (upperIndex - theoreticIndex)) * value[curveLength - 1 - upperIndex];\n                    }\n\n                    negativeCurve[length] = curveLength % 2 === 1 ? value[length - 1] : (value[length - 2] + value[length - 1]) / 2;\n\n                    negativeWaveShaperNode.curve = negativeCurve;\n                    positiveWaveShaperNode.curve = positiveCurve;\n                }\n\n                unmodifiedCurve = value;\n\n                if (isConnected) {\n                    if (isDCCurve(unmodifiedCurve) && disconnectNativeAudioBufferSourceNode === null) {\n                        disconnectNativeAudioBufferSourceNode = createConnectedNativeAudioBufferSourceNode(nativeContext, inputGainNode);\n                    } else if (disconnectNativeAudioBufferSourceNode !== null) {\n                        disconnectNativeAudioBufferSourceNode();\n                        disconnectNativeAudioBufferSourceNode = null;\n                    }\n                }\n            },\n            get inputs(): TNativeAudioNode[] {\n                return [inputGainNode];\n            },\n            get numberOfInputs(): number {\n                return negativeWaveShaperNode.numberOfInputs;\n            },\n            get numberOfOutputs(): number {\n                return negativeWaveShaperNode.numberOfOutputs;\n            },\n            get oversample(): TNativeWaveShaperNode['oversample'] {\n                return negativeWaveShaperNode.oversample;\n            },\n            set oversample(value) {\n                negativeWaveShaperNode.oversample = value;\n                positiveWaveShaperNode.oversample = value;\n            },\n            addEventListener(...args: any[]): void {\n                return inputGainNode.addEventListener(args[0], args[1], args[2]);\n            },\n            dispatchEvent(...args: any[]): boolean {\n                return inputGainNode.dispatchEvent(args[0]);\n            },\n            removeEventListener(...args: any[]): void {\n                return inputGainNode.removeEventListener(args[0], args[1], args[2]);\n            }\n        };\n\n        if (curve !== null) {\n            // Only values of type Float32Array can be assigned to the curve property.\n            nativeWaveShaperNodeFaker.curve = curve instanceof Float32Array ? curve : new Float32Array(curve);\n        }\n\n        if (oversample !== nativeWaveShaperNodeFaker.oversample) {\n            nativeWaveShaperNodeFaker.oversample = oversample;\n        }\n\n        const whenConnected = () => {\n            inputGainNode.connect(negativeWaveShaperNode).connect(outputGainNode);\n\n            inputGainNode.connect(invertGainNode).connect(positiveWaveShaperNode).connect(revertGainNode).connect(outputGainNode);\n\n            isConnected = true;\n\n            if (isDCCurve(unmodifiedCurve)) {\n                disconnectNativeAudioBufferSourceNode = createConnectedNativeAudioBufferSourceNode(nativeContext, inputGainNode);\n            }\n        };\n        const whenDisconnected = () => {\n            inputGainNode.disconnect(negativeWaveShaperNode);\n            negativeWaveShaperNode.disconnect(outputGainNode);\n\n            inputGainNode.disconnect(invertGainNode);\n            invertGainNode.disconnect(positiveWaveShaperNode);\n            positiveWaveShaperNode.disconnect(revertGainNode);\n            revertGainNode.disconnect(outputGainNode);\n\n            isConnected = false;\n\n            if (disconnectNativeAudioBufferSourceNode !== null) {\n                disconnectNativeAudioBufferSourceNode();\n                disconnectNativeAudioBufferSourceNode = null;\n            }\n        };\n\n        return monitorConnections(interceptConnections(nativeWaveShaperNodeFaker, outputGainNode), whenConnected, whenDisconnected);\n    };\n};\n", "import { TNotSupportedErrorFactory } from '../types';\n\nexport const createNotSupportedError: TNotSupportedErrorFactory = () => new DOMException('', 'NotSupportedError');\n", "import { deactivateAudioGraph } from '../helpers/deactivate-audio-graph';\nimport { testPromiseSupport } from '../helpers/test-promise-support';\nimport { IAudioBuffer, IOfflineAudioContext, IOfflineAudioContextOptions } from '../interfaces';\nimport { TAudioContextState, TNativeOfflineAudioContext, TOfflineAudioContextConstructorFactory } from '../types';\n\nconst DEFAULT_OPTIONS = {\n    numberOfChannels: 1\n} as const;\n\nexport const createOfflineAudioContextConstructor: TOfflineAudioContextConstructorFactory = (\n    baseAudioContextConstructor,\n    cacheTestResult,\n    createInvalidStateError,\n    createNativeOfflineAudioContext,\n    startRendering\n) => {\n    return class OfflineAudioContext extends baseAudioContextConstructor<IOfflineAudioContext> implements IOfflineAudioContext {\n        private _length: number;\n\n        private _nativeOfflineAudioContext: TNativeOfflineAudioContext;\n\n        private _state: null | TAudioContextState;\n\n        constructor(options: IOfflineAudioContextOptions);\n        constructor(numberOfChannels: number, length: number, sampleRate: number);\n        constructor(a: number | IOfflineAudioContextOptions, b?: number, c?: number) {\n            let options: IOfflineAudioContextOptions;\n\n            if (typeof a === 'number' && b !== undefined && c !== undefined) {\n                options = { length: b, numberOfChannels: a, sampleRate: c };\n            } else if (typeof a === 'object') {\n                options = a;\n            } else {\n                throw new Error('The given parameters are not valid.');\n            }\n\n            const { length, numberOfChannels, sampleRate } = { ...DEFAULT_OPTIONS, ...options };\n\n            const nativeOfflineAudioContext = createNativeOfflineAudioContext(numberOfChannels, length, sampleRate);\n\n            // #21 Safari does not support promises and therefore would fire the statechange event before the promise can be resolved.\n            if (!cacheTestResult(testPromiseSupport, () => testPromiseSupport(nativeOfflineAudioContext))) {\n                nativeOfflineAudioContext.addEventListener(\n                    'statechange',\n                    (() => {\n                        let i = 0;\n\n                        const delayStateChangeEvent = (event: Event) => {\n                            if (this._state === 'running') {\n                                if (i > 0) {\n                                    nativeOfflineAudioContext.removeEventListener('statechange', delayStateChangeEvent);\n                                    event.stopImmediatePropagation();\n\n                                    this._waitForThePromiseToSettle(event);\n                                } else {\n                                    i += 1;\n                                }\n                            }\n                        };\n\n                        return delayStateChangeEvent;\n                    })()\n                );\n            }\n\n            super(nativeOfflineAudioContext, numberOfChannels);\n\n            this._length = length;\n            this._nativeOfflineAudioContext = nativeOfflineAudioContext;\n            this._state = null;\n        }\n\n        get length(): number {\n            // Bug #17: Safari does not yet expose the length.\n            if (this._nativeOfflineAudioContext.length === undefined) {\n                return this._length;\n            }\n\n            return this._nativeOfflineAudioContext.length;\n        }\n\n        get state(): TAudioContextState {\n            return this._state === null ? this._nativeOfflineAudioContext.state : this._state;\n        }\n\n        public startRendering(): Promise<IAudioBuffer> {\n            /*\n             * Bug #9 & #59: It is theoretically possible that startRendering() will first render a partialOfflineAudioContext. Therefore\n             * the state of the nativeOfflineAudioContext might no transition to running immediately.\n             */\n            if (this._state === 'running') {\n                return Promise.reject(createInvalidStateError());\n            }\n\n            this._state = 'running';\n\n            return startRendering(this.destination, this._nativeOfflineAudioContext).finally(() => {\n                this._state = null;\n\n                deactivateAudioGraph(this);\n            });\n        }\n\n        private _waitForThePromiseToSettle(event: Event): void {\n            if (this._state === null) {\n                this._nativeOfflineAudioContext.dispatchEvent(event);\n            } else {\n                setTimeout(() => this._waitForThePromiseToSettle(event));\n            }\n        }\n    };\n};\n", "import { isActiveAudioNode } from '../helpers/is-active-audio-node';\nimport { setInternalStateToActive } from '../helpers/set-internal-state-to-active';\nimport { setInternalStateToPassive } from '../helpers/set-internal-state-to-passive';\nimport {\n    IAudioParam,\n    IAudioScheduledSourceNodeEventMap,\n    IMinimalOfflineAudioContext,\n    IOscillatorNode,\n    IOscillatorNodeRenderer,\n    IOscillatorOptions\n} from '../interfaces';\nimport {\n    TContext,\n    TEventHandler,\n    TNativeOscillatorNode,\n    TOscillatorNodeConstructorFactory,\n    TOscillatorNodeRenderer,\n    TOscillatorType\n} from '../types';\n\nconst DEFAULT_OPTIONS = {\n    channelCount: 2,\n    channelCountMode: 'max', // This attribute has no effect for nodes with no inputs.\n    channelInterpretation: 'speakers', // This attribute has no effect for nodes with no inputs.\n    detune: 0,\n    frequency: 440,\n    periodicWave: undefined,\n    type: 'sine'\n} as const;\n\nexport const createOscillatorNodeConstructor: TOscillatorNodeConstructorFactory = (\n    audioNodeConstructor,\n    createAudioParam,\n    createNativeOscillatorNode,\n    createOscillatorNodeRenderer,\n    getNativeContext,\n    isNativeOfflineAudioContext,\n    wrapEventListener\n) => {\n    return class OscillatorNode<T extends TContext>\n        extends audioNodeConstructor<T, IAudioScheduledSourceNodeEventMap>\n        implements IOscillatorNode<T>\n    {\n        private _detune: IAudioParam;\n\n        private _frequency: IAudioParam;\n\n        private _nativeOscillatorNode: TNativeOscillatorNode;\n\n        private _onended: null | TEventHandler<this>;\n\n        private _oscillatorNodeRenderer: TOscillatorNodeRenderer<T>;\n\n        constructor(context: T, options?: Partial<IOscillatorOptions>) {\n            const nativeContext = getNativeContext(context);\n            const mergedOptions = { ...DEFAULT_OPTIONS, ...options };\n            const nativeOscillatorNode = createNativeOscillatorNode(nativeContext, mergedOptions);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            const oscillatorNodeRenderer = <TOscillatorNodeRenderer<T>>(isOffline ? createOscillatorNodeRenderer() : null);\n            const nyquist = context.sampleRate / 2;\n\n            super(context, false, nativeOscillatorNode, oscillatorNodeRenderer);\n\n            // Bug #81: Firefox & Safari do not export the correct values for maxValue and minValue.\n            this._detune = createAudioParam(this, isOffline, nativeOscillatorNode.detune, 153600, -153600);\n            // Bug #76: Safari does not export the correct values for maxValue and minValue.\n            this._frequency = createAudioParam(this, isOffline, nativeOscillatorNode.frequency, nyquist, -nyquist);\n            this._nativeOscillatorNode = nativeOscillatorNode;\n            this._onended = null;\n            this._oscillatorNodeRenderer = oscillatorNodeRenderer;\n\n            if (this._oscillatorNodeRenderer !== null && mergedOptions.periodicWave !== undefined) {\n                (<IOscillatorNodeRenderer<IMinimalOfflineAudioContext>>this._oscillatorNodeRenderer).periodicWave =\n                    mergedOptions.periodicWave;\n            }\n        }\n\n        get detune(): IAudioParam {\n            return this._detune;\n        }\n\n        get frequency(): IAudioParam {\n            return this._frequency;\n        }\n\n        get onended(): null | TEventHandler<this> {\n            return this._onended;\n        }\n\n        set onended(value) {\n            const wrappedListener = typeof value === 'function' ? wrapEventListener(this, value) : null;\n\n            this._nativeOscillatorNode.onended = wrappedListener;\n\n            const nativeOnEnded = this._nativeOscillatorNode.onended;\n\n            this._onended = nativeOnEnded !== null && nativeOnEnded === wrappedListener ? value : nativeOnEnded;\n        }\n\n        get type(): TOscillatorType {\n            return this._nativeOscillatorNode.type;\n        }\n\n        set type(value) {\n            this._nativeOscillatorNode.type = value;\n\n            if (this._oscillatorNodeRenderer !== null) {\n                this._oscillatorNodeRenderer.periodicWave = null;\n            }\n        }\n\n        public setPeriodicWave(periodicWave: PeriodicWave): void {\n            this._nativeOscillatorNode.setPeriodicWave(periodicWave);\n\n            if (this._oscillatorNodeRenderer !== null) {\n                this._oscillatorNodeRenderer.periodicWave = periodicWave;\n            }\n        }\n\n        public start(when = 0): void {\n            this._nativeOscillatorNode.start(when);\n\n            if (this._oscillatorNodeRenderer !== null) {\n                this._oscillatorNodeRenderer.start = when;\n            }\n\n            if (this.context.state !== 'closed') {\n                setInternalStateToActive(this);\n\n                const resetInternalStateToPassive = () => {\n                    this._nativeOscillatorNode.removeEventListener('ended', resetInternalStateToPassive);\n\n                    if (isActiveAudioNode(this)) {\n                        setInternalStateToPassive(this);\n                    }\n                };\n\n                this._nativeOscillatorNode.addEventListener('ended', resetInternalStateToPassive);\n            }\n        }\n\n        public stop(when = 0): void {\n            this._nativeOscillatorNode.stop(when);\n\n            if (this._oscillatorNodeRenderer !== null) {\n                this._oscillatorNodeRenderer.stop = when;\n            }\n        }\n    };\n};\n", "import { isOwnedByContext } from '../helpers/is-owned-by-context';\nimport { IMinimalOfflineAudioContext, IOfflineAudioContext, IOscillatorNode, IPeriodicWave } from '../interfaces';\nimport { TNativeOfflineAudioContext, TNativeOscillatorNode, TOscillatorNodeRendererFactoryFactory } from '../types';\n\nexport const createOscillatorNodeRendererFactory: TOscillatorNodeRendererFactoryFactory = (\n    connectAudioParam,\n    createNativeOscillatorNode,\n    getNativeAudioNode,\n    renderAutomation,\n    renderInputsOfAudioNode\n) => {\n    return <T extends IMinimalOfflineAudioContext | IOfflineAudioContext>() => {\n        const renderedNativeOscillatorNodes = new WeakMap<TNativeOfflineAudioContext, TNativeOscillatorNode>();\n\n        let periodicWave: null | IPeriodicWave = null;\n        let start: null | number = null;\n        let stop: null | number = null;\n\n        const createOscillatorNode = async (proxy: IOscillatorNode<T>, nativeOfflineAudioContext: TNativeOfflineAudioContext) => {\n            let nativeOscillatorNode = getNativeAudioNode<T, TNativeOscillatorNode>(proxy);\n\n            // If the initially used nativeOscillatorNode was not constructed on the same OfflineAudioContext it needs to be created again.\n            const nativeOscillatorNodeIsOwnedByContext = isOwnedByContext(nativeOscillatorNode, nativeOfflineAudioContext);\n\n            if (!nativeOscillatorNodeIsOwnedByContext) {\n                const options = {\n                    channelCount: nativeOscillatorNode.channelCount,\n                    channelCountMode: nativeOscillatorNode.channelCountMode,\n                    channelInterpretation: nativeOscillatorNode.channelInterpretation,\n                    detune: nativeOscillatorNode.detune.value,\n                    frequency: nativeOscillatorNode.frequency.value,\n                    periodicWave: periodicWave === null ? undefined : periodicWave,\n                    type: nativeOscillatorNode.type\n                };\n\n                nativeOscillatorNode = createNativeOscillatorNode(nativeOfflineAudioContext, options);\n\n                if (start !== null) {\n                    nativeOscillatorNode.start(start);\n                }\n\n                if (stop !== null) {\n                    nativeOscillatorNode.stop(stop);\n                }\n            }\n\n            renderedNativeOscillatorNodes.set(nativeOfflineAudioContext, nativeOscillatorNode);\n\n            if (!nativeOscillatorNodeIsOwnedByContext) {\n                await renderAutomation(nativeOfflineAudioContext, proxy.detune, nativeOscillatorNode.detune);\n                await renderAutomation(nativeOfflineAudioContext, proxy.frequency, nativeOscillatorNode.frequency);\n            } else {\n                await connectAudioParam(nativeOfflineAudioContext, proxy.detune, nativeOscillatorNode.detune);\n                await connectAudioParam(nativeOfflineAudioContext, proxy.frequency, nativeOscillatorNode.frequency);\n            }\n\n            await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeOscillatorNode);\n\n            return nativeOscillatorNode;\n        };\n\n        return {\n            set periodicWave(value: null | IPeriodicWave) {\n                periodicWave = value;\n            },\n            set start(value: number) {\n                start = value;\n            },\n            set stop(value: number) {\n                stop = value;\n            },\n            render(proxy: IOscillatorNode<T>, nativeOfflineAudioContext: TNativeOfflineAudioContext): Promise<TNativeOscillatorNode> {\n                const renderedNativeOscillatorNode = renderedNativeOscillatorNodes.get(nativeOfflineAudioContext);\n\n                if (renderedNativeOscillatorNode !== undefined) {\n                    return Promise.resolve(renderedNativeOscillatorNode);\n                }\n\n                return createOscillatorNode(proxy, nativeOfflineAudioContext);\n            }\n        };\n    };\n};\n", "import { MOST_NEGATIVE_SINGLE_FLOAT, MOST_POSITIVE_SINGLE_FLOAT } from '../constants';\nimport { IAudioParam, IPannerNode, IPannerOptions } from '../interfaces';\nimport {\n    TAudioNodeRenderer,\n    TContext,\n    TDistanceModelType,\n    TNativePannerNode,\n    TPannerNodeConstructorFactory,\n    TPanningModelType\n} from '../types';\n\nconst DEFAULT_OPTIONS = {\n    channelCount: 2,\n    channelCountMode: 'clamped-max',\n    channelInterpretation: 'speakers',\n    coneInnerAngle: 360,\n    coneOuterAngle: 360,\n    coneOuterGain: 0,\n    distanceModel: 'inverse',\n    maxDistance: 10000,\n    orientationX: 1,\n    orientationY: 0,\n    orientationZ: 0,\n    panningModel: 'equalpower',\n    positionX: 0,\n    positionY: 0,\n    positionZ: 0,\n    refDistance: 1,\n    rolloffFactor: 1\n} as const;\n\nexport const createPannerNodeConstructor: TPannerNodeConstructorFactory = (\n    audioNodeConstructor,\n    createAudioParam,\n    createNativePannerNode,\n    createPannerNodeRenderer,\n    getNativeContext,\n    isNativeOfflineAudioContext,\n    setAudioNodeTailTime\n) => {\n    return class PannerNode<T extends TContext> extends audioNodeConstructor<T> implements IPannerNode<T> {\n        private _nativePannerNode: TNativePannerNode;\n\n        private _orientationX: IAudioParam;\n\n        private _orientationY: IAudioParam;\n\n        private _orientationZ: IAudioParam;\n\n        private _positionX: IAudioParam;\n\n        private _positionY: IAudioParam;\n\n        private _positionZ: IAudioParam;\n\n        constructor(context: T, options?: Partial<IPannerOptions>) {\n            const nativeContext = getNativeContext(context);\n            const mergedOptions = { ...DEFAULT_OPTIONS, ...options };\n            const nativePannerNode = createNativePannerNode(nativeContext, mergedOptions);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            const pannerNodeRenderer = <TAudioNodeRenderer<T, this>>(isOffline ? createPannerNodeRenderer() : null);\n\n            super(context, false, nativePannerNode, pannerNodeRenderer);\n\n            this._nativePannerNode = nativePannerNode;\n            // Bug #74: Safari does not export the correct values for maxValue and minValue.\n            this._orientationX = createAudioParam(\n                this,\n                isOffline,\n                nativePannerNode.orientationX,\n                MOST_POSITIVE_SINGLE_FLOAT,\n                MOST_NEGATIVE_SINGLE_FLOAT\n            );\n            this._orientationY = createAudioParam(\n                this,\n                isOffline,\n                nativePannerNode.orientationY,\n                MOST_POSITIVE_SINGLE_FLOAT,\n                MOST_NEGATIVE_SINGLE_FLOAT\n            );\n            this._orientationZ = createAudioParam(\n                this,\n                isOffline,\n                nativePannerNode.orientationZ,\n                MOST_POSITIVE_SINGLE_FLOAT,\n                MOST_NEGATIVE_SINGLE_FLOAT\n            );\n            this._positionX = createAudioParam(\n                this,\n                isOffline,\n                nativePannerNode.positionX,\n                MOST_POSITIVE_SINGLE_FLOAT,\n                MOST_NEGATIVE_SINGLE_FLOAT\n            );\n            this._positionY = createAudioParam(\n                this,\n                isOffline,\n                nativePannerNode.positionY,\n                MOST_POSITIVE_SINGLE_FLOAT,\n                MOST_NEGATIVE_SINGLE_FLOAT\n            );\n            this._positionZ = createAudioParam(\n                this,\n                isOffline,\n                nativePannerNode.positionZ,\n                MOST_POSITIVE_SINGLE_FLOAT,\n                MOST_NEGATIVE_SINGLE_FLOAT\n            );\n\n            // @todo Determine a meaningful tail-time instead of just using one second.\n            setAudioNodeTailTime(this, 1);\n        }\n\n        get coneInnerAngle(): number {\n            return this._nativePannerNode.coneInnerAngle;\n        }\n\n        set coneInnerAngle(value) {\n            this._nativePannerNode.coneInnerAngle = value;\n        }\n\n        get coneOuterAngle(): number {\n            return this._nativePannerNode.coneOuterAngle;\n        }\n\n        set coneOuterAngle(value) {\n            this._nativePannerNode.coneOuterAngle = value;\n        }\n\n        get coneOuterGain(): number {\n            return this._nativePannerNode.coneOuterGain;\n        }\n\n        set coneOuterGain(value) {\n            this._nativePannerNode.coneOuterGain = value;\n        }\n\n        get distanceModel(): TDistanceModelType {\n            return this._nativePannerNode.distanceModel;\n        }\n\n        set distanceModel(value) {\n            this._nativePannerNode.distanceModel = value;\n        }\n\n        get maxDistance(): number {\n            return this._nativePannerNode.maxDistance;\n        }\n\n        set maxDistance(value) {\n            this._nativePannerNode.maxDistance = value;\n        }\n\n        get orientationX(): IAudioParam {\n            return this._orientationX;\n        }\n\n        get orientationY(): IAudioParam {\n            return this._orientationY;\n        }\n\n        get orientationZ(): IAudioParam {\n            return this._orientationZ;\n        }\n\n        get panningModel(): TPanningModelType {\n            return this._nativePannerNode.panningModel;\n        }\n\n        set panningModel(value) {\n            this._nativePannerNode.panningModel = value;\n        }\n\n        get positionX(): IAudioParam {\n            return this._positionX;\n        }\n\n        get positionY(): IAudioParam {\n            return this._positionY;\n        }\n\n        get positionZ(): IAudioParam {\n            return this._positionZ;\n        }\n\n        get refDistance(): number {\n            return this._nativePannerNode.refDistance;\n        }\n\n        set refDistance(value) {\n            this._nativePannerNode.refDistance = value;\n        }\n\n        get rolloffFactor(): number {\n            return this._nativePannerNode.rolloffFactor;\n        }\n\n        set rolloffFactor(value) {\n            this._nativePannerNode.rolloffFactor = value;\n        }\n    };\n};\n", "import { isNativeAudioNodeFaker } from '../guards/native-audio-node-faker';\nimport { isOwnedByContext } from '../helpers/is-owned-by-context';\nimport { IMinimalOfflineAudioContext, INativePannerNodeFaker, IOfflineAudioContext, IPannerNode } from '../interfaces';\nimport {\n    TNativeAudioBuffer,\n    TNativeGainNode,\n    TNativeOfflineAudioContext,\n    TNativePannerNode,\n    TPannerNodeRendererFactoryFactory\n} from '../types';\n\nexport const createPannerNodeRendererFactory: TPannerNodeRendererFactoryFactory = (\n    connectAudioParam,\n    createNativeChannelMergerNode,\n    createNativeConstantSourceNode,\n    createNativeGainNode,\n    createNativePannerNode,\n    getNativeAudioNode,\n    nativeOfflineAudioContextConstructor,\n    renderAutomation,\n    renderInputsOfAudioNode,\n    renderNativeOfflineAudioContext\n) => {\n    return <T extends IMinimalOfflineAudioContext | IOfflineAudioContext>() => {\n        const renderedNativeAudioNodes = new WeakMap<TNativeOfflineAudioContext, TNativeGainNode | TNativePannerNode>();\n\n        let renderedBufferPromise: null | Promise<TNativeAudioBuffer> = null;\n\n        const createAudioNode = async (proxy: IPannerNode<T>, nativeOfflineAudioContext: TNativeOfflineAudioContext) => {\n            let nativeGainNode: null | TNativeGainNode = null;\n            let nativePannerNode = getNativeAudioNode<T, TNativePannerNode>(proxy);\n\n            const commonAudioNodeOptions = {\n                channelCount: nativePannerNode.channelCount,\n                channelCountMode: nativePannerNode.channelCountMode,\n                channelInterpretation: nativePannerNode.channelInterpretation\n            };\n            const commonNativePannerNodeOptions = {\n                ...commonAudioNodeOptions,\n                coneInnerAngle: nativePannerNode.coneInnerAngle,\n                coneOuterAngle: nativePannerNode.coneOuterAngle,\n                coneOuterGain: nativePannerNode.coneOuterGain,\n                distanceModel: nativePannerNode.distanceModel,\n                maxDistance: nativePannerNode.maxDistance,\n                panningModel: nativePannerNode.panningModel,\n                refDistance: nativePannerNode.refDistance,\n                rolloffFactor: nativePannerNode.rolloffFactor\n            };\n\n            // If the initially used nativePannerNode was not constructed on the same OfflineAudioContext it needs to be created again.\n            const nativePannerNodeIsOwnedByContext = isOwnedByContext(nativePannerNode, nativeOfflineAudioContext);\n\n            // Bug #124: Safari does not support modifying the orientation and the position with AudioParams.\n            if ('bufferSize' in nativePannerNode) {\n                nativeGainNode = createNativeGainNode(nativeOfflineAudioContext, { ...commonAudioNodeOptions, gain: 1 });\n            } else if (!nativePannerNodeIsOwnedByContext) {\n                const options = {\n                    ...commonNativePannerNodeOptions,\n                    orientationX: nativePannerNode.orientationX.value,\n                    orientationY: nativePannerNode.orientationY.value,\n                    orientationZ: nativePannerNode.orientationZ.value,\n                    positionX: nativePannerNode.positionX.value,\n                    positionY: nativePannerNode.positionY.value,\n                    positionZ: nativePannerNode.positionZ.value\n                };\n\n                nativePannerNode = createNativePannerNode(nativeOfflineAudioContext, options);\n            }\n\n            renderedNativeAudioNodes.set(nativeOfflineAudioContext, nativeGainNode === null ? nativePannerNode : nativeGainNode);\n\n            if (nativeGainNode !== null) {\n                if (renderedBufferPromise === null) {\n                    if (nativeOfflineAudioContextConstructor === null) {\n                        throw new Error('Missing the native OfflineAudioContext constructor.');\n                    }\n\n                    const partialOfflineAudioContext = new nativeOfflineAudioContextConstructor(\n                        6,\n                        // Bug #17: Safari does not yet expose the length.\n                        proxy.context.length,\n                        nativeOfflineAudioContext.sampleRate\n                    );\n                    const nativeChannelMergerNode = createNativeChannelMergerNode(partialOfflineAudioContext, {\n                        channelCount: 1,\n                        channelCountMode: 'explicit',\n                        channelInterpretation: 'speakers',\n                        numberOfInputs: 6\n                    });\n                    nativeChannelMergerNode.connect(partialOfflineAudioContext.destination);\n\n                    renderedBufferPromise = (async () => {\n                        const nativeConstantSourceNodes = await Promise.all(\n                            [\n                                proxy.orientationX,\n                                proxy.orientationY,\n                                proxy.orientationZ,\n                                proxy.positionX,\n                                proxy.positionY,\n                                proxy.positionZ\n                            ].map(async (audioParam, index) => {\n                                const nativeConstantSourceNode = createNativeConstantSourceNode(partialOfflineAudioContext, {\n                                    channelCount: 1,\n                                    channelCountMode: 'explicit',\n                                    channelInterpretation: 'discrete',\n                                    offset: index === 0 ? 1 : 0\n                                });\n\n                                await renderAutomation(partialOfflineAudioContext, audioParam, nativeConstantSourceNode.offset);\n\n                                return nativeConstantSourceNode;\n                            })\n                        );\n\n                        for (let i = 0; i < 6; i += 1) {\n                            nativeConstantSourceNodes[i].connect(nativeChannelMergerNode, 0, i);\n                            nativeConstantSourceNodes[i].start(0);\n                        }\n\n                        return renderNativeOfflineAudioContext(partialOfflineAudioContext);\n                    })();\n                }\n\n                const renderedBuffer = await renderedBufferPromise;\n                const inputGainNode = createNativeGainNode(nativeOfflineAudioContext, { ...commonAudioNodeOptions, gain: 1 });\n\n                await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, inputGainNode);\n\n                const channelDatas: Float32Array[] = [];\n\n                for (let i = 0; i < renderedBuffer.numberOfChannels; i += 1) {\n                    channelDatas.push(renderedBuffer.getChannelData(i));\n                }\n\n                let lastOrientation = [channelDatas[0][0], channelDatas[1][0], channelDatas[2][0]];\n                let lastPosition = [channelDatas[3][0], channelDatas[4][0], channelDatas[5][0]];\n                let gateGainNode = createNativeGainNode(nativeOfflineAudioContext, { ...commonAudioNodeOptions, gain: 1 });\n                let partialPannerNode = createNativePannerNode(nativeOfflineAudioContext, {\n                    ...commonNativePannerNodeOptions,\n                    orientationX: lastOrientation[0],\n                    orientationY: lastOrientation[1],\n                    orientationZ: lastOrientation[2],\n                    positionX: lastPosition[0],\n                    positionY: lastPosition[1],\n                    positionZ: lastPosition[2]\n                });\n\n                inputGainNode.connect(gateGainNode).connect((<INativePannerNodeFaker>partialPannerNode).inputs[0]);\n                partialPannerNode.connect(nativeGainNode);\n\n                for (let i = 128; i < renderedBuffer.length; i += 128) {\n                    const orientation: [number, number, number] = [channelDatas[0][i], channelDatas[1][i], channelDatas[2][i]];\n                    const positon: [number, number, number] = [channelDatas[3][i], channelDatas[4][i], channelDatas[5][i]];\n\n                    if (\n                        orientation.some((value, index) => value !== lastOrientation[index]) ||\n                        positon.some((value, index) => value !== lastPosition[index])\n                    ) {\n                        lastOrientation = orientation;\n                        lastPosition = positon;\n\n                        const currentTime = i / nativeOfflineAudioContext.sampleRate;\n\n                        gateGainNode.gain.setValueAtTime(0, currentTime);\n\n                        gateGainNode = createNativeGainNode(nativeOfflineAudioContext, { ...commonAudioNodeOptions, gain: 0 });\n                        partialPannerNode = createNativePannerNode(nativeOfflineAudioContext, {\n                            ...commonNativePannerNodeOptions,\n                            orientationX: lastOrientation[0],\n                            orientationY: lastOrientation[1],\n                            orientationZ: lastOrientation[2],\n                            positionX: lastPosition[0],\n                            positionY: lastPosition[1],\n                            positionZ: lastPosition[2]\n                        });\n\n                        gateGainNode.gain.setValueAtTime(1, currentTime);\n\n                        inputGainNode.connect(gateGainNode).connect((<INativePannerNodeFaker>partialPannerNode).inputs[0]);\n                        partialPannerNode.connect(nativeGainNode);\n                    }\n                }\n\n                return nativeGainNode;\n            }\n\n            if (!nativePannerNodeIsOwnedByContext) {\n                await renderAutomation(nativeOfflineAudioContext, proxy.orientationX, nativePannerNode.orientationX);\n                await renderAutomation(nativeOfflineAudioContext, proxy.orientationY, nativePannerNode.orientationY);\n                await renderAutomation(nativeOfflineAudioContext, proxy.orientationZ, nativePannerNode.orientationZ);\n                await renderAutomation(nativeOfflineAudioContext, proxy.positionX, nativePannerNode.positionX);\n                await renderAutomation(nativeOfflineAudioContext, proxy.positionY, nativePannerNode.positionY);\n                await renderAutomation(nativeOfflineAudioContext, proxy.positionZ, nativePannerNode.positionZ);\n            } else {\n                await connectAudioParam(nativeOfflineAudioContext, proxy.orientationX, nativePannerNode.orientationX);\n                await connectAudioParam(nativeOfflineAudioContext, proxy.orientationY, nativePannerNode.orientationY);\n                await connectAudioParam(nativeOfflineAudioContext, proxy.orientationZ, nativePannerNode.orientationZ);\n                await connectAudioParam(nativeOfflineAudioContext, proxy.positionX, nativePannerNode.positionX);\n                await connectAudioParam(nativeOfflineAudioContext, proxy.positionY, nativePannerNode.positionY);\n                await connectAudioParam(nativeOfflineAudioContext, proxy.positionZ, nativePannerNode.positionZ);\n            }\n\n            if (isNativeAudioNodeFaker(nativePannerNode)) {\n                await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativePannerNode.inputs[0]);\n            } else {\n                await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativePannerNode);\n            }\n\n            return nativePannerNode;\n        };\n\n        return {\n            render(\n                proxy: IPannerNode<T>,\n                nativeOfflineAudioContext: TNativeOfflineAudioContext\n            ): Promise<TNativeGainNode | TNativePannerNode> {\n                const renderedNativeGainNodeOrNativePannerNode = renderedNativeAudioNodes.get(nativeOfflineAudioContext);\n\n                if (renderedNativeGainNodeOrNativePannerNode !== undefined) {\n                    return Promise.resolve(renderedNativeGainNodeOrNativePannerNode);\n                }\n\n                return createAudioNode(proxy, nativeOfflineAudioContext);\n            }\n        };\n    };\n};\n", "import { IPeriodicWave, IPeriodicWaveOptions } from '../interfaces';\nimport { TContext, TPeriodicWaveConstructorFactory } from '../types';\n\nconst DEFAULT_OPTIONS = {\n    disableNormalization: false\n} as const;\n\nexport const createPeriodicWaveConstructor: TPeriodicWaveConstructorFactory = (\n    createNativePeriodicWave,\n    getNativeContext,\n    periodicWaveStore,\n    sanitizePeriodicWaveOptions\n) => {\n    return class PeriodicWave<T extends TContext> implements IPeriodicWave {\n        constructor(context: T, options?: Partial<IPeriodicWaveOptions>) {\n            const nativeContext = getNativeContext(context);\n            const mergedOptions = sanitizePeriodicWaveOptions({ ...DEFAULT_OPTIONS, ...options });\n            const periodicWave = createNativePeriodicWave(nativeContext, mergedOptions);\n\n            periodicWaveStore.add(periodicWave);\n\n            // This does violate all good pratices but it is used here to simplify the handling of periodic waves.\n            return periodicWave;\n        }\n\n        public static [Symbol.hasInstance](instance: unknown): boolean {\n            return (\n                (instance !== null && typeof instance === 'object' && Object.getPrototypeOf(instance) === PeriodicWave.prototype) ||\n                periodicWaveStore.has(<any>instance)\n            );\n        }\n    };\n};\n", "import { TRenderAutomationFactory } from '../types';\n\nexport const createRenderAutomation: TRenderAutomationFactory = (getAudioParamRenderer, renderInputsOfAudioParam) => {\n    return (nativeOfflineAudioContext, audioParam, nativeAudioParam) => {\n        const audioParamRenderer = getAudioParamRenderer(audioParam);\n\n        audioParamRenderer.replay(nativeAudioParam);\n\n        return renderInputsOfAudioParam(audioParam, nativeOfflineAudioContext, nativeAudioParam);\n    };\n};\n", "import { IAudioDestinationNode } from '../interfaces';\nimport { TRenderInputsOfAudioNodeFactory } from '../types';\n\nexport const createRenderInputsOfAudioNode: TRenderInputsOfAudioNodeFactory = (\n    getAudioNodeConnections,\n    getAudioNodeRenderer,\n    isPartOfACycle\n) => {\n    return async (audioNode, nativeOfflineAudioContext, nativeAudioNode) => {\n        const audioNodeConnections = getAudioNodeConnections(audioNode);\n\n        await Promise.all(\n            audioNodeConnections.activeInputs\n                .map((connections, input) =>\n                    Array.from(connections).map(async ([source, output]) => {\n                        const audioNodeRenderer = getAudioNodeRenderer(source);\n                        const renderedNativeAudioNode = await audioNodeRenderer.render(source, nativeOfflineAudioContext);\n                        const destination = <IAudioDestinationNode<typeof audioNode.context>>audioNode.context.destination;\n\n                        if (!isPartOfACycle(source) && (audioNode !== destination || !isPartOfACycle(audioNode))) {\n                            renderedNativeAudioNode.connect(nativeAudioNode, output, input);\n                        }\n                    })\n                )\n                .reduce((allRenderingPromises, renderingPromises) => [...allRenderingPromises, ...renderingPromises], [])\n        );\n    };\n};\n", "import { IAudioParam, IMinimalOfflineAudioContext, IOfflineAudioContext } from '../interfaces';\nimport { TNativeAudioParam, TNativeOfflineAudioContext, TRenderInputsOfAudioParamFactory } from '../types';\n\nexport const createRenderInputsOfAudioParam: TRenderInputsOfAudioParamFactory = (\n    getAudioNodeRenderer,\n    getAudioParamConnections,\n    isPartOfACycle\n) => {\n    return async <T extends IMinimalOfflineAudioContext | IOfflineAudioContext>(\n        audioParam: IAudioParam,\n        nativeOfflineAudioContext: TNativeOfflineAudioContext,\n        nativeAudioParam: TNativeAudioParam\n    ): Promise<void> => {\n        const audioParamConnections = getAudioParamConnections<T>(audioParam);\n\n        await Promise.all(\n            Array.from(audioParamConnections.activeInputs).map(async ([source, output]) => {\n                const audioNodeRenderer = getAudioNodeRenderer(source);\n                const renderedNativeAudioNode = await audioNodeRenderer.render(source, nativeOfflineAudioContext);\n\n                if (!isPartOfACycle(source)) {\n                    renderedNativeAudioNode.connect(nativeAudioParam, output);\n                }\n            })\n        );\n    };\n};\n", "import { testPromiseSupport } from '../helpers/test-promise-support';\nimport { IOfflineAudioCompletionEvent } from '../interfaces';\nimport { TNativeAudioBuffer, TRenderNativeOfflineAudioContextFactory } from '../types';\n\nexport const createRenderNativeOfflineAudioContext: TRenderNativeOfflineAudioContextFactory = (\n    cacheTestResult,\n    createNativeGainNode,\n    createNativeScriptProcessorNode,\n    testOfflineAudioContextCurrentTimeSupport\n) => {\n    return (nativeOfflineAudioContext) => {\n        // Bug #21: Safari does not support promises yet.\n        if (cacheTestResult(testPromiseSupport, () => testPromiseSupport(nativeOfflineAudioContext))) {\n            // Bug #158: Chrome and Edge do not advance currentTime if it is not accessed while rendering the audio.\n            return Promise.resolve(\n                cacheTestResult(testOfflineAudioContextCurrentTimeSupport, testOfflineAudioContextCurrentTimeSupport)\n            ).then((isOfflineAudioContextCurrentTimeSupported) => {\n                if (!isOfflineAudioContextCurrentTimeSupported) {\n                    const scriptProcessorNode = createNativeScriptProcessorNode(nativeOfflineAudioContext, 512, 0, 1);\n\n                    nativeOfflineAudioContext.oncomplete = () => {\n                        scriptProcessorNode.onaudioprocess = null; // tslint:disable-line:deprecation\n                        scriptProcessorNode.disconnect();\n                    };\n                    scriptProcessorNode.onaudioprocess = () => nativeOfflineAudioContext.currentTime; // tslint:disable-line:deprecation\n\n                    scriptProcessorNode.connect(nativeOfflineAudioContext.destination);\n                }\n\n                return nativeOfflineAudioContext.startRendering();\n            });\n        }\n\n        return new Promise<TNativeAudioBuffer>((resolve) => {\n            // Bug #48: Safari does not render an OfflineAudioContext without any connected node.\n            const gainNode = createNativeGainNode(nativeOfflineAudioContext, {\n                channelCount: 1,\n                channelCountMode: 'explicit',\n                channelInterpretation: 'discrete',\n                gain: 0\n            });\n\n            nativeOfflineAudioContext.oncomplete = (event: IOfflineAudioCompletionEvent) => {\n                gainNode.disconnect();\n\n                resolve(event.renderedBuffer);\n            };\n\n            gainNode.connect(nativeOfflineAudioContext.destination);\n\n            nativeOfflineAudioContext.startRendering();\n        });\n    };\n};\n", "import { TSetActiveAudioWorkletNodeInputsFactory } from '../types';\n\nexport const createSetActiveAudioWorkletNodeInputs: TSetActiveAudioWorkletNodeInputsFactory = (activeAudioWorkletNodeInputsStore) => {\n    return (nativeAudioWorkletNode, activeInputs) => {\n        activeAudioWorkletNodeInputsStore.set(nativeAudioWorkletNode, activeInputs);\n    };\n};\n", "import { TSetAudioNodeTailTimeFactory } from '../types';\n\nexport const createSetAudioNodeTailTime: TSetAudioNodeTailTimeFactory = (audioNodeTailTimeStore) => {\n    return (audioNode, tailTime) => audioNodeTailTimeStore.set(audioNode, tailTime);\n};\n", "import { wrapAudioBufferGetChannelDataMethod } from '../helpers/wrap-audio-buffer-get-channel-data-method';\nimport { TStartRenderingFactory } from '../types';\n\nexport const createStartRendering: TStartRenderingFactory = (\n    audioBufferStore,\n    cacheTestResult,\n    getAudioNodeRenderer,\n    getUnrenderedAudioWorkletNodes,\n    renderNativeOfflineAudioContext,\n    testAudioBufferCopyChannelMethodsOutOfBoundsSupport,\n    wrapAudioBufferCopyChannelMethods,\n    wrapAudioBufferCopyChannelMethodsOutOfBounds\n) => {\n    return (destination, nativeOfflineAudioContext) =>\n        getAudioNodeRenderer(destination)\n            .render(destination, nativeOfflineAudioContext)\n            /*\n             * Bug #86 & #87: Invoking the renderer of an AudioWorkletNode might be necessary if it has no direct or indirect connection to the\n             * destination.\n             */\n            .then(() =>\n                Promise.all(\n                    Array.from(getUnrenderedAudioWorkletNodes(nativeOfflineAudioContext)).map((audioWorkletNode) =>\n                        getAudioNodeRenderer(audioWorkletNode).render(audioWorkletNode, nativeOfflineAudioContext)\n                    )\n                )\n            )\n            .then(() => renderNativeOfflineAudioContext(nativeOfflineAudioContext))\n            .then((audioBuffer) => {\n                // Bug #5: Safari does not support copyFromChannel() and copyToChannel().\n                // Bug #100: Safari does throw a wrong error when calling getChannelData() with an out-of-bounds value.\n                if (typeof audioBuffer.copyFromChannel !== 'function') {\n                    wrapAudioBufferCopyChannelMethods(audioBuffer);\n                    wrapAudioBufferGetChannelDataMethod(audioBuffer);\n                    // Bug #157: Firefox does not allow the bufferOffset to be out-of-bounds.\n                } else if (\n                    !cacheTestResult(testAudioBufferCopyChannelMethodsOutOfBoundsSupport, () =>\n                        testAudioBufferCopyChannelMethodsOutOfBoundsSupport(audioBuffer)\n                    )\n                ) {\n                    wrapAudioBufferCopyChannelMethodsOutOfBounds(audioBuffer);\n                }\n\n                audioBufferStore.add(audioBuffer);\n\n                return audioBuffer;\n            });\n};\n", "import { IAudioParam, IStereoPannerNode, IStereoPannerOptions } from '../interfaces';\nimport { TAudioNodeRenderer, TContext, TStereoPannerNodeConstructorFactory } from '../types';\n\nconst DEFAULT_OPTIONS = {\n    channelCount: 2,\n    /*\n     * Bug #105: The channelCountMode should be 'clamped-max' according to the spec but is set to 'explicit' to achieve consistent\n     * behavior.\n     */\n    channelCountMode: 'explicit',\n    channelInterpretation: 'speakers',\n    pan: 0\n} as const;\n\nexport const createStereoPannerNodeConstructor: TStereoPannerNodeConstructorFactory = (\n    audioNodeConstructor,\n    createAudioParam,\n    createNativeStereoPannerNode,\n    createStereoPannerNodeRenderer,\n    getNativeContext,\n    isNativeOfflineAudioContext\n) => {\n    return class StereoPannerNode<T extends TContext> extends audioNodeConstructor<T> implements IStereoPannerNode<T> {\n        private _pan: IAudioParam;\n\n        constructor(context: T, options?: Partial<IStereoPannerOptions>) {\n            const nativeContext = getNativeContext(context);\n            const mergedOptions = { ...DEFAULT_OPTIONS, ...options };\n            const nativeStereoPannerNode = createNativeStereoPannerNode(nativeContext, mergedOptions);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            const stereoPannerNodeRenderer = <TAudioNodeRenderer<T, this>>(isOffline ? createStereoPannerNodeRenderer() : null);\n\n            super(context, false, nativeStereoPannerNode, stereoPannerNodeRenderer);\n\n            this._pan = createAudioParam(this, isOffline, nativeStereoPannerNode.pan);\n        }\n\n        get pan(): IAudioParam {\n            return this._pan;\n        }\n    };\n};\n", "import { isNativeAudioNodeFaker } from '../guards/native-audio-node-faker';\nimport { isOwnedByContext } from '../helpers/is-owned-by-context';\nimport { IMinimalOfflineAudioContext, IOfflineAudioContext, IStereoPannerNode } from '../interfaces';\nimport { TNativeOfflineAudioContext, TNativeStereoPannerNode, TStereoPannerNodeRendererFactoryFactory } from '../types';\n\nexport const createStereoPannerNodeRendererFactory: TStereoPannerNodeRendererFactoryFactory = (\n    connectAudioParam,\n    createNativeStereoPannerNode,\n    getNativeAudioNode,\n    renderAutomation,\n    renderInputsOfAudioNode\n) => {\n    return <T extends IMinimalOfflineAudioContext | IOfflineAudioContext>() => {\n        const renderedNativeStereoPannerNodes = new WeakMap<TNativeOfflineAudioContext, TNativeStereoPannerNode>();\n\n        const createStereoPannerNode = async (proxy: IStereoPannerNode<T>, nativeOfflineAudioContext: TNativeOfflineAudioContext) => {\n            let nativeStereoPannerNode = getNativeAudioNode<T, TNativeStereoPannerNode>(proxy);\n\n            /*\n             * If the initially used nativeStereoPannerNode was not constructed on the same OfflineAudioContext it needs to be created\n             * again.\n             */\n            const nativeStereoPannerNodeIsOwnedByContext = isOwnedByContext(nativeStereoPannerNode, nativeOfflineAudioContext);\n\n            if (!nativeStereoPannerNodeIsOwnedByContext) {\n                const options = {\n                    channelCount: nativeStereoPannerNode.channelCount,\n                    channelCountMode: nativeStereoPannerNode.channelCountMode,\n                    channelInterpretation: nativeStereoPannerNode.channelInterpretation,\n                    pan: nativeStereoPannerNode.pan.value\n                };\n\n                nativeStereoPannerNode = createNativeStereoPannerNode(nativeOfflineAudioContext, options);\n            }\n\n            renderedNativeStereoPannerNodes.set(nativeOfflineAudioContext, nativeStereoPannerNode);\n\n            if (!nativeStereoPannerNodeIsOwnedByContext) {\n                await renderAutomation(nativeOfflineAudioContext, proxy.pan, nativeStereoPannerNode.pan);\n            } else {\n                await connectAudioParam(nativeOfflineAudioContext, proxy.pan, nativeStereoPannerNode.pan);\n            }\n\n            if (isNativeAudioNodeFaker(nativeStereoPannerNode)) {\n                await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeStereoPannerNode.inputs[0]);\n            } else {\n                await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeStereoPannerNode);\n            }\n\n            return nativeStereoPannerNode;\n        };\n\n        return {\n            render(proxy: IStereoPannerNode<T>, nativeOfflineAudioContext: TNativeOfflineAudioContext): Promise<TNativeStereoPannerNode> {\n                const renderedNativeStereoPannerNode = renderedNativeStereoPannerNodes.get(nativeOfflineAudioContext);\n\n                if (renderedNativeStereoPannerNode !== undefined) {\n                    return Promise.resolve(renderedNativeStereoPannerNode);\n                }\n\n                return createStereoPannerNode(proxy, nativeOfflineAudioContext);\n            }\n        };\n    };\n};\n", "import { TTestAudioBufferConstructorSupportFactory } from '../types';\n\n// Bug #33: Safari exposes an AudioBuffer but it can't be used as a constructor.\nexport const createTestAudioBufferConstructorSupport: TTestAudioBufferConstructorSupportFactory = (nativeAudioBufferConstructor) => {\n    return () => {\n        if (nativeAudioBufferConstructor === null) {\n            return false;\n        }\n\n        try {\n            new nativeAudioBufferConstructor({ length: 1, sampleRate: 44100 }); // tslint:disable-line:no-unused-expression\n        } catch {\n            return false;\n        }\n\n        return true;\n    };\n};\n", "import { TTestAudioWorkletProcessorPostMessageSupportFactory } from '../types';\n\n// Bug #179: Firefox does not allow to transfer any buffer which has been passed to the process() method as an argument.\nexport const createTestAudioWorkletProcessorPostMessageSupport: TTestAudioWorkletProcessorPostMessageSupportFactory = (\n    nativeAudioWorkletNodeConstructor,\n    nativeOfflineAudioContextConstructor\n) => {\n    return async () => {\n        // Bug #61: If there is no native AudioWorkletNode it gets faked and therefore it is no problem if the it doesn't exist.\n        if (nativeAudioWorkletNodeConstructor === null) {\n            return true;\n        }\n\n        if (nativeOfflineAudioContextConstructor === null) {\n            return false;\n        }\n\n        const blob = new Blob(\n            ['class A extends AudioWorkletProcessor{process(i){this.port.postMessage(i,[i[0][0].buffer])}}registerProcessor(\"a\",A)'],\n            {\n                type: 'application/javascript; charset=utf-8'\n            }\n        );\n        // Bug #141: Safari does not support creating an OfflineAudioContext with less than 44100 Hz.\n        const offlineAudioContext = new nativeOfflineAudioContextConstructor(1, 128, 44100);\n        const url = URL.createObjectURL(blob);\n\n        let isEmittingMessageEvents = false;\n        let isEmittingProcessorErrorEvents = false;\n\n        try {\n            await offlineAudioContext.audioWorklet.addModule(url);\n\n            const audioWorkletNode = new nativeAudioWorkletNodeConstructor(offlineAudioContext, 'a', { numberOfOutputs: 0 });\n            const oscillator = offlineAudioContext.createOscillator();\n\n            audioWorkletNode.port.onmessage = () => (isEmittingMessageEvents = true);\n            audioWorkletNode.onprocessorerror = () => (isEmittingProcessorErrorEvents = true);\n\n            oscillator.connect(audioWorkletNode);\n            oscillator.start(0);\n\n            await offlineAudioContext.startRendering();\n\n            // Bug #197: Safari does not deliver the messages before the promise returned by startRendering() resolves.\n            await new Promise((resolve) => setTimeout(resolve));\n        } catch {\n            // Ignore errors.\n        } finally {\n            URL.revokeObjectURL(url);\n        }\n\n        return isEmittingMessageEvents && !isEmittingProcessorErrorEvents;\n    };\n};\n", "import { TTestOfflineAudioContextCurrentTimeSupportFactory } from '../types';\n\nexport const createTestOfflineAudioContextCurrentTimeSupport: TTestOfflineAudioContextCurrentTimeSupportFactory = (\n    createNativeGainNode,\n    nativeOfflineAudioContextConstructor\n) => {\n    return () => {\n        if (nativeOfflineAudioContextConstructor === null) {\n            return Promise.resolve(false);\n        }\n\n        const nativeOfflineAudioContext = new nativeOfflineAudioContextConstructor(1, 1, 44100);\n\n        // Bug #48: Safari does not render an OfflineAudioContext without any connected node.\n        const gainNode = createNativeGainNode(nativeOfflineAudioContext, {\n            channelCount: 1,\n            channelCountMode: 'explicit',\n            channelInterpretation: 'discrete',\n            gain: 0\n        });\n\n        // Bug #21: Safari does not support promises yet.\n        return new Promise((resolve) => {\n            nativeOfflineAudioContext.oncomplete = () => {\n                gainNode.disconnect();\n\n                resolve(nativeOfflineAudioContext.currentTime !== 0);\n            };\n            nativeOfflineAudioContext.startRendering();\n        });\n    };\n};\n", "import { TUnknownErrorFactory } from '../types';\n\nexport const createUnknownError: TUnknownErrorFactory = () => new DOMException('', 'UnknownError');\n", "import { IWaveShaperNode, IWaveShaperOptions } from '../interfaces';\nimport { TAudioNodeRenderer, TContext, TNativeWaveShaperNode, TOverSampleType, TWaveShaperNodeConstructorFactory } from '../types';\n\nconst DEFAULT_OPTIONS = {\n    channelCount: 2,\n    channelCountMode: 'max',\n    channelInterpretation: 'speakers',\n    curve: null,\n    oversample: 'none'\n} as const;\n\nexport const createWaveShaperNodeConstructor: TWaveShaperNodeConstructorFactory = (\n    audioNodeConstructor,\n    createInvalidStateError,\n    createNativeWaveShaperNode,\n    createWaveShaperNodeRenderer,\n    getNativeContext,\n    isNativeOfflineAudioContext,\n    setAudioNodeTailTime\n) => {\n    return class WaveShaperNode<T extends TContext> extends audioNodeConstructor<T> implements IWaveShaperNode<T> {\n        private _isCurveNullified: boolean;\n\n        private _nativeWaveShaperNode: TNativeWaveShaperNode;\n\n        constructor(context: T, options?: Partial<IWaveShaperOptions>) {\n            const nativeContext = getNativeContext(context);\n            const mergedOptions = { ...DEFAULT_OPTIONS, ...options };\n            const nativeWaveShaperNode = createNativeWaveShaperNode(nativeContext, mergedOptions);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            const waveShaperNodeRenderer = <TAudioNodeRenderer<T, this>>(isOffline ? createWaveShaperNodeRenderer() : null);\n\n            // @todo Add a mechanism to only switch a WaveShaperNode to active while it is connected.\n            super(context, true, nativeWaveShaperNode, waveShaperNodeRenderer);\n\n            this._isCurveNullified = false;\n            this._nativeWaveShaperNode = nativeWaveShaperNode;\n\n            // @todo Determine a meaningful tail-time instead of just using one second.\n            setAudioNodeTailTime(this, 1);\n        }\n\n        get curve(): null | Float32Array {\n            if (this._isCurveNullified) {\n                return null;\n            }\n\n            return this._nativeWaveShaperNode.curve;\n        }\n\n        set curve(value) {\n            // Bug #103: Safari does not allow to set the curve to null.\n            if (value === null) {\n                this._isCurveNullified = true;\n                this._nativeWaveShaperNode.curve = new Float32Array([0, 0]);\n            } else {\n                // Bug #102: Safari does not throw an InvalidStateError when the curve has less than two samples.\n                // Bug #104: Chrome and Edge will throw an InvalidAccessError when the curve has less than two samples.\n                if (value.length < 2) {\n                    throw createInvalidStateError();\n                }\n\n                this._isCurveNullified = false;\n                this._nativeWaveShaperNode.curve = value;\n            }\n        }\n\n        get oversample(): TOverSampleType {\n            return this._nativeWaveShaperNode.oversample;\n        }\n\n        set oversample(value) {\n            this._nativeWaveShaperNode.oversample = value;\n        }\n    };\n};\n", "import { isNativeAudioNodeFaker } from '../guards/native-audio-node-faker';\nimport { isOwnedByContext } from '../helpers/is-owned-by-context';\nimport { IMinimalOfflineAudioContext, IOfflineAudioContext, IWaveShaperNode } from '../interfaces';\nimport { TNativeOfflineAudioContext, TNativeWaveShaperNode, TWaveShaperNodeRendererFactoryFactory } from '../types';\n\nexport const createWaveShaperNodeRendererFactory: TWaveShaperNodeRendererFactoryFactory = (\n    createNativeWaveShaperNode,\n    getNativeAudioNode,\n    renderInputsOfAudioNode\n) => {\n    return <T extends IMinimalOfflineAudioContext | IOfflineAudioContext>() => {\n        const renderedNativeWaveShaperNodes = new WeakMap<TNativeOfflineAudioContext, TNativeWaveShaperNode>();\n\n        const createWaveShaperNode = async (proxy: IWaveShaperNode<T>, nativeOfflineAudioContext: TNativeOfflineAudioContext) => {\n            let nativeWaveShaperNode = getNativeAudioNode<T, TNativeWaveShaperNode>(proxy);\n\n            // If the initially used nativeWaveShaperNode was not constructed on the same OfflineAudioContext it needs to be created again.\n            const nativeWaveShaperNodeIsOwnedByContext = isOwnedByContext(nativeWaveShaperNode, nativeOfflineAudioContext);\n\n            if (!nativeWaveShaperNodeIsOwnedByContext) {\n                const options = {\n                    channelCount: nativeWaveShaperNode.channelCount,\n                    channelCountMode: nativeWaveShaperNode.channelCountMode,\n                    channelInterpretation: nativeWaveShaperNode.channelInterpretation,\n                    curve: nativeWaveShaperNode.curve,\n                    oversample: nativeWaveShaperNode.oversample\n                };\n\n                nativeWaveShaperNode = createNativeWaveShaperNode(nativeOfflineAudioContext, options);\n            }\n\n            renderedNativeWaveShaperNodes.set(nativeOfflineAudioContext, nativeWaveShaperNode);\n\n            if (isNativeAudioNodeFaker(nativeWaveShaperNode)) {\n                await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeWaveShaperNode.inputs[0]);\n            } else {\n                await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeWaveShaperNode);\n            }\n\n            return nativeWaveShaperNode;\n        };\n\n        return {\n            render(proxy: IWaveShaperNode<T>, nativeOfflineAudioContext: TNativeOfflineAudioContext): Promise<TNativeWaveShaperNode> {\n                const renderedNativeWaveShaperNode = renderedNativeWaveShaperNodes.get(nativeOfflineAudioContext);\n\n                if (renderedNativeWaveShaperNode !== undefined) {\n                    return Promise.resolve(renderedNativeWaveShaperNode);\n                }\n\n                return createWaveShaperNode(proxy, nativeOfflineAudioContext);\n            }\n        };\n    };\n};\n", "import { TWindow, TWindowFactory } from '../types';\n\nexport const createWindow: TWindowFactory = () => (typeof window === 'undefined' ? null : <TWindow>window);\n", "import { TNativeAudioBuffer, TWrapAudioBufferCopyChannelMethodsFactory } from '../types';\n\nexport const createWrapAudioBufferCopyChannelMethods: TWrapAudioBufferCopyChannelMethodsFactory = (\n    convertNumberToUnsignedLong,\n    createIndexSizeError\n) => {\n    return (audioBuffer: TNativeAudioBuffer): void => {\n        audioBuffer.copyFromChannel = (destination, channelNumberAsNumber, bufferOffsetAsNumber = 0) => {\n            const bufferOffset = convertNumberToUnsignedLong(bufferOffsetAsNumber);\n            const channelNumber = convertNumberToUnsignedLong(channelNumberAsNumber);\n\n            if (channelNumber >= audioBuffer.numberOfChannels) {\n                throw createIndexSizeError();\n            }\n\n            const audioBufferLength = audioBuffer.length;\n            const channelData = audioBuffer.getChannelData(channelNumber);\n            const destinationLength = destination.length;\n\n            for (let i = bufferOffset < 0 ? -bufferOffset : 0; i + bufferOffset < audioBufferLength && i < destinationLength; i += 1) {\n                destination[i] = channelData[i + bufferOffset];\n            }\n        };\n\n        audioBuffer.copyToChannel = (source, channelNumberAsNumber, bufferOffsetAsNumber = 0) => {\n            const bufferOffset = convertNumberToUnsignedLong(bufferOffsetAsNumber);\n            const channelNumber = convertNumberToUnsignedLong(channelNumberAsNumber);\n\n            if (channelNumber >= audioBuffer.numberOfChannels) {\n                throw createIndexSizeError();\n            }\n\n            const audioBufferLength = audioBuffer.length;\n            const channelData = audioBuffer.getChannelData(channelNumber);\n            const sourceLength = source.length;\n\n            for (let i = bufferOffset < 0 ? -bufferOffset : 0; i + bufferOffset < audioBufferLength && i < sourceLength; i += 1) {\n                channelData[i + bufferOffset] = source[i];\n            }\n        };\n    };\n};\n", "import { TNativeAudioBuffer, TWrapAudioBufferCopyChannelMethodsOutOfBoundsFactory } from '../types';\n\nexport const createWrapAudioBufferCopyChannelMethodsOutOfBounds: TWrapAudioBufferCopyChannelMethodsOutOfBoundsFactory = (\n    convertNumberToUnsignedLong\n) => {\n    return (audioBuffer: TNativeAudioBuffer): void => {\n        audioBuffer.copyFromChannel = ((copyFromChannel) => {\n            return (destination: Float32Array, channelNumberAsNumber: number, bufferOffsetAsNumber = 0) => {\n                const bufferOffset = convertNumberToUnsignedLong(bufferOffsetAsNumber);\n                const channelNumber = convertNumberToUnsignedLong(channelNumberAsNumber);\n\n                if (bufferOffset < audioBuffer.length) {\n                    return copyFromChannel.call(audioBuffer, destination, channelNumber, bufferOffset);\n                }\n            };\n        })(audioBuffer.copyFromChannel);\n\n        audioBuffer.copyToChannel = ((copyToChannel) => {\n            return (source: Float32Array, channelNumberAsNumber: number, bufferOffsetAsNumber = 0) => {\n                const bufferOffset = convertNumberToUnsignedLong(bufferOffsetAsNumber);\n                const channelNumber = convertNumberToUnsignedLong(channelNumberAsNumber);\n\n                if (bufferOffset < audioBuffer.length) {\n                    return copyToChannel.call(audioBuffer, source, channelNumber, bufferOffset);\n                }\n            };\n        })(audioBuffer.copyToChannel);\n    };\n};\n", "import { TWrapAudioBufferSourceNodeStopMethodNullifiedBufferFactory } from '../types';\n\nexport const createWrapAudioBufferSourceNodeStopMethodNullifiedBuffer: TWrapAudioBufferSourceNodeStopMethodNullifiedBufferFactory = (\n    overwriteAccessors\n) => {\n    return (nativeAudioBufferSourceNode, nativeContext) => {\n        const nullifiedBuffer = nativeContext.createBuffer(1, 1, 44100);\n\n        if (nativeAudioBufferSourceNode.buffer === null) {\n            nativeAudioBufferSourceNode.buffer = nullifiedBuffer;\n        }\n\n        overwriteAccessors(\n            nativeAudioBufferSourceNode,\n            'buffer',\n            (get) => () => {\n                const value = get.call(nativeAudioBufferSourceNode);\n\n                return value === nullifiedBuffer ? null : value;\n            },\n            (set) => (value) => {\n                return set.call(nativeAudioBufferSourceNode, value === null ? nullifiedBuffer : value);\n            }\n        );\n    };\n};\n", "import { TWrapChannelMergerNodeFactory } from '../types';\n\nexport const createWrapChannelMergerNode: TWrapChannelMergerNodeFactory = (createInvalidStateError, monitorConnections) => {\n    return (nativeContext, channelMergerNode) => {\n        // Bug #15: Safari does not return the default properties.\n        channelMergerNode.channelCount = 1;\n        channelMergerNode.channelCountMode = 'explicit';\n\n        // Bug #16: Safari does not throw an error when setting a different channelCount or channelCountMode.\n        Object.defineProperty(channelMergerNode, 'channelCount', {\n            get: () => 1,\n            set: () => {\n                throw createInvalidStateError();\n            }\n        });\n\n        Object.defineProperty(channelMergerNode, 'channelCountMode', {\n            get: () => 'explicit',\n            set: () => {\n                throw createInvalidStateError();\n            }\n        });\n\n        // Bug #20: Safari requires a connection of any kind to treat the input signal correctly.\n        const audioBufferSourceNode = nativeContext.createBufferSource();\n\n        const whenConnected = () => {\n            const length = channelMergerNode.numberOfInputs;\n\n            for (let i = 0; i < length; i += 1) {\n                audioBufferSourceNode.connect(channelMergerNode, 0, i);\n            }\n        };\n        const whenDisconnected = () => audioBufferSourceNode.disconnect(channelMergerNode);\n\n        monitorConnections(channelMergerNode, whenConnected, whenDisconnected);\n    };\n};\n", "import { TGetFirstSampleFunction } from '../types';\n\nexport const getFirstSample: TGetFirstSampleFunction = (audioBuffer, buffer, channelNumber) => {\n    // Bug #5: Safari does not support copyFromChannel() and copyToChannel().\n    if (audioBuffer.copyFromChannel === undefined) {\n        return audioBuffer.getChannelData(channelNumber)[0];\n    }\n\n    audioBuffer.copyFromChannel(buffer, channelNumber);\n\n    return buffer[0];\n};\n", "import { TIsDCCurveFunction } from '../types';\n\nexport const isDCCurve: TIsDCCurveFunction = (curve) => {\n    if (curve === null) {\n        return false;\n    }\n\n    const length = curve.length;\n\n    if (length % 2 !== 0) {\n        return curve[Math.floor(length / 2)] !== 0;\n    }\n\n    return curve[length / 2 - 1] + curve[length / 2] !== 0;\n};\n", "import { TOverwriteAccessorsFunction } from '../types';\n\nexport const overwriteAccessors: TOverwriteAccessorsFunction = (object, property, createGetter, createSetter) => {\n    let prototype = object;\n\n    while (!prototype.hasOwnProperty(property)) {\n        prototype = Object.getPrototypeOf(prototype);\n    }\n\n    const { get, set } = <Required<PropertyDescriptor>>Object.getOwnPropertyDescriptor(prototype, property);\n\n    Object.defineProperty(object, property, { get: createGetter(get), set: createSetter(set) });\n};\n", "import { TSanitizeAudioWorkletNodeOptionsFunction } from '../types';\n\nexport const sanitizeAudioWorkletNodeOptions: TSanitizeAudioWorkletNodeOptionsFunction = (options) => {\n    return {\n        ...options,\n        outputChannelCount:\n            options.outputChannelCount !== undefined\n                ? options.outputChannelCount\n                : options.numberOfInputs === 1 && options.numberOfOutputs === 1\n                ? /*\n                   * Bug #61: This should be the computedNumberOfChannels, but unfortunately that is almost impossible to fake. That's why\n                   * the channelCountMode is required to be 'explicit' as long as there is not a native implementation in every browser. That\n                   * makes sure the computedNumberOfChannels is equivilant to the channelCount which makes it much easier to compute.\n                   */\n                  [options.channelCount]\n                : Array.from({ length: options.numberOfOutputs }, () => 1)\n    };\n};\n", "import { TSanitizeChannelSplitterOptionsFunction } from '../types';\n\nexport const sanitizeChannelSplitterOptions: TSanitizeChannelSplitterOptionsFunction = (options) => {\n    return { ...options, channelCount: options.numberOfOutputs };\n};\n", "import { TSanitizePeriodicWaveOptionsFunction } from '../types';\n\nexport const sanitizePeriodicWaveOptions: TSanitizePeriodicWaveOptionsFunction = (options) => {\n    const { imag, real } = options;\n\n    if (imag === undefined) {\n        if (real === undefined) {\n            return { ...options, imag: [0, 0], real: [0, 0] };\n        }\n\n        return { ...options, imag: Array.from(real, () => 0), real };\n    }\n\n    if (real === undefined) {\n        return { ...options, imag, real: Array.from(imag, () => 0) };\n    }\n\n    return { ...options, imag, real };\n};\n", "import { TSetValueAtTimeUntilPossibleFunction } from '../types';\n\nexport const setValueAtTimeUntilPossible: TSetValueAtTimeUntilPossibleFunction = (audioParam, value, startTime) => {\n    try {\n        audioParam.setValueAtTime(value, startTime);\n    } catch (err) {\n        if (err.code !== 9) {\n            throw err;\n        }\n\n        setValueAtTimeUntilPossible(audioParam, value, startTime + 1e-7);\n    }\n};\n", "import { TNativeContext } from '../types';\n\nexport const testAudioBufferSourceNodeStartMethodConsecutiveCallsSupport = (nativeContext: TNativeContext) => {\n    const nativeAudioBufferSourceNode = nativeContext.createBufferSource();\n\n    nativeAudioBufferSourceNode.start();\n\n    try {\n        nativeAudioBufferSourceNode.start();\n    } catch {\n        return true;\n    }\n\n    return false;\n};\n", "import { TNativeContext } from '../types';\n\nexport const testAudioBufferSourceNodeStartMethodOffsetClampingSupport = (nativeContext: TNativeContext) => {\n    const nativeAudioBufferSourceNode = nativeContext.createBufferSource();\n    const nativeAudioBuffer = nativeContext.createBuffer(1, 1, 44100);\n\n    nativeAudioBufferSourceNode.buffer = nativeAudioBuffer;\n\n    try {\n        nativeAudioBufferSourceNode.start(0, 1);\n    } catch {\n        return false;\n    }\n\n    return true;\n};\n", "import { TNativeContext } from '../types';\n\nexport const testAudioBufferSourceNodeStopMethodNullifiedBufferSupport = (nativeContext: TNativeContext) => {\n    const nativeAudioBufferSourceNode = nativeContext.createBufferSource();\n\n    nativeAudioBufferSourceNode.start();\n\n    try {\n        nativeAudioBufferSourceNode.stop();\n    } catch {\n        return false;\n    }\n\n    return true;\n};\n", "import { TNativeContext } from '../types';\n\nexport const testAudioScheduledSourceNodeStartMethodNegativeParametersSupport = (nativeContext: TNativeContext) => {\n    const nativeAudioBufferSourceNode = nativeContext.createOscillator();\n\n    try {\n        nativeAudioBufferSourceNode.start(-1);\n    } catch (err) {\n        return err instanceof RangeError;\n    }\n\n    return false;\n};\n", "import { TNativeContext } from '../types';\n\nexport const testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport = (nativeContext: TNativeContext) => {\n    const nativeAudioBuffer = nativeContext.createBuffer(1, 1, 44100);\n    const nativeAudioBufferSourceNode = nativeContext.createBufferSource();\n\n    nativeAudioBufferSourceNode.buffer = nativeAudioBuffer;\n    nativeAudioBufferSourceNode.start();\n    nativeAudioBufferSourceNode.stop();\n\n    try {\n        nativeAudioBufferSourceNode.stop();\n\n        return true;\n    } catch {\n        return false;\n    }\n};\n", "import { TNativeContext } from '../types';\n\nexport const testAudioScheduledSourceNodeStopMethodNegativeParametersSupport = (nativeContext: TNativeContext) => {\n    const nativeAudioBufferSourceNode = nativeContext.createOscillator();\n\n    try {\n        nativeAudioBufferSourceNode.stop(-1);\n    } catch (err) {\n        return err instanceof RangeError;\n    }\n\n    return false;\n};\n", "import { TTestAudioWorkletNodeOptionsClonabilityFunction } from '../types';\n\nexport const testAudioWorkletNodeOptionsClonability: TTestAudioWorkletNodeOptionsClonabilityFunction = (audioWorkletNodeOptions) => {\n    const { port1, port2 } = new MessageChannel();\n\n    try {\n        // This will throw an error if the audioWorkletNodeOptions are not clonable.\n        port1.postMessage(audioWorkletNodeOptions);\n    } finally {\n        port1.close();\n        port2.close();\n    }\n};\n", "import { TNativeAudioBufferSourceNode } from '../types';\n\nexport const wrapAudioBufferSourceNodeStartMethodOffsetClamping = (nativeAudioBufferSourceNode: TNativeAudioBufferSourceNode): void => {\n    nativeAudioBufferSourceNode.start = ((start) => {\n        return (when = 0, offset = 0, duration?: number) => {\n            const buffer = nativeAudioBufferSourceNode.buffer;\n            // Bug #154: Safari does not clamp the offset if it is equal to or greater than the duration of the buffer.\n            const clampedOffset = buffer === null ? offset : Math.min(buffer.duration, offset);\n\n            // Bug #155: Safari does not handle the offset correctly if it would cause the buffer to be not be played at all.\n            if (buffer !== null && clampedOffset > buffer.duration - 0.5 / nativeAudioBufferSourceNode.context.sampleRate) {\n                start.call(nativeAudioBufferSourceNode, when, 0, 0);\n            } else {\n                start.call(nativeAudioBufferSourceNode, when, clampedOffset, duration);\n            }\n        };\n    })(nativeAudioBufferSourceNode.start);\n};\n", "import { TNativeAudioNode, TWrapAudioScheduledSourceNodeStopMethodConsecutiveCallsFunction } from '../types';\nimport { interceptConnections } from './intercept-connections';\n\nexport const wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls: TWrapAudioScheduledSourceNodeStopMethodConsecutiveCallsFunction = (\n    nativeAudioScheduledSourceNode,\n    nativeContext\n) => {\n    const nativeGainNode = nativeContext.createGain();\n\n    nativeAudioScheduledSourceNode.connect(nativeGainNode);\n\n    const disconnectGainNode = ((disconnect) => {\n        return () => {\n            // @todo TypeScript cannot infer the overloaded signature with 1 argument yet.\n            (<(destinaton: TNativeAudioNode) => void>disconnect).call(nativeAudioScheduledSourceNode, nativeGainNode);\n            nativeAudioScheduledSourceNode.removeEventListener('ended', disconnectGainNode);\n        };\n    })(nativeAudioScheduledSourceNode.disconnect);\n\n    nativeAudioScheduledSourceNode.addEventListener('ended', disconnectGainNode);\n\n    interceptConnections(nativeAudioScheduledSourceNode, nativeGainNode);\n\n    nativeAudioScheduledSourceNode.stop = ((stop) => {\n        let isStopped = false;\n\n        return (when = 0) => {\n            if (isStopped) {\n                try {\n                    stop.call(nativeAudioScheduledSourceNode, when);\n                } catch {\n                    nativeGainNode.gain.setValueAtTime(0, when);\n                }\n            } else {\n                stop.call(nativeAudioScheduledSourceNode, when);\n\n                isStopped = true;\n            }\n        };\n    })(nativeAudioScheduledSourceNode.stop);\n};\n", "import { TWrapEventListenerFunction } from '../types';\n\nexport const wrapEventListener: TWrapEventListenerFunction = (target, eventListener) => {\n    return (event) => {\n        const descriptor = { value: target };\n\n        Object.defineProperties(event, {\n            currentTarget: descriptor,\n            target: descriptor\n        });\n\n        if (typeof eventListener === 'function') {\n            return eventListener.call(target, event);\n        }\n\n        return eventListener.handleEvent.call(target, event);\n    };\n};\n", "import { OfflineAudioContext } from 'standardized-audio-context';\n\nexport const render = (audioBuffer: AudioBuffer, offset: number, duration: number) => {\n    const offlineAudioContext = new OfflineAudioContext(\n        audioBuffer.numberOfChannels,\n        Math.round(duration * audioBuffer.sampleRate),\n        audioBuffer.sampleRate\n    );\n    const biquadFilter = offlineAudioContext.createBiquadFilter();\n    const bufferSourceNode = offlineAudioContext.createBufferSource();\n\n    biquadFilter.frequency.value = 240;\n    biquadFilter.type = 'lowpass';\n\n    bufferSourceNode.buffer = audioBuffer;\n\n    bufferSourceNode.connect(biquadFilter).connect(offlineAudioContext.destination);\n\n    bufferSourceNode.start(0, offset, duration);\n\n    return offlineAudioContext.startRendering().then((renderedBuffer) => {\n        const channelData = renderedBuffer.getChannelData(0);\n        const sampleRate = renderedBuffer.sampleRate;\n\n        return { channelData, sampleRate };\n    });\n};\n", "export const createLoadOrReturnBroker = <Broker>(loadBroker: (url: string) => Broker, worker: string) => {\n    let broker: null | Broker = null;\n\n    return () => {\n        if (broker !== null) {\n            return broker;\n        }\n\n        const blob = new Blob([worker], { type: 'application/javascript; charset=utf-8' });\n        const url = URL.createObjectURL(blob);\n\n        broker = loadBroker(url);\n\n        // Bug #1: Edge up until v18 didn't like the URL to be revoked directly.\n        setTimeout(() => URL.revokeObjectURL(url));\n\n        return broker;\n    };\n};\n", "// This is the minified and stringified code of the web-audio-beat-detector-worker package.\nexport const worker = `(()=>{\"use strict\";const e=(e,t,o)=>{const s=e.length,n=[];let a=!1;for(let r=0;r<s;r+=1)e[r]>t?a=!0:a&&(a=!1,n.push(r-1),r+=o/4-1);return a&&n.push(s-1),n},t=(t,o,s)=>{const n=(e=>{let t=0;const o=e.length;for(let s=0;s<o;s+=1)e[s]>t&&(t=e[s]);return t})(t),a=.3*n;let r=[],l=n-.05*n;if(n>.25)for(;r.length<30&&l>=a;)r=e(t,l,o),l-=.05*n;const p=(e=>{const t=[];return e.forEach(((o,s)=>{const n=Math.min(e.length-s,10);for(let a=1;a<n;a+=1){const n=e[s+a]-o;t.some((e=>e.interval===n&&(e.peaks.push(o),!0)))||t.push({interval:n,peaks:[o]})}})),t})(r),h=function(e,t){let o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};var s,n;const a=Math.max(0,null!==(s=o.minTempo)&&void 0!==s?s:90),r=Math.max(0,null!==(n=o.maxTempo)&&void 0!==n?n:180),l=[];return e.forEach((e=>{let o=60/(e.interval/t);for(;o<a;)o*=2;for(;o>r;)o/=2;let s=!1,n=e.peaks.length;l.forEach((t=>{if(t.tempo===o&&(t.score+=e.peaks.length,t.peaks=[...t.peaks,...e.peaks],s=!0),t.tempo>o-.5&&t.tempo<o+.5){const s=2*Math.abs(t.tempo-o);n+=(1-s)*t.peaks.length,t.score+=(1-s)*e.peaks.length}})),s||l.push({peaks:e.peaks,score:n,tempo:o})})),l}(p,o,s);return h.sort(((e,t)=>t.score-e.score)),h};addEventListener(\"message\",(e=>{let{data:o}=e;try{if(\"analyze\"===o.method){const{id:e,params:{channelData:s,sampleRate:n,tempoSettings:a}}=o,r=((e,o,s)=>{const n=t(e,o,s);if(0===n.length)throw new Error(\"The given channelData does not contain any detectable beats.\");return n[0].tempo})(s,n,a);postMessage({error:null,id:e,result:{tempo:r}})}else{if(\"guess\"!==o.method)throw new Error('The given method \"'.concat(o.method,'\" is not supported'));{const{id:e,params:{channelData:s,sampleRate:n,tempoSettings:a}}=o,{bpm:r,offset:l,tempo:p}=((e,o,s)=>{const n=t(e,o,s);if(0===n.length)throw new Error(\"The given channelData does not contain any detectable beats.\");const{peaks:a,tempo:r}=n[0],l=Math.round(r),p=60/l;a.sort(((e,t)=>e-t));let h=a[0]/o;for(;h>p;)h-=p;return{bpm:l,offset:h,tempo:r}})(s,n,a);postMessage({error:null,id:e,result:{bpm:r,offset:l,tempo:p}})}}}catch(e){postMessage({error:{message:e.message},id:o.id,result:null})}}))})();`; // tslint:disable-line:max-line-length\n", "import { load } from 'web-audio-beat-detector-broker';\nimport { createLoadOrReturnBroker } from './factories/load-or-return-broker';\nimport { worker } from './worker/worker';\n\nconst loadOrReturnBroker = createLoadOrReturnBroker(load, worker);\n\nexport const analyze: ReturnType<typeof load>['analyze'] = (...args) => loadOrReturnBroker().analyze(...args);\n\nexport const guess: ReturnType<typeof load>['guess'] = (...args) => loadOrReturnBroker().guess(...args);\n", "export class TabRecorder {\n    mediaRecorder: MediaRecorder | null = null;\n    chunks: any[] = [];\n    isRecording: boolean = false;\n\n    constructor() {}\n\n    async startRecording() {\n        if (this.isRecording) {\n            console.warn(\"Recording is already in progress.\");\n            return;\n        }\n\n        try {\n            const stream = document.querySelector('canvas')!.captureStream(45);\n            this.chunks = [];\n            this.mediaRecorder = new MediaRecorder(stream, { mimeType: 'video/webm; codecs=vp9' });\n\n            this.mediaRecorder.ondataavailable = event => {\n                if (event.data.size > 0) {\n                    this.chunks.push(event.data);\n                }\n            };\n\n            this.mediaRecorder.start(1000);\n            this.isRecording = true;\n            console.log(\"Recording started.\");\n        } catch (error) {\n            console.error(\"Error starting recording:\", error);\n        }\n    }\n\n    stopRecording() {\n        if (!this.isRecording) {\n            console.warn(\"No recording in progress to stop.\");\n            return;\n        }\n\n        this.mediaRecorder!.stop();\n        this.isRecording = false;\n        console.log(\"Recording stopped.\");\n    }\n\n    saveRecording() {\n        const blob = new Blob(this.chunks, { type: 'video/webm' });\n        const url = URL.createObjectURL(blob);\n        const a = document.createElement('a');\n        a.href = url;\n        a.download = 'recording.webm';\n        document.body.appendChild(a);\n        a.click();\n        document.body.removeChild(a);\n        URL.revokeObjectURL(url);\n        console.log(\"Recording saved.\");\n    }\n}\n\nexport class TabClipper {\n    recorders: TabRecorder[] = [];\n\n    constructor() {}\n\n    startCapturing() {\n        this.recorders = [];\n        this.recorders.push(new TabRecorder());\n        this.recorders[0].startRecording();\n\n        setInterval(() => {\n            this.addRecorder();\n        }, 10000);\n    }\n\n    addRecorder() {\n        let index = this.recorders.push(new TabRecorder()) - 1;\n        this.recorders.at(index)?.startRecording();\n\n        setTimeout(() => {\n            this.recorders.at(index)?.stopRecording();\n            this.recorders.splice(index, 1);\n        }, 30000);\n    }\n\n    stopCapturing() {\n        for (let recorder of this.recorders) {\n            recorder.stopRecording();\n        }\n    }\n\n    saveClip() {\n        this.recorders.at(0)?.saveRecording();\n    }\n}", "import './events';\n\nimport ws from './ws';\nimport { guess } from 'web-audio-beat-detector';\nimport { TabClipper } from './clip';\n\ndeclare const window: Global & typeof globalThis;\ndeclare const c3_runtimeInterface: C3_runtimeInterface;\n\nconst menu: ModMenu = {\n    multiplayer: false,\n    opponent: \"\",\n    get players() {\n        return window.players;\n    },\n    get heads() {\n        return window.heads;\n    },\n    get ball() {\n        return window.ball;\n    },\n    get globalVars() {\n        return window.globalVars;\n    },\n    getBeat: guess,\n    clipper: new TabClipper(),\n    practicePlayer: 4,\n    giveBall(body) {\n        var ball = c3_runtimeInterface._localRuntime._iRuntime.objects.balls.getAllInstances()[0];\n    \n        ball.instVars.hold = 1;\n        ball.instVars.who = body;\n    },\n    dropBall() {\n        var ball = c3_runtimeInterface._localRuntime._iRuntime.objects.balls.getAllInstances()[0];\n    \n        ball.instVars.hold = 0;\n        ball.instVars.who = -1;\n    }\n}\n\nObject.defineProperties(window, {\n    \"ball\": {\n        get: () => c3_runtimeInterface._localRuntime._iRuntime.objects.balls.getAllInstances()[0],\n    },\n    \"players\": {\n        get: () => [\n            c3_runtimeInterface._localRuntime._iRuntime.objects.body.getAllInstances()[0],\n            c3_runtimeInterface._localRuntime._iRuntime.objects.body2.getAllInstances()[0],\n            c3_runtimeInterface._localRuntime._iRuntime.objects.body3.getAllInstances()[0],\n            c3_runtimeInterface._localRuntime._iRuntime.objects.body4.getAllInstances()[0],\n        ],\n    },\n    \"heads\": {\n        get: () => [\n            c3_runtimeInterface._localRuntime._iRuntime.objects.head.getAllInstances()[0],\n            c3_runtimeInterface._localRuntime._iRuntime.objects.head2.getAllInstances()[0],\n            c3_runtimeInterface._localRuntime._iRuntime.objects.head3.getAllInstances()[0],\n            c3_runtimeInterface._localRuntime._iRuntime.objects.head4.getAllInstances()[0],\n        ],\n    },\n    \"globalVars\": {\n        get: () => c3_runtimeInterface._localRuntime._iRuntime.globalVars,\n    }\n});\n\nws(menu);"],
  "mappings": "0qBAAA,IAAAA,GAAAC,GAAA,CAAAC,GAAAC,KAAA,EAAC,SAAUC,EAAQC,EAAS,CACxB,OAAOH,IAAY,UAAY,OAAOC,GAAW,IAAcE,EAAQH,EAAO,EAC9E,OAAO,QAAW,YAAc,OAAO,IAAM,OAAO,CAAC,SAAS,EAAGG,CAAO,GACvED,EAAS,OAAO,WAAe,IAAc,WAAaA,GAAU,KAAMC,EAAQD,EAAO,kBAAoB,CAAC,CAAC,EACpH,GAAGF,GAAO,SAAUA,EAAS,CAAE,aAE3B,IAAII,EAAwB,SAA+BC,EAAsB,CAC/E,OAAO,SAAUC,EAAK,CACpB,IAAIC,EAASF,EAAqBC,CAAG,EACrC,OAAAA,EAAI,IAAIC,CAAM,EACPA,CACT,CACF,EAEIC,EAAc,SAAqBC,EAAmB,CACxD,OAAO,SAAUC,EAAYC,EAAY,CACvC,OAAAF,EAAkB,IAAIC,EAAYC,CAAU,EACrCA,CACT,CACF,EAMIC,EAAmB,OAAO,mBAAqB,OAAY,iBAAmB,OAAO,iBACrFC,EAAkC,UAClCC,EAA6BD,EAAkC,EAC/DE,EAA6B,SAAoCC,EAAOP,EAAmB,CAC7F,OAAO,SAAUC,EAAY,CAC3B,IAAIO,EAAaR,EAAkB,IAAIC,CAAU,EAS7CC,EAAaM,IAAe,OAAYP,EAAW,KAAOO,EAAaH,EAA6BG,EAAa,EAAI,EACzH,GAAI,CAACP,EAAW,IAAIC,CAAU,EAC5B,OAAOK,EAAMN,EAAYC,CAAU,EAQrC,GAAID,EAAW,KAAOG,EAAiC,CACrD,KAAOH,EAAW,IAAIC,CAAU,GAC9BA,EAAa,KAAK,MAAM,KAAK,OAAO,EAAIG,CAA0B,EAEpE,OAAOE,EAAMN,EAAYC,CAAU,CACrC,CAEA,GAAID,EAAW,KAAOE,EACpB,MAAM,IAAI,MAAM,gGAAgG,EAGlH,KAAOF,EAAW,IAAIC,CAAU,GAC9BA,EAAa,KAAK,MAAM,KAAK,OAAO,EAAIC,CAAgB,EAE1D,OAAOI,EAAMN,EAAYC,CAAU,CACrC,CACF,EAEIO,EAAuB,IAAI,QAC3BF,EAAQR,EAAYU,CAAoB,EACxCb,EAAuBU,EAA2BC,EAAOE,CAAoB,EAC7EC,EAAkBf,EAAsBC,CAAoB,EAEhEL,EAAQ,gBAAkBmB,EAC1BnB,EAAQ,qBAAuBK,CAEnC,CAAE,IC3EF,IAAAe,GAAAC,GAAA,CAAAC,GAAAC,KAAA,UAASC,GAAgBC,EAAK,CAC5B,GAAI,MAAM,QAAQA,CAAG,EAAG,OAAOA,CACjC,CACAF,GAAO,QAAUC,GAAiBD,GAAO,QAAQ,WAAa,GAAMA,GAAO,QAAQ,QAAaA,GAAO,UCHvG,IAAAG,GAAAC,GAAA,CAAAC,GAAAC,KAAA,UAASC,GAAsBC,EAAGC,EAAG,CACnC,IAAIC,EAAYF,GAAR,KAAY,KAAsB,OAAO,OAAtB,KAAgCA,EAAE,OAAO,QAAQ,GAAKA,EAAE,YAAY,EAC/F,GAAYE,GAAR,KAAW,CACb,IAAIC,EACFC,EACAC,EACA,EACAC,EAAI,CAAC,EACLC,EAAI,GACJC,EAAI,GACN,GAAI,CACF,GAAIH,GAAKH,EAAIA,EAAE,KAAKF,CAAC,GAAG,KAAYC,IAAN,EAAS,CACrC,GAAI,OAAOC,CAAC,IAAMA,EAAG,OACrBK,EAAI,EACN,KAAO,MAAO,EAAEA,GAAKJ,EAAIE,EAAE,KAAKH,CAAC,GAAG,QAAUI,EAAE,KAAKH,EAAE,KAAK,EAAGG,EAAE,SAAWL,GAAIM,EAAI,GAAG,CACzF,OAASP,EAAG,CACVQ,EAAI,GAAIJ,EAAIJ,CACd,QAAE,CACA,GAAI,CACF,GAAI,CAACO,GAAaL,EAAE,QAAV,OAAwB,EAAIA,EAAE,OAAU,EAAG,OAAO,CAAC,IAAM,GAAI,MACzE,QAAE,CACA,GAAIM,EAAG,MAAMJ,CACf,CACF,CACA,OAAOE,CACT,CACF,CACAR,GAAO,QAAUC,GAAuBD,GAAO,QAAQ,WAAa,GAAMA,GAAO,QAAQ,QAAaA,GAAO,UC3B7G,IAAAW,GAAAC,GAAA,CAAAC,GAAAC,KAAA,UAASC,GAAkBC,EAAKC,EAAK,EAC/BA,GAAO,MAAQA,EAAMD,EAAI,UAAQC,EAAMD,EAAI,QAC/C,QAASE,EAAI,EAAGC,EAAO,IAAI,MAAMF,CAAG,EAAGC,EAAID,EAAKC,IAAKC,EAAKD,CAAC,EAAIF,EAAIE,CAAC,EACpE,OAAOC,CACT,CACAL,GAAO,QAAUC,GAAmBD,GAAO,QAAQ,WAAa,GAAMA,GAAO,QAAQ,QAAaA,GAAO,UCLzG,IAAAM,GAAAC,GAAA,CAAAC,GAAAC,KAAA,KAAIC,GAAmB,KACvB,SAASC,GAA4BC,EAAGC,EAAQ,CAC9C,GAAKD,EACL,IAAI,OAAOA,GAAM,SAAU,OAAOF,GAAiBE,EAAGC,CAAM,EAC5D,IAAIC,EAAI,OAAO,UAAU,SAAS,KAAKF,CAAC,EAAE,MAAM,EAAG,EAAE,EAErD,GADIE,IAAM,UAAYF,EAAE,cAAaE,EAAIF,EAAE,YAAY,MACnDE,IAAM,OAASA,IAAM,MAAO,OAAO,MAAM,KAAKF,CAAC,EACnD,GAAIE,IAAM,aAAe,2CAA2C,KAAKA,CAAC,EAAG,OAAOJ,GAAiBE,EAAGC,CAAM,EAChH,CACAJ,GAAO,QAAUE,GAA6BF,GAAO,QAAQ,WAAa,GAAMA,GAAO,QAAQ,QAAaA,GAAO,UCTnH,IAAAM,GAAAC,GAAA,CAAAC,GAAAC,KAAA,UAASC,IAAmB,CAC1B,MAAM,IAAI,UAAU;AAAA,mFAA2I,CACjK,CACAD,GAAO,QAAUC,GAAkBD,GAAO,QAAQ,WAAa,GAAMA,GAAO,QAAQ,QAAaA,GAAO,UCHxG,IAAAE,GAAAC,GAAA,CAAAC,GAAAC,KAAA,KAAIC,GAAiB,KACjBC,GAAuB,KACvBC,GAA6B,KAC7BC,GAAkB,KACtB,SAASC,GAAeC,EAAKC,EAAG,CAC9B,OAAON,GAAeK,CAAG,GAAKJ,GAAqBI,EAAKC,CAAC,GAAKJ,GAA2BG,EAAKC,CAAC,GAAKH,GAAgB,CACtH,CACAJ,GAAO,QAAUK,GAAgBL,GAAO,QAAQ,WAAa,GAAMA,GAAO,QAAQ,QAAaA,GAAO,UCPtG,IAAAQ,GAAAC,GAAA,CAAAC,GAAAC,KAAA,UAASC,GAAgBC,EAAUC,EAAa,CAC9C,GAAI,EAAED,aAAoBC,GACxB,MAAM,IAAI,UAAU,mCAAmC,CAE3D,CACAH,GAAO,QAAUC,GAAiBD,GAAO,QAAQ,WAAa,GAAMA,GAAO,QAAQ,QAAaA,GAAO,UCLvG,IAAAI,GAAAC,GAAA,CAAAC,GAAAC,KAAA,UAASC,GAAQC,EAAG,CAClB,0BAEA,OAAQF,GAAO,QAAUC,GAAwB,OAAO,QAArB,YAA2C,OAAO,OAAO,UAA1B,SAAqC,SAAUC,EAAG,CAClH,OAAO,OAAOA,CAChB,EAAI,SAAUA,EAAG,CACf,OAAOA,GAAmB,OAAO,QAArB,YAA+BA,EAAE,cAAgB,QAAUA,IAAM,OAAO,UAAY,SAAW,OAAOA,CACpH,EAAGF,GAAO,QAAQ,WAAa,GAAMA,GAAO,QAAQ,QAAaA,GAAO,QAAUC,GAAQC,CAAC,CAC7F,CACAF,GAAO,QAAUC,GAASD,GAAO,QAAQ,WAAa,GAAMA,GAAO,QAAQ,QAAaA,GAAO,UCT/F,IAAAG,GAAAC,GAAA,CAAAC,GAAAC,KAAA,KAAIC,GAAU,KAAuB,QACrC,SAASC,GAAYC,EAAGC,EAAG,CACzB,GAAgBH,GAAQE,CAAC,GAArB,UAA0B,CAACA,EAAG,OAAOA,EACzC,IAAIE,EAAIF,EAAE,OAAO,WAAW,EAC5B,GAAeE,IAAX,OAAc,CAChB,IAAIC,EAAID,EAAE,KAAKF,EAAGC,GAAK,SAAS,EAChC,GAAgBH,GAAQK,CAAC,GAArB,SAAwB,OAAOA,EACnC,MAAM,IAAI,UAAU,8CAA8C,CACpE,CACA,OAAqBF,IAAb,SAAiB,OAAS,QAAQD,CAAC,CAC7C,CACAH,GAAO,QAAUE,GAAaF,GAAO,QAAQ,WAAa,GAAMA,GAAO,QAAQ,QAAaA,GAAO,UCXnG,IAAAO,GAAAC,GAAA,CAAAC,GAAAC,KAAA,KAAIC,GAAU,KAAuB,QACjCC,GAAc,KAClB,SAASC,GAAcC,EAAG,CACxB,IAAIC,EAAIH,GAAYE,EAAG,QAAQ,EAC/B,OAAmBH,GAAQI,CAAC,GAArB,SAAyBA,EAAI,OAAOA,CAAC,CAC9C,CACAL,GAAO,QAAUG,GAAeH,GAAO,QAAQ,WAAa,GAAMA,GAAO,QAAQ,QAAaA,GAAO,UCNrG,IAAAM,GAAAC,GAAA,CAAAC,GAAAC,KAAA,KAAIC,GAAgB,KACpB,SAASC,GAAkBC,EAAQC,EAAO,CACxC,QAASC,EAAI,EAAGA,EAAID,EAAM,OAAQC,IAAK,CACrC,IAAIC,EAAaF,EAAMC,CAAC,EACxBC,EAAW,WAAaA,EAAW,YAAc,GACjDA,EAAW,aAAe,GACtB,UAAWA,IAAYA,EAAW,SAAW,IACjD,OAAO,eAAeH,EAAQF,GAAcK,EAAW,GAAG,EAAGA,CAAU,CACzE,CACF,CACA,SAASC,GAAaC,EAAaC,EAAYC,EAAa,CAC1D,OAAID,GAAYP,GAAkBM,EAAY,UAAWC,CAAU,EAC/DC,GAAaR,GAAkBM,EAAaE,CAAW,EAC3D,OAAO,eAAeF,EAAa,YAAa,CAC9C,SAAU,EACZ,CAAC,EACMA,CACT,CACAR,GAAO,QAAUO,GAAcP,GAAO,QAAQ,WAAa,GAAMA,GAAO,QAAQ,QAAaA,GAAO,UClBpG,IAAAW,GAAAC,GAAA,CAAAC,GAAAC,KAAA,EAAC,SAAUC,EAAQC,EAAS,CACxB,OAAOH,IAAY,UAAY,OAAOC,GAAW,IAAcE,EAAQH,GAAS,KAAiD,KAAkD,IAA6C,EAChO,OAAO,QAAW,YAAc,OAAO,IAAM,OAAO,CAAC,UAAW,uCAAwC,wCAAyC,oCAAoC,EAAGG,CAAO,GAC9LD,EAAS,OAAO,WAAe,IAAc,WAAaA,GAAU,KAAMC,EAAQD,EAAO,iBAAmB,CAAC,EAAGA,EAAO,eAAgBA,EAAO,gBAAiBA,EAAO,YAAY,EACvL,GAAGF,GAAO,SAAUA,EAASI,EAAgBC,EAAiBC,EAAc,CAAE,aAE1E,IAAIC,EAAsD,SAA6DC,EAAOC,EAASC,EAAY,CACjJ,MAAO,CACL,QAASD,EACT,WAAYC,EACZ,KAAM,yBACN,MAAOF,CACT,CACF,EAEIG,EAAiD,SAAwDH,EAAOC,EAASC,EAAY,CACvI,MAAO,CACL,QAASD,EACT,WAAYC,EACZ,KAAM,oBACN,MAAOF,CACT,CACF,EAEII,EAAgC,SAAuCJ,EAAOK,EAAW,CAC3F,MAAO,CACL,UAAWA,EACX,KAAM,WACN,MAAOL,CACT,CACF,EAEIM,EAAqC,SAA4CC,EAAQF,EAAWG,EAAU,CAChH,MAAO,CACL,SAAUA,EACV,UAAWH,EACX,KAAM,gBACN,OAAQE,CACV,CACF,EAEIE,EAAuB,SAA8BC,EAAMC,EAAkBC,EAAM,CACrF,IAAIP,EAAYO,EAAK,UACnBC,EAASD,EAAK,OACdE,EAAeF,EAAK,aACtB,OAAOC,GAAUF,EAAmBE,GAAU,KAAK,KAAKR,EAAYK,GAAQI,CAAY,CAC1F,EAEIC,EAA0C,SAAiDC,EAAiB,CAC9G,OAAOA,EAAgB,OAAS,wBAClC,EAEIC,EAAqC,SAA4CD,EAAiB,CACpG,OAAOA,EAAgB,OAAS,mBAClC,EAEIE,EAAkC,SAAyCF,EAAiB,CAC9F,OAAOD,EAAwCC,CAAe,GAAKC,EAAmCD,CAAe,CACvH,EAEIG,EAA4B,SAAmCH,EAAiB,CAClF,OAAOA,EAAgB,OAAS,UAClC,EAEII,EAAiC,SAAwCJ,EAAiB,CAC5F,OAAOA,EAAgB,OAAS,eAClC,EAEIK,EAAyC,SAASA,EAAuCC,EAAkBC,EAAOb,EAAMc,EAAc,CACxI,IAAIR,EAAkBM,EAAiBC,CAAK,EAC5C,OAAOP,IAAoB,OAAYQ,EAAeN,EAAgCF,CAAe,GAAKG,EAA0BH,CAAe,EAAIA,EAAgB,MAAQI,EAA+BJ,CAAe,EAAIA,EAAgB,OAAOA,EAAgB,OAAO,OAAS,CAAC,EAAIP,EAAqBC,EAAMW,EAAuCC,EAAkBC,EAAQ,EAAGP,EAAgB,UAAWQ,CAAY,EAAGR,CAAe,CACvb,EAEIS,EAA8C,SAAqDH,EAAkBC,EAAOG,EAAwBC,EAAqBH,EAAc,CACzL,OAAOE,IAA2B,OAAY,CAACC,EAAoB,WAAYH,CAAY,EAAIN,EAAgCQ,CAAsB,EAAI,CAACA,EAAuB,QAASA,EAAuB,KAAK,EAAIP,EAA0BO,CAAsB,EAAI,CAACA,EAAuB,UAAWA,EAAuB,KAAK,EAAIN,EAA+BM,CAAsB,EAAI,CAACA,EAAuB,UAAYA,EAAuB,SAAUA,EAAuB,OAAOA,EAAuB,OAAO,OAAS,CAAC,CAAC,EAAI,CAACA,EAAuB,UAAWL,EAAuCC,EAAkBC,EAAQ,EAAGG,EAAuB,UAAWF,CAAY,CAAC,CAClrB,EAEII,EAAiC,SAAwCZ,EAAiB,CAC5F,OAAOA,EAAgB,OAAS,eAClC,EAEIa,EAAyC,SAAgDb,EAAiB,CAC5G,OAAOA,EAAgB,OAAS,uBAClC,EAEIc,EAAe,SAAsBd,EAAiB,CACxD,OAAIY,EAA+BZ,CAAe,GAAKa,EAAuCb,CAAe,EACpGA,EAAgB,WAErBD,EAAwCC,CAAe,GAAKC,EAAmCD,CAAe,EACzGA,EAAgB,QAElBA,EAAgB,SACzB,EAEIe,EAAgC,SAAuCrB,EAAML,EAAWM,EAAkBC,EAAM,CAClH,IAAIX,EAAUW,EAAK,QACjBZ,EAAQY,EAAK,MACf,OAAID,IAAqBX,EAChBA,EAEL,EAAIW,GAAoB,EAAIX,GAASW,EAAmB,GAAKX,EAAQ,EAChEW,EAAmB,KAAK,IAAIX,EAAQW,GAAmBD,EAAOL,IAAcJ,EAAUI,EAAU,EAElG,CACT,EAEI2B,EAA2B,SAAkCtB,EAAML,EAAWM,EAAkBC,EAAM,CACxG,IAAIX,EAAUW,EAAK,QACjBZ,EAAQY,EAAK,MACf,OAAOD,GAAoBD,EAAOL,IAAcJ,EAAUI,IAAcL,EAAQW,EAClF,EAEIsB,EAAmB,SAA0B1B,EAAQ2B,EAAgB,CACvE,IAAIC,EAAa,KAAK,MAAMD,CAAc,EACtCE,EAAa,KAAK,KAAKF,CAAc,EACzC,OAAIC,IAAeC,EACV7B,EAAO4B,CAAU,GAElB,GAAKD,EAAiBC,IAAe5B,EAAO4B,CAAU,GAAK,GAAKC,EAAaF,IAAmB3B,EAAO6B,CAAU,CAC3H,EAEIC,EAA2B,SAAkC3B,EAAME,EAAM,CAC3E,IAAIJ,EAAWI,EAAK,SAClBP,EAAYO,EAAK,UACjBL,EAASK,EAAK,OACZsB,GAAkBxB,EAAOL,GAAaG,GAAYD,EAAO,OAAS,GACtE,OAAO0B,EAAiB1B,EAAQ2B,CAAc,CAChD,EAEII,EAA6B,SAAoCtB,EAAiB,CACpF,OAAOA,EAAgB,OAAS,WAClC,EAEIuB,EAAmC,SAAUC,EAAkB,CACjE,SAASD,EAAoBf,EAAc,CACzC3B,EAAgB,KAAM0C,CAAmB,EACzC,KAAK,kBAAoB,CAAC,EAC1B,KAAK,YAAc,EACnB,KAAK,cAAgBf,CACvB,CACA,OAAA1B,EAAayC,EAAqB,CAAC,CACjC,IAAKC,EACL,MAAO,UAAiB,CACtB,OAAO,KAAK,kBAAkB,OAAO,QAAQ,EAAE,CACjD,CACF,EAAG,CACD,IAAK,MACL,MAAO,SAAaxB,EAAiB,CACnC,IAAIyB,EAAYX,EAAad,CAAe,EAC5C,GAAIY,EAA+BZ,CAAe,GAAKa,EAAuCb,CAAe,EAAG,CAC9G,IAAIO,EAAQ,KAAK,kBAAkB,UAAU,SAAUG,EAAwB,CAC7E,OAAIG,EAAuCb,CAAe,GAAKI,EAA+BM,CAAsB,EAC3GA,EAAuB,UAAYA,EAAuB,UAAYe,EAExEX,EAAaJ,CAAsB,GAAKe,CACjD,CAAC,EACGC,EAAyB,KAAK,kBAAkBnB,CAAK,EAIzD,GAHIA,IAAU,KACZ,KAAK,kBAAoB,KAAK,kBAAkB,MAAM,EAAGA,CAAK,GAE5DK,EAA+BZ,CAAe,EAAG,CACnD,IAAI2B,EAAsB,KAAK,kBAAkB,KAAK,kBAAkB,OAAS,CAAC,EAClF,GAAID,IAA2B,QAAaxB,EAAgCwB,CAAsB,EAAG,CACnG,GAAIC,IAAwB,QAAaL,EAA2BK,CAAmB,EACrF,MAAM,IAAI,MAAM,iCAAiC,EAEnD,IAAItC,EAAYsC,IAAwB,OAAYD,EAAuB,WAAatB,EAA+BuB,CAAmB,EAAIA,EAAoB,UAAYA,EAAoB,SAAWb,EAAaa,CAAmB,EACzOC,GAAaD,IAAwB,OAAY,KAAK,cAAgBvB,EAA+BuB,CAAmB,EAAIA,EAAoB,OAAOA,EAAoB,OAAO,OAAS,CAAC,EAAIA,EAAoB,MACpN3C,GAAQe,EAAwC2B,CAAsB,EAAIX,EAA8BU,EAAWpC,EAAWuC,GAAYF,CAAsB,EAAIV,EAAyBS,EAAWpC,EAAWuC,GAAYF,CAAsB,EACrPG,EAA2B9B,EAAwC2B,CAAsB,EAAI3C,EAAoDC,GAAOyC,EAAW,KAAK,WAAW,EAAItC,EAA+CH,GAAOyC,EAAW,KAAK,WAAW,EAC5Q,KAAK,kBAAkB,KAAKI,CAAwB,CACtD,CAIA,GAHIF,IAAwB,QAAaL,EAA2BK,CAAmB,GACrF,KAAK,kBAAkB,KAAKvC,EAA8B,KAAK,SAASqC,CAAS,EAAGA,CAAS,CAAC,EAE5FE,IAAwB,QAAavB,EAA+BuB,CAAmB,GAAKA,EAAoB,UAAYA,EAAoB,SAAWF,EAAW,CACxK,IAAIjC,EAAWiC,EAAYE,EAAoB,UAC3CG,IAASH,EAAoB,OAAO,OAAS,GAAKA,EAAoB,SACtEI,EAAS,KAAK,IAAI,EAAG,EAAI,KAAK,KAAKvC,EAAWsC,EAAK,CAAC,EACpDE,GAAWxC,GAAYuC,EAAS,GAAKD,GACrCvC,GAASoC,EAAoB,OAAO,MAAM,EAAGI,CAAM,EACvD,GAAIC,GAAW,EACb,QAASC,GAAI,EAAGA,GAAIF,EAAQE,IAAK,EAAG,CAClC,IAAIC,GAASF,GAAWC,GAAI,EAC5B1C,GAAO0C,EAAC,EAAIN,EAAoB,OAAOM,GAAI,CAAC,GAAK,EAAIC,IAAUP,EAAoB,OAAOM,EAAC,EAAIC,EACjG,CAEF,KAAK,kBAAkB,KAAK,kBAAkB,OAAS,CAAC,EAAI5C,EAAmCC,GAAQoC,EAAoB,UAAWnC,CAAQ,CAChJ,CACF,CACF,KAAO,CACL,IAAI2C,GAAS,KAAK,kBAAkB,UAAU,SAAUzB,EAAwB,CAC9E,OAAOI,EAAaJ,CAAsB,EAAIe,CAChD,CAAC,EACGW,GAA0BD,KAAW,GAAK,KAAK,kBAAkB,KAAK,kBAAkB,OAAS,CAAC,EAAI,KAAK,kBAAkBA,GAAS,CAAC,EAC3I,GAAIC,KAA4B,QAAahC,EAA+BgC,EAAuB,GAAKtB,EAAasB,EAAuB,EAAIA,GAAwB,SAAWX,EACjL,MAAO,GAET,IAAIY,EAA4BtC,EAAwCC,CAAe,EAAIjB,EAAoDiB,EAAgB,MAAOA,EAAgB,QAAS,KAAK,WAAW,EAAIC,EAAmCD,CAAe,EAAIb,EAA+Ca,EAAgB,MAAOyB,EAAW,KAAK,WAAW,EAAIzB,EAC9W,GAAImC,KAAW,GACb,KAAK,kBAAkB,KAAKE,CAAyB,MAChD,CACL,GAAIjC,EAA+BJ,CAAe,GAAKyB,EAAYzB,EAAgB,SAAWc,EAAa,KAAK,kBAAkBqB,EAAM,CAAC,EACvI,MAAO,GAET,KAAK,kBAAkB,OAAOA,GAAQ,EAAGE,CAAyB,CACpE,CACF,CACA,MAAO,EACT,CACF,EAAG,CACD,IAAK,QACL,MAAO,SAAe3C,EAAM,CAC1B,IAAIa,EAAQ,KAAK,kBAAkB,UAAU,SAAUG,EAAwB,CAC7E,OAAOI,EAAaJ,CAAsB,EAAIhB,CAChD,CAAC,EACD,GAAIa,EAAQ,EAAG,CACb,IAAI+B,EAA4B,KAAK,kBAAkB,MAAM/B,EAAQ,CAAC,EAClEgC,EAAgCD,EAA0B,CAAC,EAC3DhB,EAA2BiB,CAA6B,GAC1DD,EAA0B,QAAQlD,EAA8BiB,EAAuC,KAAK,kBAAmBE,EAAQ,EAAGgC,EAA8B,UAAW,KAAK,aAAa,EAAGA,EAA8B,SAAS,CAAC,EAElP,KAAK,kBAAoBD,CAC3B,CACF,CACF,EAAG,CACD,IAAK,WACL,MAAO,SAAkB5C,EAAM,CAC7B,GAAI,KAAK,kBAAkB,SAAW,EACpC,OAAO,KAAK,cAEd,IAAI8C,EAAmB,KAAK,kBAAkB,UAAU,SAAUxC,GAAiB,CACjF,OAAOc,EAAad,EAAe,EAAIN,CACzC,CAAC,EACGiB,EAAsB,KAAK,kBAAkB6B,CAAgB,EAC7DC,GAAuBD,IAAqB,GAAK,KAAK,kBAAkB,OAASA,GAAoB,EACrG9B,EAAyB,KAAK,kBAAkB+B,CAAmB,EACvE,GAAI/B,IAA2B,QAAaY,EAA2BZ,CAAsB,IAAMC,IAAwB,QAAa,CAACT,EAAgCS,CAAmB,GAAKA,EAAoB,WAAajB,GAChO,OAAOD,EAAqBC,EAAMW,EAAuC,KAAK,kBAAmBoC,EAAsB,EAAG/B,EAAuB,UAAW,KAAK,aAAa,EAAGA,CAAsB,EAEzM,GAAIA,IAA2B,QAAaP,EAA0BO,CAAsB,IAAMC,IAAwB,QAAa,CAACT,EAAgCS,CAAmB,GACzL,OAAOD,EAAuB,MAEhC,GAAIA,IAA2B,QAAaN,EAA+BM,CAAsB,IAAMC,IAAwB,QAAa,CAACT,EAAgCS,CAAmB,GAAKD,EAAuB,UAAYA,EAAuB,SAAWhB,GACxQ,OAAIA,EAAOgB,EAAuB,UAAYA,EAAuB,SAC5DW,EAAyB3B,EAAMgB,CAAsB,EAEvDA,EAAuB,OAAOA,EAAuB,OAAO,OAAS,CAAC,EAE/E,GAAIA,IAA2B,QAAaR,EAAgCQ,CAAsB,IAAMC,IAAwB,QAAa,CAACT,EAAgCS,CAAmB,GAC/L,OAAOD,EAAuB,MAEhC,GAAIC,IAAwB,QAAaZ,EAAwCY,CAAmB,EAAG,CACrG,IAAI+B,EAAwBjC,EAA4C,KAAK,kBAAmBgC,EAAqB/B,EAAwBC,EAAqB,KAAK,aAAa,EAClLgC,GAAyB/D,EAAe8D,EAAuB,CAAC,EAChErD,GAAYsD,GAAuB,CAAC,EACpC3D,EAAQ2D,GAAuB,CAAC,EAClC,OAAO5B,EAA8BrB,EAAML,GAAWL,EAAO2B,CAAmB,CAClF,CACA,GAAIA,IAAwB,QAAaV,EAAmCU,CAAmB,EAAG,CAChG,IAAIiC,EAAyBnC,EAA4C,KAAK,kBAAmBgC,EAAqB/B,EAAwBC,EAAqB,KAAK,aAAa,EACnLkC,GAAyBjE,EAAegE,EAAwB,CAAC,EACjEE,EAAaD,GAAuB,CAAC,EACrCE,GAASF,GAAuB,CAAC,EACnC,OAAO7B,EAAyBtB,EAAMoD,EAAYC,GAAQpC,CAAmB,CAC/E,CACA,OAAO,KAAK,aACd,CACF,CAAC,CAAC,EACKY,CACT,EAAE,OAAO,QAAQ,EAEbyB,EAAqC,SAA4CC,EAAY,CAC/F,MAAO,CACL,WAAYA,EACZ,KAAM,eACR,CACF,EAEIC,EAA6C,SAAoDD,EAAY,CAC/G,MAAO,CACL,WAAYA,EACZ,KAAM,uBACR,CACF,EAEIE,EAA8C,SAAqDnE,EAAOC,EAAS,CACrH,MAAO,CACL,QAASA,EACT,KAAM,yBACN,MAAOD,CACT,CACF,EAEIoE,EAAyC,SAAgDpE,EAAOC,EAAS,CAC3G,MAAO,CACL,QAASA,EACT,KAAM,oBACN,MAAOD,CACT,CACF,EAEIqE,EAAiC,SAAwCxD,EAAQR,EAAWS,EAAc,CAC5G,MAAO,CACL,UAAWT,EACX,OAAQQ,EACR,aAAcC,EACd,KAAM,WACR,CACF,EAEAtB,EAAQ,oBAAsB+C,EAC9B/C,EAAQ,mCAAqCwE,EAC7CxE,EAAQ,2CAA6C0E,EACrD1E,EAAQ,4CAA8C2E,EACtD3E,EAAQ,uCAAyC4E,EACjD5E,EAAQ,+BAAiC6E,EACzC7E,EAAQ,8BAAgCY,EACxCZ,EAAQ,mCAAqCc,CAEjD,CAAE,ICjUD,YAAY,UAAkB,qBAAwB,YAAY,UAAkB,sBAAwB,YAAY,UAAU,iBAEnI,QAASgE,IAAO,CAAE,OAAQ,SAAU,iBAAkB,EAClDA,EAAI,UAAU,iBAAmB,IAAI,MAAMA,EAAI,UAAU,iBAAkB,CACvE,MAAO,CAACC,EAAQC,EAASC,KACjBA,EAAK,CAAC,GAAKA,EAAK,CAAC,YAAa,WAC9BA,EAAK,CAAC,EAAI,IAAI,MAAMA,EAAK,CAAC,EAAG,CACzB,MAAO,CAACF,EAAQC,EAASE,IAAwB,CAC7C,GAAI,CACA,GAAI,SAAS,cAAc,UAAU,GAAG,SAASA,EAAM,CAAC,EAAE,MAAc,EACpE,MAAO,EAEf,MAAQ,CAAC,CAET,OAAOH,EAAO,MAAMC,EAASE,CAAK,CACtC,CACJ,CAAC,GAGEH,EAAO,MAAMC,EAASC,CAAI,EAEzC,CAAC,ECrBU,SAARE,GAA2BC,EAAa,CAC3C,OAAOA,EAAK,IAAI,CAACC,EAAOC,IAAU,CAACA,EAAOD,CAAK,CAAC,CACpD,CCEe,SAARE,GAAoBC,EAAe,CACtC,IAAMC,EAEF,CAAC,EACCC,EAAc,iFACdC,EAAK,IAAI,UAAUD,CAAW,EAC9BE,EAAiB,SAAS,eAAe,gBAAgB,EACzDC,EAAoB,SAAS,eAAe,mBAAmB,EAErE,OAAO,QAAUF,EAEjBA,EAAG,OAAS,IAAM,CACd,QAAQ,IAAI,qBAAqB,CACrC,EAEAA,EAAG,UAAaG,GAAU,CACtB,GAAIA,EAAM,KAAK,WAAW,cAAc,EAAG,CACvC,IAAMC,EAAKD,EAAM,KAAK,MAAM,GAAG,EAAE,CAAC,EAC9B,QAAQ,UAAUC,CAAE,mCAAmC,GACvDC,EAAY,kBAAkBD,CAAE,EAAE,EAClCP,EAAK,WAAa,GAClB,OAAO,SAAWO,GAElBC,EAAY,kBAAkBD,CAAE,EAAE,CAE1C,CACA,GAAID,EAAM,KAAK,WAAW,kBAAkB,EAAG,CAC3C,IAAMC,EAAKD,EAAM,KAAK,MAAM,GAAG,EAAE,CAAC,EAClC,OAAO,SAAWC,EAElB,OAAO,cAAc,KAAK,IAAM,YAAY,IAAM,CAC1CP,EAAK,cAAgB,IACrBQ,EAAY,aAAa,KAAK,UAAU,CACpC,KAAM,QACN,MAAO,SACP,OAAQR,EAAK,SACb,QAAS,OAAO,QAAQ,IAAKS,IAAY,CAAE,EAAGA,EAAO,EAAG,EAAGA,EAAO,EAAG,SAAUA,EAAO,QAAS,EAAE,EACjG,MAAO,OAAO,MAAM,IAAKC,IAAU,CAAE,EAAGA,EAAK,EAAG,EAAGA,EAAK,EAAG,SAAUA,EAAK,QAAS,EAAE,EACrF,KAAM,CAAE,EAAG,OAAO,KAAK,EAAG,EAAG,OAAO,KAAK,EAAG,SAAU,CAAC,KAAM,OAAO,KAAK,SAAS,KAAM,IAAK,OAAO,KAAK,SAAS,GAAG,CAAE,CAC3H,CAAC,CAAC,EAAE,CAEZ,EAAG,EAAE,CAAC,CACV,CACA,GAAIJ,EAAM,KAAK,WAAW,eAAe,EAAG,CACxC,IAAMK,EAAML,EAAM,KAAK,MAAM,GAAG,EAAE,CAAC,EAAE,MAAM,GAAG,EAAE,OAAQM,GAAc,CAAC,CAACA,CAAC,EAIzE,GAHID,EAAI,KAAMJ,GAAeA,IAAOP,EAAK,aAAa,GAClDW,EAAI,OAAOA,EAAI,QAAQX,EAAK,aAAa,EAAG,CAAC,EAE7CW,EAAI,QAAU,EAAG,CACjB,GAAI,KAAK,UAAUA,CAAG,IAAM,KAAK,UAAU,CACvC,GAAG,MAAM,KAAK,SAAS,iBAAiB,gBAAgB,CAAC,EAAE,IAAKF,GAAoBA,EAAO,WAAW,CAC1G,CAAC,EACG,OAGJL,EAAe,SAAW,GAE1BC,EAAkB,UAAY,GAE9B,QAASE,KAAMI,EACX,GAAIJ,IAAOP,EAAK,cAAe,CAC3B,IAAMS,EAAS,SAAS,cAAc,OAAO,EAC7CA,EAAO,KAAO,QACdA,EAAO,KAAO,SACdA,EAAO,UAAY,SACnBA,EAAO,MAAQF,EAEfF,EAAkB,YAAYI,CAAM,EACpCJ,EAAkB,WAAa,SAASE,CAAE,eAC9C,CAER,CACJ,CAEA,GAAID,EAAM,KAAK,WAAW,YAAY,EAAG,CACrC,IAAMO,EAAO,KAAK,MAAMP,EAAM,KAAK,MAAM,YAAY,EAAE,CAAC,CAAC,EACzDQ,EAAYD,CAAI,CACpB,CACJ,EAEAV,EAAG,QAAU,IAAM,CACf,QAAQ,IAAI,0BAA0B,CAC1C,EAEA,SAASK,EAAYO,EAAc,CAC/BZ,EAAG,KAAKY,CAAO,CACnB,CAEA,SAASD,EAAYD,EAAY,CAAC,EAAG,CACjC,GAAIA,EAAK,SAAWb,EAAK,cACrB,MAAO,GAGX,GAAIa,EAAK,OAAS,SACd,GAAIA,EAAK,QAAU,UAAW,CAC1B,OAAS,CAACG,EAAOP,CAAM,IAAKQ,GAAUJ,EAAK,OAAO,EAAG,CACjD,IAAMK,EAAiB,OAAO,QAAQ,KAAK,CAACC,EAAIC,IAAMJ,IAAUI,CAAC,EACjE,GAAKF,EAGL,CAAAA,EAAe,EAAIT,EAAO,EAC1BS,EAAe,EAAIT,EAAO,EAC1B,OAAS,CAACY,EAAKC,CAAK,IAAK,OAAO,QAAQb,EAAO,QAAQ,EACnDS,EAAe,SAASG,CAAG,EAAIC,EAEvC,CAEA,OAAS,CAACN,EAAON,CAAI,IAAKO,GAAUJ,EAAK,KAAK,EAAG,CAC7C,IAAMU,EAAe,OAAO,MAAM,KAAK,CAACJ,EAAIC,IAAMJ,IAAUI,CAAC,EAC7D,GAAKG,EAGL,CAAAA,EAAa,EAAIb,EAAK,EACtBa,EAAa,EAAIb,EAAK,EACtB,OAAS,CAACW,EAAKC,CAAK,IAAK,OAAO,QAAQZ,EAAK,QAAQ,EACjDa,EAAa,SAASF,CAAG,EAAIC,EAErC,CAEA,IAAME,EAAe,OAAO,KAC5BA,EAAa,EAAIX,EAAK,KAAK,EAC3BW,EAAa,EAAIX,EAAK,KAAK,EAC3B,OAAS,CAACQ,EAAKC,CAAK,IAAK,OAAO,QAAQT,EAAK,KAAK,QAAQ,EACtDW,EAAa,SAASH,CAAG,EAAIC,EAGjC,IAAMhB,EAAQ,IAAI,cAAc,UAAW,CACvC,IAAKO,EAAK,IACV,MAAOA,EAAK,MACZ,QAASA,EAAK,QACd,KAAMA,EAAK,IACf,CAAC,EAED,OAAO,cAAcP,CAAK,CAC9B,SAAWO,EAAK,QAAU,QAAS,CAC/B,IAAMP,EAAQ,IAAI,cAAc,QAAS,CACrC,IAAKO,EAAK,IACV,MAAOA,EAAK,MACZ,QAASA,EAAK,QACd,KAAMA,EAAK,IACf,CAAC,EAED,OAAO,cAAcP,CAAK,CAC9B,SAAWO,EAAK,QAAU,SAAU,CAChC,GAAIZ,EAAK,GAAQA,EAAK,GAAQA,EAAK,QAC/B,MAAO,GAEX,OAAS,CAACe,EAAOP,CAAM,IAAKQ,GAAUJ,EAAK,OAAO,EAAG,CACjD,IAAMK,EAAiB,OAAO,QAAQ,KAAK,CAACC,EAAIC,IAAMJ,IAAUI,CAAC,EACjE,GAAKF,EAGL,CAAAA,EAAe,EAAIT,EAAO,EAC1BS,EAAe,EAAIT,EAAO,EAC1B,OAAS,CAACY,EAAKC,CAAK,IAAK,OAAO,QAAQb,EAAO,QAAQ,EACnDS,EAAe,SAASG,CAAG,EAAIC,EAEvC,CAEA,OAAS,CAACN,EAAON,CAAI,IAAKO,GAAUJ,EAAK,KAAK,EAAG,CAC7C,IAAMU,EAAe,OAAO,MAAM,KAAK,CAACJ,EAAIC,IAAMJ,IAAUI,CAAC,EAC7D,GAAKG,EAGL,CAAAA,EAAa,EAAIb,EAAK,EACtBa,EAAa,EAAIb,EAAK,EACtB,OAAS,CAACW,EAAKC,CAAK,IAAK,OAAO,QAAQZ,EAAK,QAAQ,EACjDa,EAAa,SAASF,CAAG,EAAIC,EAErC,CAEA,IAAME,EAAe,OAAO,KAC5BA,EAAa,EAAIX,EAAK,KAAK,EAC3BW,EAAa,EAAIX,EAAK,KAAK,EAC3B,OAAS,CAACQ,EAAKC,CAAK,IAAK,OAAO,QAAQT,EAAK,KAAK,QAAQ,EACtDW,EAAa,SAASH,CAAG,EAAIC,CAErC,EAER,CAEA,OAAO,qBAAqB,UAAYhB,GAAiB,CACrD,GAAI,CAACA,EAAM,UACP,MAAO,GAEPN,EAAK,cAAgB,KAChBM,EAAwB,MAAQ,IACjCE,EAAY,aAAa,KAAK,UAAU,CACpC,KAAM,QACN,MAAO,UACP,IAAK,IACL,MAAO,GACP,QAAS,GACT,KAAM,OACN,OAAQR,EAAK,SACb,QAAS,OAAO,QAAQ,IAAKS,IAAY,CAAE,EAAGA,EAAO,EAAG,EAAGA,EAAO,EAAG,SAAUA,EAAO,QAAS,EAAE,EACjG,MAAO,OAAO,MAAM,IAAKC,IAAU,CAAE,EAAGA,EAAK,EAAG,EAAGA,EAAK,EAAG,SAAUA,EAAK,QAAS,EAAE,EACrF,KAAM,CAAE,EAAG,OAAO,KAAK,EAAG,EAAG,OAAO,KAAK,EAAG,SAAU,OAAO,KAAK,QAAS,CAC/E,CAAC,CAAC,EAAE,EACIJ,EAAwB,MAAQ,WACxCE,EAAY,aAAa,KAAK,UAAU,CACpC,KAAM,QACN,MAAO,UACP,IAAK,UACL,MAAO,GACP,QAAS,GACT,KAAM,UACN,OAAQR,EAAK,SACb,QAAS,OAAO,QAAQ,IAAKS,IAAY,CAAE,EAAGA,EAAO,EAAG,EAAGA,EAAO,EAAG,SAAUA,EAAO,QAAS,EAAE,EACjG,MAAO,OAAO,MAAM,IAAKC,IAAU,CAAE,EAAGA,EAAK,EAAG,EAAGA,EAAK,EAAG,SAAUA,EAAK,QAAS,EAAE,EACrF,KAAM,CAAE,EAAG,OAAO,KAAK,EAAG,EAAG,OAAO,KAAK,EAAG,SAAU,OAAO,KAAK,QAAS,CAC/E,CAAC,CAAC,EAAE,EAGhB,CAAC,EAED,OAAO,qBAAqB,QAAUJ,GAAU,CAC5C,GAAI,CAACA,EAAM,UACP,MAAO,GAEPN,EAAK,cAAgB,KAChBM,EAAwB,MAAQ,IACjCE,EAAY,aAAa,KAAK,UAAU,CACpC,KAAM,QACN,MAAO,QACP,IAAK,IACL,MAAO,GACP,QAAS,GACT,KAAM,OACN,OAAQR,EAAK,QACjB,CAAC,CAAC,EAAE,EACIM,EAAwB,MAAQ,WACxCE,EAAY,aAAa,KAAK,UAAU,CACpC,KAAM,QACN,MAAO,QACP,IAAK,UACL,MAAO,GACP,QAAS,GACT,KAAM,UACN,OAAQR,EAAK,QACjB,CAAC,CAAC,EAAE,EAGhB,CAAC,CACL,CCxPA,IAAAyB,GAAgC,SCAhC,IAAAC,GAQO,SCNA,IAAMC,GAAuC,IAAM,IAAI,aAAa,GAAI,YAAY,ECApF,IAAMC,GAA0FC,GAC5F,CAACC,EAAcC,EAAQ,CAACC,EAAQC,EAAOC,CAAa,EAAGC,IAAoB,CAC9EN,EACIC,EAAaG,CAAK,EAClB,CAACF,EAAQC,EAAQE,CAAa,EAC7BE,GAA0BA,EAAsB,CAAC,IAAML,GAAUK,EAAsB,CAAC,IAAMJ,EAC/FG,CAAgB,CAExB,ECPG,IAAME,GAAkEC,GACpE,CACHC,EACAC,EACAC,IACA,CACA,IAAMC,EAAe,CAAA,EAErB,QAASC,EAAI,EAAGA,EAAIF,EAAgB,eAAgBE,GAAK,EACrDD,EAAa,KAAK,IAAI,GAAgC,EAG1DJ,EAA0B,IAAIC,EAAW,CACrC,aAAAG,EACA,QAAS,IAAI,IACb,cAAe,IAAI,QACnB,SAAUF,EACb,CACL,EClBG,IAAMI,GAAoEC,GACtE,CACHC,EACAC,IACA,CACAF,EAA2B,IAAIC,EAAY,CAAE,aAAc,IAAI,IAAO,cAAe,IAAI,QAAW,SAAUC,CAAkB,CAAE,CACtI,ECKG,IAAMC,GAAyD,IAAI,QAE7DC,GAA2D,IAAI,QAE/DC,GAAoC,IAAI,QAExCC,GAA6D,IAAI,QAEjEC,GAAsC,IAAI,QAE1CC,GAA+B,IAAI,QAEnCC,GAAmF,IAAI,QAEvFC,GAAiC,IAAI,QAGrCC,GAGT,IAAI,QAEKC,GAGT,IAAI,QCrCR,IAAMC,GAAU,CACZ,WAAS,CACL,OAAOA,EACX,GAGSC,GAAmBC,GAAwC,CACpE,GAAI,CACA,IAAMC,EAAQ,IAAI,MAAMD,EAAeF,EAAO,EAE9C,IAAIG,CACR,MAAQ,CACJ,MAAO,EACX,CAEA,MAAO,EACX,ECNA,IAAMC,GAAyB,uPAElBC,GAAwB,CAACC,EAAgBC,IAAiC,CACnF,IAAMC,EAAmB,CAAA,EAErBC,EAAgCH,EAAO,QAAQ,SAAU,EAAE,EAC3DI,EAASD,EAA8B,MAAML,EAAsB,EAEvE,KAAOM,IAAW,MAAM,CACpB,IAAMC,EAAgBD,EAAO,CAAC,EAAE,MAAM,EAAG,EAAE,EAErCE,EAAiCF,EAAO,CAAC,EAC1C,QAAQ,cAAe,EAAE,EACzB,QAAQC,EAAe,IAAI,IAAIA,EAAeJ,CAAG,EAAE,SAAQ,CAAE,EAClEC,EAAiB,KAAKI,CAA8B,EAEpDH,EAAgCA,EAA8B,MAAMC,EAAO,CAAC,EAAE,MAAM,EAAE,QAAQ,SAAU,EAAE,EAC1GA,EAASD,EAA8B,MAAML,EAAsB,CACvE,CAEA,MAAO,CAACI,EAAiB,KAAK,GAAG,EAAGC,CAA6B,CACrE,EC3BA,IAAMI,GAA8BC,GAAmF,CACnH,GAAIA,IAAyB,QAAa,CAAC,MAAM,QAAQA,CAAoB,EACzE,MAAM,IAAI,UAAU,qFAAqF,CAEjH,EAEMC,GAAoEC,GAAoB,CAC1F,GAAI,CAACC,GAAgBD,CAAa,EAC9B,MAAM,IAAI,UAAU,4DAA4D,EAGpF,GAAIA,EAAc,YAAc,MAAQ,OAAOA,EAAc,WAAc,SACvE,MAAM,IAAI,UAAU,4DAA4D,CAExF,EAEaE,GAA6D,CACtEC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,IACA,CACA,IAAIC,EAAQ,EAEZ,MAAO,CAACC,EAASC,EAAWC,EAAU,CAAE,YAAa,MAAM,IAAM,CAC7D,IAAMC,EAA4BP,EAAiB,IAAII,CAAO,EAE9D,GAAIG,IAA8B,QAAaA,EAA0B,IAAIF,CAAS,EAClF,OAAO,QAAQ,QAAO,EAG1B,IAAMG,EAA2BT,EAAgB,IAAIK,CAAO,EAE5D,GAAII,IAA6B,OAAW,CACxC,IAAMC,EAA0BD,EAAyB,IAAIH,CAAS,EAEtE,GAAII,IAA4B,OAC5B,OAAOA,CAEf,CAEA,IAAMC,EAAgBf,EAAiBS,CAAO,EAGxCO,EACFD,EAAc,eAAiB,OACzBhB,EAAYW,CAAS,EAChB,KAAK,CAAC,CAACO,EAAQC,CAAW,IAAK,CAC5B,GAAM,CAACC,EAAkBC,CAA6B,EAAIC,GAAsBJ,EAAQC,CAAW,EAiB7FI,EAAgB,GAAGH,CAAgB,4GAA4GC,CAA6B;sBAIlL,OAAOvB,EAAeyB,CAAa,CACvC,CAAC,EACA,KAAK,IAAK,CACP,IAAMC,EAAqFhB,EAAQ,MAAO,IAAG,EAE7G,GAAIgB,IAAoC,OAEpC,MAAM,IAAI,YAGdzB,EAAiCiB,EAAc,YAAaA,EAAc,WAAY,IAClFQ,EACI,KAA2B,GAC3B,OACA,CAACC,EAAMhC,IAAiB,CACpB,GAAIgC,EAAK,KAAI,IAAO,GAChB,MAAM5B,EAAuB,EAGjC,IAAM6B,EAAoCC,GAAwC,IAAIX,CAAa,EAEnG,GAAIU,IAAsC,OAAW,CACjD,GAAIA,EAAkC,IAAID,CAAI,EAC1C,MAAM5B,EAAuB,EAGjCL,GAAoBC,CAAa,EACjCH,GAA2BG,EAAc,oBAAoB,EAE7DiC,EAAkC,IAAID,EAAMhC,CAAa,CAC7D,MACID,GAAoBC,CAAa,EACjCH,GAA2BG,EAAc,oBAAoB,EAE7DkC,GAAwC,IAAIX,EAAe,IAAI,IAAI,CAAC,CAACS,EAAMhC,CAAa,CAAC,CAAC,CAAC,CAEnG,EACAuB,EAAc,WACd,OACA,MAAS,CACZ,CAET,CAAC,EACL,QAAQ,IAAI,CACRhB,EAAYW,CAAS,EACrB,QAAQ,QACJf,EAAgBW,EAA6CA,CAA2C,CAAC,EAEhH,EAAE,KAAK,CAAC,CAAC,CAACW,EAAQC,CAAW,EAAGS,CAAuB,IAAK,CACzD,IAAMC,EAAepB,EAAQ,EAE7BA,EAAQoB,EAER,GAAM,CAACT,EAAkBC,CAA6B,EAAIC,GAAsBJ,EAAQC,CAAW,EA8E7FI,EAAgB,GAAGH,CAAgB,iDAAiDC,CAA6B;KAnDlFO,EAC/B,wBACA,uLAkDK,+CALcA,EAA0B,GAAK,oDAKkB,kBAJ/CA,EACrB,GACA,qEAEwG,gGAAgGC,CAAY,+DACpNC,EAAO,IAAI,KAAK,CAACP,CAAa,EAAG,CAAE,KAAM,uCAAuC,CAAE,EAClFQ,EAAM,IAAI,gBAAgBD,CAAI,EAEpC,OAAOd,EAAc,aAChB,UAAUe,EAAKnB,CAAO,EACtB,KAAK,IAAK,CACP,GAAIT,EAA4Ba,CAAa,EACzC,OAAOA,EAIX,IAAMgB,EAA4B9B,EAAqCc,CAAa,EAEpF,OAAOgB,EAA0B,aAAa,UAAUD,EAAKnB,CAAO,EAAE,KAAK,IAAMoB,CAAyB,CAC9G,CAAC,EACA,KAAMC,GAA4C,CAC/C,GAAI7B,IAAsC,KACtC,MAAM,IAAI,YAGd,GAAI,CAEA,IAAIA,EAAkC6B,EAA0C,QAAQJ,CAAY,EAAE,CAC1G,MAAQ,CACJ,MAAM,IAAI,WACd,CACJ,CAAC,EACA,QAAQ,IAAM,IAAI,gBAAgBE,CAAG,CAAC,CAC/C,CAAC,EAEX,OAAIjB,IAA6B,OAC7BT,EAAgB,IAAIK,EAAS,IAAI,IAAI,CAAC,CAACC,EAAWM,CAAO,CAAC,CAAC,CAAC,EAE5DH,EAAyB,IAAIH,EAAWM,CAAO,EAGnDA,EACK,KAAK,IAAK,CACP,IAAMiB,EAAmC5B,EAAiB,IAAII,CAAO,EAEjEwB,IAAqC,OACrC5B,EAAiB,IAAII,EAAS,IAAI,IAAI,CAACC,CAAS,CAAC,CAAC,EAElDuB,EAAiC,IAAIvB,CAAS,CAEtD,CAAC,EACA,QAAQ,IAAK,CACV,IAAMwB,EAAkC9B,EAAgB,IAAIK,CAAO,EAE/DyB,IAAoC,QACpCA,EAAgC,OAAOxB,CAAS,CAExD,CAAC,EAEEM,CACX,CACJ,EC/QO,IAAMmB,GAA0C,CAACC,EAAKC,IAAO,CAChE,IAAMC,EAAQF,EAAI,IAAIC,CAAG,EAEzB,GAAIC,IAAU,OACV,MAAM,IAAI,MAAM,gDAAgD,EAGpE,OAAOA,CACX,ECRO,IAAMC,GAAkD,CAACC,EAAKC,IAAa,CAC9E,IAAMC,EAAmB,MAAM,KAAKF,CAAG,EAAE,OAAOC,CAAS,EAEzD,GAAIC,EAAiB,OAAS,EAC1B,MAAM,MAAM,kCAAkC,EAGlD,GAAIA,EAAiB,SAAW,EAC5B,MAAM,MAAM,uBAAuB,EAGvC,GAAM,CAACC,CAAe,EAAID,EAE1B,OAAAF,EAAI,OAAOG,CAAe,EAEnBA,CACX,ECbO,IAAMC,GAA0C,CACnDC,EACAC,EACAC,EACAC,IACA,CACA,IAAMC,EAA0BC,GAAeL,EAAeC,CAAM,EAC9DK,EAAqBC,GACvBH,EACCI,GAA2BA,EAAuB,CAAC,IAAMN,GAAUM,EAAuB,CAAC,IAAML,CAAK,EAG3G,OAAIC,EAAwB,OAAS,GACjCJ,EAAc,OAAOC,CAAM,EAGxBK,CACX,EClBO,IAAMG,GAAuEC,GACzEC,GAAeC,GAAiBF,CAAS,ECA7C,IAAMG,GAAgDC,GAA4B,CACrF,GAAIC,GAAwB,IAAID,CAAS,EACrC,MAAM,IAAI,MAAM,kCAAkC,EAGtDC,GAAwB,IAAID,CAAS,EAErCE,GAA6BF,CAAS,EAAE,QAASG,GAAkBA,EAAc,EAAI,CAAC,CAC1F,ECVO,IAAMC,GAA0CC,GAC5C,SAAUA,ECCd,IAAMC,GAAiDC,GAA4B,CACtF,GAAI,CAACC,GAAwB,IAAID,CAAS,EACtC,MAAM,IAAI,MAAM,8BAA8B,EAGlDC,GAAwB,OAAOD,CAAS,EAExCE,GAA6BF,CAAS,EAAE,QAASG,GAAkBA,EAAc,EAAK,CAAC,CAC3F,ECPO,IAAMC,GAAyC,CAClDC,EACAC,IACA,CACI,CAACC,GAAmBF,CAAS,GAAKC,EAAa,MAAOE,GAAgBA,EAAY,OAAS,CAAC,GAC5FC,GAA0BJ,CAAS,CAE3C,ECPO,IAAMK,GAAmE,CAC5EC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,IACA,CACA,IAAMC,EAAqB,IAAI,QAE/B,MAAO,CAACC,EAAQC,EAAaC,EAAQC,EAAOC,IAAa,CACrD,GAAM,CAAE,aAAAC,EAAc,cAAAC,CAAa,EAAKf,EAAwBU,CAAW,EACrE,CAAE,QAAAM,CAAO,EAAKhB,EAAwBS,CAAM,EAC5CQ,EAAiBf,EAA6BO,CAAM,EAEpDS,EAA8CC,GAAY,CAC5D,IAAMC,EAA6BjB,EAAmBO,CAAW,EAC3DW,EAAwBlB,EAAmBM,CAAM,EAEvD,GAAIU,EAAU,CACV,IAAMG,EAAoBC,GAAwCR,EAAeN,EAAQE,EAAQC,CAAK,EAEtGjB,EAAoCmB,EAAcL,EAAQa,EAAmB,EAAK,EAE9E,CAACT,GAAa,CAACP,EAAeG,CAAM,GACpCZ,EAAwCwB,EAAuBD,EAA4BT,EAAQC,CAAK,EAGxGL,EAAmBG,CAAW,GAC9Bc,GAAyBd,CAAW,CAE5C,KAAO,CACH,IAAMY,EAAoBxB,EAAuCgB,EAAcL,EAAQE,EAAQC,CAAK,EAEpGhB,EAAqCmB,EAAeH,EAAOU,EAAmB,EAAK,EAE/E,CAACT,GAAa,CAACP,EAAeG,CAAM,GACpCV,EAA6CsB,EAAuBD,EAA4BT,EAAQC,CAAK,EAGjH,IAAMa,EAAWxB,EAAqBS,CAAW,EAEjD,GAAIe,IAAa,EACTpB,EAAkBK,CAAW,GAC7BgB,GAAuChB,EAAaI,CAAY,MAEjE,CACH,IAAMa,EAAoBnB,EAAmB,IAAIE,CAAW,EAExDiB,IAAsB,QACtB,aAAaA,CAAiB,EAGlCnB,EAAmB,IACfE,EACA,WAAW,IAAK,CACRL,EAAkBK,CAAW,GAC7BgB,GAAuChB,EAAaI,CAAY,CAExE,EAAGW,EAAW,GAAI,CAAC,CAE3B,CACJ,CACJ,EAEA,OACIrB,EACIY,EACA,CAACN,EAAaC,EAAQC,CAAK,EAC1BgB,GACGA,EAAiB,CAAC,IAAMlB,GAAekB,EAAiB,CAAC,IAAMjB,GAAUiB,EAAiB,CAAC,IAAMhB,EACrG,EAAI,GAGRK,EAAe,IAAIC,CAAa,EAE5Bb,EAAkBI,CAAM,EACxBd,EAAoCmB,EAAcL,EAAQ,CAACE,EAAQC,EAAOM,CAAa,EAAG,EAAI,EAE9FtB,EAAqCmB,EAAeH,EAAO,CAACH,EAAQE,EAAQO,CAAa,EAAG,EAAI,EAG7F,IAGJ,EACX,CACJ,EClGO,IAAMW,GAA4FC,GAC9F,CAACC,EAAeC,EAAO,CAACC,EAAQC,EAAQC,CAAa,EAAGC,IAAoB,CAC/E,IAAMC,EAA0BN,EAAc,IAAIE,CAAM,EAEpDI,IAA4B,OAC5BN,EAAc,IAAIE,EAAQ,IAAI,IAAI,CAAC,CAACC,EAAQF,EAAOG,CAAa,CAAC,CAAC,CAAC,EAEnEL,EACIO,EACA,CAACH,EAAQF,EAAOG,CAAa,EAC5BG,GAA2BA,EAAuB,CAAC,IAAMJ,GAAUI,EAAuB,CAAC,IAAMN,EAClGI,CAAgB,CAG5B,ECdG,IAAMG,GAA0DC,GAC5D,CAACC,EAAeC,IAAkC,CACrD,IAAMC,EAAiBH,EAAqBC,EAAe,CACvD,aAAc,EACd,iBAAkB,WAClB,sBAAuB,WACvB,KAAM,EACT,EAEDC,EAA+B,QAAQC,CAAc,EAAE,QAAQF,EAAc,WAAW,EAExF,IAAMG,EAAa,IAAK,CACpBF,EAA+B,oBAAoB,QAASE,CAAU,EACtEF,EAA+B,WAAWC,CAAc,EACxDA,EAAe,WAAU,CAC7B,EAEAD,EAA+B,iBAAiB,QAASE,CAAU,CACvE,EClBG,IAAMC,GAA8EC,GAChF,CAACC,EAAeC,IAAoB,CACvCF,EAA+BC,CAAa,EAAE,IAAIC,CAAgB,CACtE,ECFJ,IAAMC,GAAkB,CACpB,aAAc,EACd,iBAAkB,MAClB,sBAAuB,WACvB,QAAS,KACT,YAAa,IACb,YAAa,KACb,sBAAuB,IAGdC,GAAiE,CAC1EC,EACAC,EACAC,EACAC,EACAC,EACAC,IAEO,cAA+CL,CAAwB,CAG1E,YAAYM,EAAYC,EAAmC,CACvD,IAAMC,EAAgBJ,EAAiBE,CAAO,EACxCG,EAAgB,CAAE,GAAGX,GAAiB,GAAGS,CAAO,EAChDG,EAAqBP,EAAyBK,EAAeC,CAAa,EAC1EE,EACDN,EAA4BG,CAAa,EAAIP,EAA0B,EAAK,KAGjF,MAAMK,EAAS,GAAOI,EAAoBC,CAAoB,EAE9D,KAAK,oBAAsBD,CAC/B,CAEA,IAAI,SAAO,CACP,OAAO,KAAK,oBAAoB,OACpC,CAEA,IAAI,QAAQE,EAAK,CACb,KAAK,oBAAoB,QAAUA,CACvC,CAEA,IAAI,mBAAiB,CACjB,OAAO,KAAK,oBAAoB,iBACpC,CAEA,IAAI,aAAW,CACX,OAAO,KAAK,oBAAoB,WACpC,CAEA,IAAI,YAAYA,EAAK,CAEjB,IAAMC,EAAc,KAAK,oBAAoB,YAI7C,GAFA,KAAK,oBAAoB,YAAcD,EAEnC,EAAEA,EAAQ,KAAK,oBAAoB,aACnC,WAAK,oBAAoB,YAAcC,EAEjCX,EAAoB,CAElC,CAEA,IAAI,aAAW,CACX,OAAO,KAAK,oBAAoB,WACpC,CAEA,IAAI,YAAYU,EAAK,CAEjB,IAAME,EAAc,KAAK,oBAAoB,YAI7C,GAFA,KAAK,oBAAoB,YAAcF,EAEnC,EAAE,KAAK,oBAAoB,YAAcA,GACzC,WAAK,oBAAoB,YAAcE,EAEjCZ,EAAoB,CAElC,CAEA,IAAI,uBAAqB,CACrB,OAAO,KAAK,oBAAoB,qBACpC,CAEA,IAAI,sBAAsBU,EAAK,CAC3B,KAAK,oBAAoB,sBAAwBA,CACrD,CAEO,qBAAqBG,EAAiB,CACzC,KAAK,oBAAoB,qBAAqBA,CAAK,CACvD,CAEO,sBAAsBA,EAAiB,CAC1C,KAAK,oBAAoB,sBAAsBA,CAAK,CACxD,CAEO,sBAAsBA,EAAmB,CAC5C,KAAK,oBAAoB,sBAAsBA,CAAK,CACxD,CAEO,uBAAuBA,EAAmB,CAC7C,KAAK,oBAAoB,uBAAuBA,CAAK,CACzD,GCvGD,IAAMC,EAAmB,CAACC,EAAmCC,IACzDD,EAAgB,UAAYC,ECChC,IAAMC,GAAyE,CAClFC,EACAC,EACAC,IAEO,IAAmE,CACtE,IAAMC,EAA8B,IAAI,QAElCC,EAAqB,MAAOC,EAAyBC,IAAyD,CAChH,IAAIC,EAAqBN,EAA2CI,CAAK,EAKzE,GAAI,CAFuCG,EAAiBD,EAAoBD,CAAyB,EAEhE,CACrC,IAAMG,EAAU,CACZ,aAAcF,EAAmB,aACjC,iBAAkBA,EAAmB,iBACrC,sBAAuBA,EAAmB,sBAC1C,QAASA,EAAmB,QAC5B,YAAaA,EAAmB,YAChC,YAAaA,EAAmB,YAChC,sBAAuBA,EAAmB,uBAG9CA,EAAqBP,EAAyBM,EAA2BG,CAAO,CACpF,CAEA,OAAAN,EAA4B,IAAIG,EAA2BC,CAAkB,EAE7E,MAAML,EAAwBG,EAAOC,EAA2BC,CAAkB,EAE3EA,CACX,EAEA,MAAO,CACH,OAAOF,EAAyBC,EAAqD,CACjF,IAAMI,EAA6BP,EAA4B,IAAIG,CAAyB,EAE5F,OAAII,IAA+B,OACxB,QAAQ,QAAQA,CAA0B,EAG9CN,EAAmBC,EAAOC,CAAyB,CAC9D,EAER,EChDG,IAAMK,GAAuDC,GAAkD,CAClH,GAAI,CACAA,EAAkB,cAAc,IAAI,aAAa,CAAC,EAAG,EAAG,EAAE,CAC9D,MAAQ,CACJ,MAAO,EACX,CAEA,MAAO,EACX,ECRO,IAAMC,GAA+C,IAAM,IAAI,aAAa,GAAI,gBAAgB,ECChG,IAAMC,GAAuCC,GAAyC,CACzFA,EAAY,gBAAmBC,GACnBC,GAAmB,CACvB,GAAI,CACA,OAAOD,EAAe,KAAKD,EAAaE,CAAO,CACnD,OAASC,EAAK,CACV,MAAIA,EAAI,OAAS,GACPC,GAAoB,EAGxBD,CACV,CACJ,GACDH,EAAY,cAAc,CACjC,ECZA,IAAMK,GAAkB,CACpB,iBAAkB,GAGTC,GAA+D,CACxEC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,IACA,CACA,IAAIC,EAA+D,KAEnE,OAAO,MAAMC,EAAW,CAsBpB,YAAYC,EAA4B,CACpC,GAAIN,IAAyC,KACzC,MAAM,IAAI,MAAM,qDAAqD,EAGzE,GAAM,CAAE,OAAAO,EAAQ,iBAAAC,EAAkB,WAAAC,CAAU,EAAK,CAAE,GAAGf,GAAiB,GAAGY,CAAO,EAE7EF,IAA8B,OAC9BA,EAA4B,IAAIJ,EAAqC,EAAG,EAAG,KAAK,GAOpF,IAAMU,EACFX,IAAiC,MACjCF,EAAgBI,EAAyCA,CAAuC,EAC1F,IAAIF,EAA6B,CAAE,OAAAQ,EAAQ,iBAAAC,EAAkB,WAAAC,CAAU,CAAE,EACzEL,EAA0B,aAAaI,EAAkBD,EAAQE,CAAU,EAGrF,GAAIC,EAAY,mBAAqB,EACjC,MAAMZ,EAAuB,EAKjC,OAAI,OAAOY,EAAY,iBAAoB,YACvCR,EAAkCQ,CAAW,EAC7CC,GAAoCD,CAAW,GAG9Cb,EAAgBe,GAAqD,IAClEA,GAAoDF,CAAW,CAAC,GAGpEP,EAA6CO,CAAW,EAG5Dd,EAAiB,IAAIc,CAAW,EAMzBA,CACX,CAEO,OAAQ,OAAO,WAAW,EAAEG,EAAiB,CAChD,OACKA,IAAa,MAAQ,OAAOA,GAAa,UAAY,OAAO,eAAeA,CAAQ,IAAMR,GAAY,WACtGT,EAAiB,IAASiB,CAAQ,CAE1C,EAER,ECnGO,IAAMC,GAA6B,sBAE7BC,GAA6B,CAACD,GCCpC,IAAME,GAAiDC,GAAcC,GAAwB,IAAID,CAAS,ECWjH,IAAME,GAAkB,CACpB,OAAQ,KACR,aAAc,EACd,iBAAkB,MAClB,sBAAuB,WAEvB,KAAM,GACN,QAAS,EACT,UAAW,EACX,aAAc,GAGLC,GAAmF,CAC5FC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,IAEO,cACKP,CAA0D,CAelE,YAAYQ,EAAYC,EAA4C,CAChE,IAAMC,EAAgBL,EAAiBG,CAAO,EACxCG,EAAgB,CAAE,GAAGb,GAAiB,GAAGW,CAAO,EAChDG,EAA8BR,EAAkCM,EAAeC,CAAa,EAC5FE,EAAYP,EAA4BI,CAAa,EACrDI,EACDD,EAAYZ,EAAmC,EAAK,KAGzD,MAAMO,EAAS,GAAOI,EAA6BE,CAA6B,EAEhF,KAAK,+BAAiCA,EACtC,KAAK,mBAAqB,GAC1B,KAAK,aAAeH,EAAc,SAAW,KAC7C,KAAK,6BAA+BC,EACpC,KAAK,SAAW,KAEhB,KAAK,cAAgBV,EACjB,KACAW,EACAD,EAA4B,aAC5BG,GACAC,EAA0B,CAElC,CAEA,IAAI,QAAM,CACN,OAAI,KAAK,mBACE,KAGJ,KAAK,6BAA6B,MAC7C,CAEA,IAAI,OAAOC,EAAK,CAIZ,GAHA,KAAK,6BAA6B,OAASA,EAGvCA,IAAU,KAAM,CAChB,GAAI,KAAK,aACL,MAAMd,EAAuB,EAGjC,KAAK,aAAe,EACxB,CACJ,CAEA,IAAI,MAAI,CACJ,OAAO,KAAK,6BAA6B,IAC7C,CAEA,IAAI,KAAKc,EAAK,CACV,KAAK,6BAA6B,KAAOA,CAC7C,CAEA,IAAI,SAAO,CACP,OAAO,KAAK,6BAA6B,OAC7C,CAEA,IAAI,QAAQA,EAAK,CACb,KAAK,6BAA6B,QAAUA,CAChD,CAEA,IAAI,WAAS,CACT,OAAO,KAAK,6BAA6B,SAC7C,CAEA,IAAI,UAAUA,EAAK,CACf,KAAK,6BAA6B,UAAYA,CAClD,CAEA,IAAI,SAAO,CACP,OAAO,KAAK,QAChB,CAEA,IAAI,QAAQA,EAAK,CACb,IAAMC,EAAkB,OAAOD,GAAU,WAAaV,EAAkB,KAAMU,CAAK,EAAI,KAEvF,KAAK,6BAA6B,QAAUC,EAE5C,IAAMC,EAAgB,KAAK,6BAA6B,QAExD,KAAK,SAAWA,IAAkB,MAAQA,IAAkBD,EAAkBD,EAAQE,CAC1F,CAEA,IAAI,cAAY,CACZ,OAAO,KAAK,aAChB,CAEO,MAAMC,EAAO,EAAGC,EAAS,EAAGC,EAAiB,CAOhD,GANA,KAAK,6BAA6B,MAAMF,EAAMC,EAAQC,CAAQ,EAE1D,KAAK,iCAAmC,OACxC,KAAK,+BAA+B,MAAQA,IAAa,OAAY,CAACF,EAAMC,CAAM,EAAI,CAACD,EAAMC,EAAQC,CAAQ,GAG7G,KAAK,QAAQ,QAAU,SAAU,CACjCC,GAAyB,IAAI,EAE7B,IAAMC,EAA8B,IAAK,CACrC,KAAK,6BAA6B,oBAAoB,QAASA,CAA2B,EAEtFC,GAAkB,IAAI,GACtBC,GAA0B,IAAI,CAEtC,EAEA,KAAK,6BAA6B,iBAAiB,QAASF,CAA2B,CAC3F,CACJ,CAEO,KAAKJ,EAAO,EAAC,CAChB,KAAK,6BAA6B,KAAKA,CAAI,EAEvC,KAAK,iCAAmC,OACxC,KAAK,+BAA+B,KAAOA,EAEnD,GCrKD,IAAMO,GAA2F,CACpGC,EACAC,EACAC,EACAC,EACAC,IAEO,IAAmE,CACtE,IAAMC,EAAuC,IAAI,QAE7CC,EAA4D,KAC5DC,EAAsB,KAEpBC,EAA8B,MAChCC,EACAC,IACA,CACA,IAAIC,EAA8BT,EAAoDO,CAAK,EAMrFG,EAA8CC,EAAiBF,EAA6BD,CAAyB,EAE3H,GAAI,CAACE,EAA6C,CAC9C,IAAME,EAAU,CACZ,OAAQH,EAA4B,OACpC,aAAcA,EAA4B,aAC1C,iBAAkBA,EAA4B,iBAC9C,sBAAuBA,EAA4B,sBAEnD,KAAMA,EAA4B,KAClC,QAASA,EAA4B,QACrC,UAAWA,EAA4B,UACvC,aAAcA,EAA4B,aAAa,OAG3DA,EAA8BV,EAAkCS,EAA2BI,CAAO,EAE9FR,IAAU,MACVK,EAA4B,MAAM,GAAGL,CAAK,EAG1CC,IAAS,MACTI,EAA4B,KAAKJ,CAAI,CAE7C,CAEA,OAAAF,EAAqC,IAAIK,EAA2BC,CAA2B,EAE1FC,EAKD,MAAMZ,EAAkBU,EAA2BD,EAAM,aAAcE,EAA4B,YAAY,EAH/G,MAAMR,EAAiBO,EAA2BD,EAAM,aAAcE,EAA4B,YAAY,EAMlH,MAAMP,EAAwBK,EAAOC,EAA2BC,CAA2B,EAEpFA,CACX,EAEA,MAAO,CACH,IAAI,MAAMI,EAAkD,CACxDT,EAAQS,CACZ,EACA,IAAI,KAAKA,EAAa,CAClBR,EAAOQ,CACX,EACA,OACIN,EACAC,EAAqD,CAErD,IAAMM,EAAsCX,EAAqC,IAAIK,CAAyB,EAE9G,OAAIM,IAAwC,OACjC,QAAQ,QAAQA,CAAmC,EAGvDR,EAA4BC,EAAOC,CAAyB,CACvE,EAER,ECrFG,IAAMO,GAA+CC,GACjD,iBAAkBA,ECDtB,IAAMC,GAA0CC,GAC5C,cAAeA,GAAa,SAAUA,ECD1C,IAAMC,GAA4CC,GAC9C,WAAYA,ECDhB,IAAMC,GAAkCC,GACpC,EAAE,cAAeA,IAAc,SAAUA,ECD7C,IAAMC,GAAwCC,GAC1C,WAAYA,GAAa,cAAeA,ECD5C,IAAMC,GAA0CC,GAC5C,QAASA,ECCb,IAAMC,GACTC,GAEiCC,GAAeC,GAA8BF,CAAS,ECHpF,IAAMG,GACTC,GAEkCC,GAAeC,GAA+BF,CAAU,ECMvF,IAAMG,GAA4C,CACrDC,EACAC,IACA,CACA,GAAM,CAAE,aAAAC,CAAY,EAAKC,GAAwBH,CAAS,EAE1DE,EAAa,QAASE,GAClBA,EAAY,QAAQ,CAAC,CAACC,CAAM,IAAK,CACxBJ,EAAM,SAASD,CAAS,GACzBD,GAA0CM,EAAQ,CAAC,GAAGJ,EAAOD,CAAS,CAAC,CAE/E,CAAC,CAAC,EAGN,IAAMM,EAAcC,GAAwBP,CAAS,EAC/C,CAEIA,EAAU,cAEdQ,GAAmBR,CAAS,EAC5B,MAAM,KAAKA,EAAU,WAAW,OAAM,CAAE,EACxCS,GAAmBT,CAAS,EAC5B,CAACA,EAAU,EAAGA,EAAU,OAAQA,EAAU,UAAWA,EAAU,IAAI,EACnEU,GAAqBV,CAAS,EAC9B,CAACA,EAAU,MAAM,EACjBW,GAAWX,CAAS,EACpB,CAACA,EAAU,IAAI,EACfY,GAAiBZ,CAAS,EAC1B,CAACA,EAAU,OAAQA,EAAU,SAAS,EACtCa,GAAmBb,CAAS,EAC5B,CAACA,EAAU,GAAG,EACd,CAAA,EAEN,QAAWc,KAAcR,EAAa,CAClC,IAAMS,EAAwBC,GAA4BF,CAAU,EAEhEC,IAA0B,QAC1BA,EAAsB,aAAa,QAAQ,CAAC,CAACV,CAAM,IAAMN,GAA0CM,EAAQJ,CAAK,CAAC,CAEzH,CAEIgB,GAAkBjB,CAAS,GAC3BkB,GAA0BlB,CAAS,CAE3C,ECtDO,IAAMmB,GAA4CC,GAAoB,CACzEC,GAAoED,EAAQ,YAAa,CAAA,CAAE,CAC/F,ECJO,IAAME,GAAsBC,GAE3BA,IAAgB,QAChB,OAAOA,GAAgB,UACtB,OAAOA,GAAgB,WAAaA,IAAgB,YAAcA,IAAgB,eAAiBA,IAAgB,YCMrH,IAAMC,GAAiE,CAC1EC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,IAEO,cAA2BR,CAA0C,CAWxE,YAAYS,EAAgC,CAAA,EAAE,CAC1C,GAAID,IAAkC,KAClC,MAAM,IAAI,MAAM,8CAA8C,EAGlE,IAAIE,EAEJ,GAAI,CACAA,EAAqB,IAAIF,EAA8BC,CAAO,CAClE,OAASE,EAAK,CAEV,MAAIA,EAAI,OAAS,IAAMA,EAAI,UAAY,6BAC7BT,EAAuB,EAG3BS,CACV,CAGA,GAAID,IAAuB,KACvB,MAAMP,EAAkB,EAI5B,GAAI,CAACS,GAAmBH,EAAQ,WAAW,EACvC,MAAM,IAAI,UACN,uBAAuBA,EAAQ,WAAW,kEAAkE,EAKpH,GAAIA,EAAQ,aAAe,QAAaC,EAAmB,aAAeD,EAAQ,WAC9E,MAAMP,EAAuB,EAGjC,MAAMQ,EAAoB,CAAC,EAE3B,GAAM,CAAE,YAAAG,CAAW,EAAKJ,EAClB,CAAE,WAAAK,CAAU,EAAKJ,EAuCvB,GApCA,KAAK,aACD,OAAOA,EAAmB,aAAgB,SACpCA,EAAmB,YACnBG,IAAgB,WAChB,IAAMC,EACND,IAAgB,eAAiBA,IAAgB,OACjD,IAAMC,EACND,IAAgB,WAChB,KAAOC,EAKN,KAAK,IAAI,EAAG,KAAK,IAAI,IAAK,KAAK,MAAOD,EAAcC,EAAc,GAAG,CAAC,CAAC,EAAI,IAAOA,EAC7F,KAAK,oBAAsBJ,EAGvBF,EAA8B,OAAS,sBACvC,KAAK,gBAAkBE,EAAmB,WAAU,EACpD,KAAK,sBAAwBA,EAAmB,iBAAgB,EAEhE,KAAK,gBAAgB,KAAK,MAAQ,MAElC,KAAK,sBAAsB,QAAQ,KAAK,eAAe,EAAE,QAAQA,EAAmB,WAAW,EAC/F,KAAK,sBAAsB,MAAK,IAEhC,KAAK,gBAAkB,KACvB,KAAK,sBAAwB,MAGjC,KAAK,OAAS,KAMVA,EAAmB,QAAU,UAAW,CACxC,KAAK,OAAS,YAEd,IAAMK,EAAc,IAAK,CACjB,KAAK,SAAW,cAChB,KAAK,OAAS,MAGlBL,EAAmB,oBAAoB,cAAeK,CAAW,CACrE,EAEAL,EAAmB,iBAAiB,cAAeK,CAAW,CAClE,CACJ,CAEA,IAAI,aAAW,CACX,OAAO,KAAK,YAChB,CAEA,IAAI,OAAK,CACL,OAAO,KAAK,SAAW,KAAO,KAAK,OAAS,KAAK,oBAAoB,KACzE,CAEO,OAAK,CAER,OAAI,KAAK,QAAU,SACR,KAAK,oBAAoB,MAAK,EAAG,KAAK,IAAK,CAC9C,MAAMd,EAAuB,CACjC,CAAC,GAID,KAAK,SAAW,cAChB,KAAK,OAAS,MAGX,KAAK,oBAAoB,MAAK,EAAG,KAAK,IAAK,CAC1C,KAAK,kBAAoB,MAAQ,KAAK,wBAA0B,OAChE,KAAK,sBAAsB,KAAI,EAE/B,KAAK,gBAAgB,WAAU,EAC/B,KAAK,sBAAsB,WAAU,GAGzCe,GAAqB,IAAI,CAC7B,CAAC,EACL,CAEO,yBAAyBC,EAA8B,CAC1D,OAAO,IAAIb,EAAuC,KAAM,CAAE,aAAAa,CAAY,CAAE,CAC5E,CAEO,8BAA4B,CAC/B,OAAO,IAAIZ,EAA2C,IAAI,CAC9D,CAEO,wBAAwBa,EAAwB,CACnD,OAAO,IAAIZ,EAAsC,KAAM,CAAE,YAAAY,CAAW,CAAE,CAC1E,CAEO,6BAA6BC,EAAkC,CAClE,OAAO,IAAIZ,EAA2C,KAAM,CAAE,iBAAAY,CAAgB,CAAE,CACpF,CAEO,QAAM,CACT,OAAI,KAAK,SAAW,YACT,IAAI,QAAQ,CAACC,EAASC,IAAU,CACnC,IAAMC,EAAiB,IAAK,CACxB,KAAK,oBAAoB,oBAAoB,cAAeA,CAAc,EAEtE,KAAK,oBAAoB,QAAU,UACnCF,EAAO,EAEP,KAAK,OAAM,EAAG,KAAKA,EAASC,CAAM,CAE1C,EAEA,KAAK,oBAAoB,iBAAiB,cAAeC,CAAc,CAC3E,CAAC,EAGE,KAAK,oBAAoB,OAAM,EAAG,MAAOX,GAAO,CAGnD,MAAIA,IAAQ,QAAaA,EAAI,OAAS,GAC5BV,EAAuB,EAG3BU,CACV,CAAC,CACL,CAEO,SAAO,CACV,OAAO,KAAK,oBAAoB,QAAO,EAAG,MAAOA,GAAO,CAEpD,MAAIA,IAAQ,OACFV,EAAuB,EAG3BU,CACV,CAAC,CACL,GC3MD,IAAMY,GAAiF,CAC1FC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,IAEO,cAAuDP,CAAuB,CAKjF,YAAYQ,EAAYC,EAAoB,CACxC,IAAMC,EAAgBL,EAAiBG,CAAO,EACxCG,EAAYL,EAA4BI,CAAa,EACrDE,EAA6BR,EAAiCM,EAAeD,EAAcE,CAAS,EACpGE,EACDF,EAAYV,EAAmCM,CAAuB,EAAI,KAG/E,MAAMC,EAAS,GAAOI,EAA4BC,CAA4B,EAE9E,KAAK,mCAAqCF,EAC1C,KAAK,4BAA8BC,CACvC,CAEA,IAAI,cAAY,CACZ,OAAO,KAAK,4BAA4B,YAC5C,CAEA,IAAI,aAAaE,EAAK,CAGlB,GAAI,KAAK,mCACL,MAAMX,EAAuB,EAIjC,GAAIW,EAAQ,KAAK,4BAA4B,gBACzC,MAAMZ,EAAoB,EAG9B,KAAK,4BAA4B,aAAeY,CACpD,CAEA,IAAI,kBAAgB,CAChB,OAAO,KAAK,4BAA4B,gBAC5C,CAEA,IAAI,iBAAiBA,EAAK,CAEtB,GAAI,KAAK,mCACL,MAAMX,EAAuB,EAGjC,KAAK,4BAA4B,iBAAmBW,CACxD,CAEA,IAAI,iBAAe,CACf,OAAO,KAAK,4BAA4B,eAC5C,GChED,IAAMC,GAGTC,GACA,CACA,IAAMC,EAAsC,IAAI,QAE1CC,EAA6B,MAAOC,EAAiCC,IAAyD,CAChI,IAAMC,EAA6BD,EAA0B,YAE7D,OAAAH,EAAoC,IAAIG,EAA2BC,CAA0B,EAE7F,MAAML,EAAwBG,EAAOC,EAA2BC,CAA0B,EAEnFA,CACX,EAEA,MAAO,CACH,OACIF,EACAC,EAAqD,CAErD,IAAME,EAAqCL,EAAoC,IAAIG,CAAyB,EAE5G,OAAIE,IAAuC,OAChC,QAAQ,QAAQA,CAAkC,EAGtDJ,EAA2BC,EAAOC,CAAyB,CACtE,EAER,ECnCO,IAAMG,GAA2D,CACpEC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,IAEO,CAACC,EAASC,IAAiB,CAC9B,IAAMC,EAAiBD,EAAc,SAG/BE,EAAwB,IAAK,CAC/B,IAAMC,EAAS,IAAI,aAAa,CAAC,EAC3BC,EAAoBZ,EAA8BQ,EAAe,CACnE,aAAc,EACd,iBAAkB,WAClB,sBAAuB,WACvB,eAAgB,EACnB,EACKK,EAAYR,EAA4BG,CAAa,EAEvDM,EAA+B,GAC/BC,EAAoE,CAAC,EAAG,EAAG,GAAI,EAAG,EAAG,CAAC,EACtFC,EAAyC,CAAC,EAAG,EAAG,CAAC,EAE/CC,EAA4B,IAAK,CACnC,GAAIH,EACA,OAGJA,EAA+B,GAE/B,IAAMI,EAAsBhB,EAAgCM,EAAe,IAAK,EAAG,CAAC,EAGpFU,EAAoB,eAAiB,CAAC,CAAE,YAAAC,CAAW,IAAM,CACrD,IAAMC,EAAgE,CAClEhB,EAAee,EAAaR,EAAQ,CAAC,EACrCP,EAAee,EAAaR,EAAQ,CAAC,EACrCP,EAAee,EAAaR,EAAQ,CAAC,EACrCP,EAAee,EAAaR,EAAQ,CAAC,EACrCP,EAAee,EAAaR,EAAQ,CAAC,EACrCP,EAAee,EAAaR,EAAQ,CAAC,GAGrCS,EAAY,KAAK,CAACC,EAAOC,IAAUD,IAAUN,EAAgBO,CAAK,CAAC,IACnEb,EAAe,eAAe,GAAGW,CAAW,EAE5CL,EAAkBK,GAGtB,IAAMG,EAAoC,CACtCnB,EAAee,EAAaR,EAAQ,CAAC,EACrCP,EAAee,EAAaR,EAAQ,CAAC,EACrCP,EAAee,EAAaR,EAAQ,CAAC,GAGrCY,EAAQ,KAAK,CAACF,EAAOC,IAAUD,IAAUL,EAAaM,CAAK,CAAC,IAC5Db,EAAe,YAAY,GAAGc,CAAO,EAErCP,EAAeO,EAEvB,EAEAX,EAAkB,QAAQM,CAAmB,CACjD,EACMM,EAAwBF,GAAmBD,GAAiB,CAC1DA,IAAUN,EAAgBO,CAAK,IAC/BP,EAAgBO,CAAK,EAAID,EAEzBZ,EAAe,eAAe,GAAGM,CAAe,EAExD,EACMU,EAAqBH,GAAmBD,GAAiB,CACvDA,IAAUL,EAAaM,CAAK,IAC5BN,EAAaM,CAAK,EAAID,EAEtBZ,EAAe,YAAY,GAAGO,CAAY,EAElD,EACMU,EAAuB,CAACC,EAAeC,EAAsBC,IAAqC,CACpG,IAAMC,EAAqB7B,EAA+BO,EAAe,CACrE,aAAc,EACd,iBAAkB,WAClB,sBAAuB,WACvB,OAAQoB,EACX,EAEDE,EAAmB,QAAQlB,EAAmB,EAAGe,CAAK,EAGtDG,EAAmB,MAAK,EAExB,OAAO,eAAeA,EAAmB,OAAQ,eAAgB,CAC7D,KAAG,CACC,OAAOF,CACX,EACH,EAMD,IAAMG,EAAahC,EACV,CAAE,QAAAQ,CAAO,EACdM,EACAiB,EAAmB,OACnBE,GACAC,EAA0B,EAG9B,OAAA3B,EACIyB,EACA,QACCG,GAAQ,IAAMA,EAAI,KAAKH,CAAU,EACjCI,GAASd,GAAS,CACf,GAAI,CACAc,EAAI,KAAKJ,EAAYV,CAAK,CAC9B,OAASe,EAAK,CACV,GAAIA,EAAI,OAAS,EACb,MAAMA,CAEd,CAEAnB,EAAyB,EAErBJ,GAEAgB,EAASR,CAAK,CAEtB,CAAC,EAGLU,EAAW,qBAAwBM,GAC3BxB,EACO,IAAK,CACR,MAAMV,EAAuB,CACjC,EAGG,IAAImC,IAAwD,CAC/D,IAAMjB,EAAQgB,EAAoB,MAAMN,EAAYO,CAAI,EAExD,OAAArB,EAAyB,EAElBI,CACX,GACDU,EAAW,mBAAmB,EACjCA,EAAW,uBAA0BQ,GAC7B1B,EACO,IAAK,CACR,MAAMV,EAAuB,CACjC,EAGG,IAAImC,IAA0D,CACjE,IAAMjB,EAAQkB,EAAsB,MAAMR,EAAYO,CAAI,EAE1D,OAAArB,EAAyB,EAElBI,CACX,GACDU,EAAW,qBAAqB,EACnCA,EAAW,8BAAiCS,GACpC3B,EACO,IAAK,CACR,MAAMV,EAAuB,CACjC,EAGG,IAAImC,IAAiE,CACxE,IAAMjB,EAAQmB,EAA6B,MAAMT,EAAYO,CAAI,EAEjE,OAAArB,EAAyB,EAElBI,CACX,GACDU,EAAW,4BAA4B,EAC1CA,EAAW,yBAA4BU,GAC/B5B,EACO,IAAK,CACR,MAAMV,EAAuB,CACjC,EAGG,IAAImC,IAA4D,CACnE,IAAMjB,EAAQoB,EAAwB,MAAMV,EAAYO,CAAI,EAE5D,OAAArB,EAAyB,EAElBI,CACX,GACDU,EAAW,uBAAuB,EACrCA,EAAW,iBAAoBW,GACvB7B,EACO,IAAK,CACR,MAAMV,EAAuB,CACjC,EAGG,IAAImC,IAAoD,CAC3D,IAAMjB,EAAQqB,EAAgB,MAAMX,EAAYO,CAAI,EAEpD,OAAArB,EAAyB,EAElBI,CACX,GACDU,EAAW,eAAe,EAC7BA,EAAW,gBAAmBY,GACtB9B,EACO,IAAK,CACR,MAAMV,EAAuB,CACjC,EAGG,IAAImC,IAAmD,CAC1D,IAAMjB,EAAQsB,EAAe,MAAMZ,EAAYO,CAAI,EAEnD,OAAArB,EAAyB,EAElBI,CACX,GACDU,EAAW,cAAc,EAC5BA,EAAW,qBAAwBa,GAC3B/B,EACO,IAAK,CACR,MAAMV,EAAuB,CACjC,EAGG,IAAImC,IAAwD,CAC/D,IAAMjB,EAAQuB,EAAoB,MAAMb,EAAYO,CAAI,EAExD,OAAArB,EAAyB,EAElBI,CACX,GACDU,EAAW,mBAAmB,EAE1BA,CACX,EAEA,MAAO,CACH,SAAUL,EAAqB,EAAG,EAAGF,EAAqB,CAAC,CAAC,EAC5D,SAAUE,EAAqB,EAAG,EAAGF,EAAqB,CAAC,CAAC,EAC5D,SAAUE,EAAqB,EAAG,GAAIF,EAAqB,CAAC,CAAC,EAC7D,UAAWE,EAAqB,EAAG,EAAGD,EAAkB,CAAC,CAAC,EAC1D,UAAWC,EAAqB,EAAG,EAAGD,EAAkB,CAAC,CAAC,EAC1D,UAAWC,EAAqB,EAAG,EAAGD,EAAkB,CAAC,CAAC,EAC1D,IAAKC,EAAqB,EAAG,EAAGF,EAAqB,CAAC,CAAC,EACvD,IAAKE,EAAqB,EAAG,EAAGF,EAAqB,CAAC,CAAC,EACvD,IAAKE,EAAqB,EAAG,EAAGF,EAAqB,CAAC,CAAC,EAE/D,EAEM,CAAE,SAAAqB,EAAU,SAAAC,EAAU,SAAAC,EAAU,UAAAC,EAAW,UAAAC,EAAW,UAAAC,EAAW,IAAAC,EAAK,IAAAC,EAAK,IAAAC,CAAG,EAChF5C,EAAe,WAAa,OAAYC,EAAqB,EAAKD,EAEtE,MAAO,CACH,IAAI,UAAQ,CACR,OAAOoC,CACX,EACA,IAAI,UAAQ,CACR,OAAOC,CACX,EACA,IAAI,UAAQ,CACR,OAAOC,CACX,EACA,IAAI,WAAS,CACT,OAAOC,CACX,EACA,IAAI,WAAS,CACT,OAAOC,CACX,EACA,IAAI,WAAS,CACT,OAAOC,CACX,EACA,IAAI,KAAG,CACH,OAAOC,CACX,EACA,IAAI,KAAG,CACH,OAAOC,CACX,EACA,IAAI,KAAG,CACH,OAAOC,CACX,EAER,ECnSG,IAAMC,GACTC,GAEO,YAAaA,ECHjB,IAAMC,GACTC,GAEOC,GAAYD,EAAiB,CAAC,CAAC,ECJnC,IAAME,GAAkD,CAACC,EAAKC,EAASC,EAAWC,IAAoB,CACzG,QAAWC,KAAQJ,EACf,GAAIE,EAAUE,CAAI,EAAG,CACjB,GAAID,EACA,MAAO,GAGX,MAAM,MAAM,gDAAgD,CAChE,CAGJ,OAAAH,EAAI,IAAIC,CAAO,EAER,EACX,ECZO,IAAMI,GAAuC,CAChDC,EACAC,EACA,CAACC,EAAQC,CAAa,EACtBC,IACA,CACAC,GACIL,EACA,CAACC,EAAQC,EAAQC,CAAa,EAC7BG,GAA0BA,EAAsB,CAAC,IAAML,GAAUK,EAAsB,CAAC,IAAMJ,EAC/FE,CAAgB,CAExB,ECZO,IAAMG,GAAwC,CACjDC,EACA,CAACC,EAAQC,EAAQC,CAAa,EAC9BC,IACA,CACA,IAAMC,EAA0BL,EAAc,IAAIC,CAAM,EAEpDI,IAA4B,OAC5BL,EAAc,IAAIC,EAAQ,IAAI,IAAI,CAAC,CAACC,EAAQC,CAAa,CAAC,CAAC,CAAC,EAE5DG,GACID,EACA,CAACH,EAAQC,CAAa,EACrBI,GAA2BA,EAAuB,CAAC,IAAML,EAC1DE,CAAgB,CAG5B,EClBO,IAAMI,GACTC,GAEO,WAAYA,ECFhB,IAAMC,GAA4F,CACrGC,EACAC,EACAC,EACAC,IACoC,CACpC,GAAIC,GAAuBH,CAA0B,EAAG,CACpD,IAAMI,EAAiCJ,EAA2B,OAAOE,CAAK,EAE9E,OAAAH,EAAsB,QAAQK,EAAgCH,EAAQ,CAAC,EAEhE,CAACG,EAAgCH,EAAQ,CAAC,CACrD,CAEA,OAAAF,EAAsB,QAAQC,EAA4BC,EAAQC,CAAK,EAEhE,CAACF,EAA4BC,EAAQC,CAAK,CACrD,EClBO,IAAMG,GAA8B,CACvCC,EACAC,EACAC,IACkC,CAClC,QAAWC,KAAyBH,EAChC,GAAIG,EAAsB,CAAC,IAAMF,GAAUE,EAAsB,CAAC,IAAMD,EACpE,OAAAF,EAAuB,OAAOG,CAAqB,EAE5CA,EAIf,OAAO,IACX,ECbO,IAAMC,GAA0C,CACnDC,EACAC,EACAC,IAEOC,GACHH,EACCI,GAA0BA,EAAsB,CAAC,IAAMH,GAAUG,EAAsB,CAAC,IAAMF,CAAM,ECPtG,IAAMG,GAAiC,CAC1CC,EACAC,IACA,CAGA,GAAI,CAFmBC,GAA6BF,CAAS,EAEzC,OAAOC,CAAa,EACpC,MAAM,IAAI,MAAM,sCAAsC,CAE9D,ECRO,IAAME,GAA2C,CACpDC,EACAC,EACAC,IACA,CACA,IAAMC,EAA0BC,GAAeJ,EAAeC,CAAM,EAC9DI,EAAqBC,GACvBH,EACCI,GAA2BA,EAAuB,CAAC,IAAML,CAAM,EAGpE,OAAIC,EAAwB,OAAS,GACjCH,EAAc,OAAOC,CAAM,EAGxBI,CACX,EClBO,IAAMG,GAAsG,CAC/GC,EACAC,EACAC,EACAC,IACA,CACIC,GAAuBH,CAA0B,EACjDD,EAAsB,WAAWC,EAA2B,OAAOE,CAAK,EAAGD,EAAQ,CAAC,EAEpFF,EAAsB,WAAWC,EAA4BC,EAAQC,CAAK,CAElF,ECTO,IAAME,EACTC,GAEUC,GAAeC,GAAkBF,CAAS,ECHjD,IAAMG,GAAuBC,GACzBC,GAAeC,GAAmBF,CAAU,ECHhD,IAAMG,GAA2CC,GAC7CC,GAAe,IAAID,CAAS,ECDhC,IAAME,GAAmDC,GACrD,CAACC,GAAwB,IAAID,CAAS,ECF1C,IAAME,GAAuC,CAChDC,EACAC,IAEO,IAAI,QAASC,GAAW,CAK3B,GAAID,IAAsC,KACtCC,EAAQ,EAAI,MACT,CACH,IAAMC,EAAWH,EAAmB,sBAAsB,IAAK,EAAG,CAAC,EAC7DI,EAAQJ,EAAmB,WAAU,EAErCK,EAAOL,EAAmB,aAAa,EAAG,EAAG,KAAK,EAClDM,EAAcD,EAAK,eAAe,CAAC,EAEzCC,EAAY,CAAC,EAAI,EACjBA,EAAY,CAAC,EAAI,EAEjB,IAAMC,EAASP,EAAmB,mBAAkB,EAEpDO,EAAO,OAASF,EAChBE,EAAO,KAAO,GAEdA,EAAO,QAAQJ,CAAQ,EAAE,QAAQH,EAAmB,WAAW,EAC/DO,EAAO,QAAQH,CAAK,EACpBG,EAAO,WAAWH,CAAK,EAGvBD,EAAS,eAAkBK,GAAS,CAChC,IAAMC,EAAUD,EAAM,YAAY,eAAe,CAAC,EAE9C,MAAM,UAAU,KAAK,KAAKC,EAAUC,GAAmBA,IAAW,CAAC,EACnER,EAAQ,EAAI,EAEZA,EAAQ,EAAK,EAGjBK,EAAO,KAAI,EAEXJ,EAAS,eAAiB,KAE1BI,EAAO,WAAWJ,CAAQ,EAC1BA,EAAS,WAAWH,EAAmB,WAAW,CACtD,EAEAO,EAAO,MAAK,CAChB,CACJ,CAAC,ECjDE,IAAMI,GAAyB,CAClCC,EACAC,IACM,CACN,IAAMC,EAAS,IAAI,IAEnB,QAAWC,KAASH,EAChB,QAAWI,KAAaD,EAAO,CAC3B,IAAME,EAAQH,EAAO,IAAIE,CAAS,EAElCF,EAAO,IAAIE,EAAWC,IAAU,OAAY,EAAIA,EAAQ,CAAC,CAC7D,CAGJH,EAAO,QAAQ,CAACG,EAAOD,IAAcH,EAAQG,EAAWC,CAAK,CAAC,CAClE,EChBO,IAAMC,GACTC,GAEO,YAAaA,ECFjB,IAAMC,GAAiCC,GAA2C,CACrF,IAAMC,EAAc,IAAI,IAExBD,EAAgB,SAAyCE,GAE9C,CAACC,EAAmDC,EAAS,EAAGC,EAAgB,IAA8B,CACjH,IAAMC,EAAcC,GAAkBJ,CAAW,EAAID,EAAQC,EAAaC,EAAQC,CAAK,EAAIH,EAAQC,EAAaC,CAAM,EAGhHI,EAA2BP,EAAY,IAAIE,CAAW,EAE5D,OAAIK,IAA6B,OAC7BP,EAAY,IAAIE,EAAa,CAAC,CAAE,MAAAE,EAAO,OAAAD,CAAM,CAAE,CAAC,EAE5CI,EAAyB,MAAOC,GAAeA,EAAW,QAAUJ,GAASI,EAAW,SAAWL,CAAM,GACzGI,EAAyB,KAAK,CAAE,MAAAH,EAAO,OAAAD,CAAM,CAAE,EAIhDE,CACX,GACDN,EAAgB,QAAQ,KAAKA,CAAe,CAAC,EAEhDA,EAAgB,YAAeU,GACpB,CAACC,EAAqEP,EAAiBC,IAAwB,CAGlH,GAFAK,EAAW,MAAMV,CAAe,EAE5BW,IAAwB,OACxBV,EAAY,MAAK,UACV,OAAOU,GAAwB,SACtC,OAAW,CAACR,EAAaK,CAAwB,IAAKP,EAAa,CAC/D,IAAMW,EAAsBJ,EAAyB,OAAQC,GAAeA,EAAW,SAAWE,CAAmB,EAEjHC,EAAoB,SAAW,EAC/BX,EAAY,OAAOE,CAAW,EAE9BF,EAAY,IAAIE,EAAaS,CAAmB,CAExD,SACOX,EAAY,IAAIU,CAAmB,EAC1C,GAAIP,IAAW,OACXH,EAAY,OAAOU,CAAmB,MACnC,CACH,IAAMH,EAA2BP,EAAY,IAAIU,CAAmB,EAEpE,GAAIH,IAA6B,OAAW,CACxC,IAAMI,EAAsBJ,EAAyB,OAChDC,GAAeA,EAAW,SAAWL,IAAWK,EAAW,QAAUJ,GAASA,IAAU,OAAU,EAGnGO,EAAoB,SAAW,EAC/BX,EAAY,OAAOU,CAAmB,EAEtCV,EAAY,IAAIU,EAAqBC,CAAmB,CAEhE,CACJ,CAGJ,OAAW,CAACT,EAAaK,CAAwB,IAAKP,EAClDO,EAAyB,QAASC,GAAc,CACxCF,GAAkBJ,CAAW,EAC7BH,EAAgB,QAAQG,EAAaM,EAAW,OAAQA,EAAW,KAAK,EAExET,EAAgB,QAAQG,EAAaM,EAAW,MAAM,CAE9D,CAAC,CAET,GACDT,EAAgB,UAAU,CACjC,EC7BA,IAAMa,GAA0C,CAC5CC,EACAC,EACAC,EACAC,IACS,CACT,GAAM,CAAE,aAAAC,EAAc,cAAAC,CAAa,EAAKC,GAA4BL,CAAW,EACzE,CAAE,QAAAM,CAAO,EAAKC,GAAwBR,CAAM,EAC5CS,EAAiBC,GAA6BV,CAAM,EAEpDW,EAA8CC,GAAY,CAC5D,IAAMC,EAAkBC,EAAmBd,CAAM,EAC3Ce,EAAmBC,GAAoBf,CAAW,EAExD,GAAIW,EAAU,CACV,IAAMK,EAAoBC,GAAyCb,EAAeL,EAAQE,CAAM,EAEhGiB,GAAqCf,EAAcJ,EAAQiB,EAAmB,EAAK,EAE/E,CAACd,GAAa,CAACiB,GAAepB,CAAM,GACpCa,EAAgB,QAAQE,EAAkBb,CAAM,CAExD,KAAO,CACH,IAAMe,EAAoBI,GAAwCjB,EAAcJ,EAAQE,CAAM,EAE9FoB,GAAsCjB,EAAeY,EAAmB,EAAK,EAEzE,CAACd,GAAa,CAACiB,GAAepB,CAAM,GACpCa,EAAgB,WAAWE,EAAkBb,CAAM,CAE3D,CACJ,EAEA,OACIqB,GACIhB,EACA,CAACN,EAAaC,CAAM,EACnBsB,GAAqBA,EAAiB,CAAC,IAAMvB,GAAeuB,EAAiB,CAAC,IAAMtB,EACrF,EAAI,GAGRO,EAAe,IAAIE,CAAa,EAE5Bc,GAAkBzB,CAAM,EACxBmB,GAAqCf,EAAcJ,EAAQ,CAACE,EAAQS,CAAa,EAAG,EAAI,EAExFW,GAAsCjB,EAAe,CAACL,EAAQE,EAAQS,CAAa,EAAG,EAAI,EAGvF,IAGJ,EACX,EAEMe,GAAmC,CACrC1B,EACAC,EACAC,EACAyB,IAC+C,CAC/C,GAAM,CAAE,aAAAvB,EAAc,cAAAC,CAAa,EAAKG,GAAwBP,CAAW,EAErE2B,EAAwBC,GAA4BzB,EAAauB,CAAK,EAAG3B,EAAQE,CAAM,EAE7F,OAAI0B,IAA0B,KAGnB,CAFwBE,GAAwCzB,EAAeL,EAAQE,EAAQyB,CAAK,EAE5E,CAAC,EAAG,EAAK,EAGrC,CAACC,EAAsB,CAAC,EAAG,EAAI,CAC1C,EAEMG,GAAoC,CACtC/B,EACAC,EACAC,IAC+C,CAC/C,GAAM,CAAE,aAAAE,EAAc,cAAAC,CAAa,EAAKC,GAA4BL,CAAW,EAEzE2B,EAAwBC,GAA4BzB,EAAcJ,EAAQE,CAAM,EAEtF,OAAI0B,IAA0B,KAGnB,CAFwBV,GAAyCb,EAAeL,EAAQE,CAAM,EAEtE,CAAC,EAAG,EAAK,EAGrC,CAAC0B,EAAsB,CAAC,EAAG,EAAI,CAC1C,EAEMI,GAA0B,CAC5BhC,EACAG,EACAF,EACAC,EACAyB,IACA,CACA,GAAM,CAACM,EAAUrB,CAAQ,EAAIc,GAAiC1B,EAAQC,EAAaC,EAAQyB,CAAK,EAUhG,GARIM,IAAa,OACbC,GAA+BlC,EAAQiC,CAAQ,EAE3CrB,GAAY,CAACT,GAAa,CAACiB,GAAepB,CAAM,GAChDmC,GAA6CrB,EAAmBd,CAAM,EAAGc,EAAmBb,CAAW,EAAGC,EAAQyB,CAAK,GAI3HF,GAAkBxB,CAAW,EAAG,CAChC,GAAM,CAAE,aAAAG,CAAY,EAAKI,GAAwBP,CAAW,EAE5DmC,GAAuCnC,EAAaG,CAAY,CACpE,CACJ,EAEMiC,GAA2B,CAC7BrC,EACAG,EACAF,EACAC,IACA,CACA,GAAM,CAAC+B,EAAUrB,CAAQ,EAAImB,GAAkC/B,EAAQC,EAAaC,CAAM,EAEtF+B,IAAa,OACbC,GAA+BlC,EAAQiC,CAAQ,EAE3CrB,GAAY,CAACT,GAAa,CAACiB,GAAepB,CAAM,GAChDc,EAAmBd,CAAM,EAAE,WAAWgB,GAAoBf,CAAW,EAAGC,CAAM,EAG1F,EAEMoC,GAAsB,CAAqBtC,EAAuBG,IAAuD,CAC3H,IAAMoC,EAA+B/B,GAAwBR,CAAM,EAC7DwC,EAAe,CAAA,EAErB,QAAWhB,KAAoBe,EAA6B,QACpDE,GAA4BjB,CAAgB,EAC5CQ,GAAwBhC,EAAQG,EAAW,GAAGqB,CAAgB,EAE9Da,GAAyBrC,EAAQG,EAAW,GAAGqB,CAAgB,EAGnEgB,EAAa,KAAKhB,EAAiB,CAAC,CAAC,EAGzC,OAAAe,EAA6B,QAAQ,MAAK,EAEnCC,CACX,EAEME,GAA2B,CAC7B1C,EACAG,EACAD,IACiC,CACjC,IAAMqC,EAA+B/B,GAAwBR,CAAM,EAC7DwC,EAAe,CAAA,EAErB,QAAWhB,KAAoBe,EAA6B,QACpDf,EAAiB,CAAC,IAAMtB,IACpBuC,GAA4BjB,CAAgB,EAC5CQ,GAAwBhC,EAAQG,EAAW,GAAGqB,CAAgB,EAE9Da,GAAyBrC,EAAQG,EAAW,GAAGqB,CAAgB,EAGnEgB,EAAa,KAAKhB,EAAiB,CAAC,CAAC,EACrCe,EAA6B,QAAQ,OAAOf,CAAgB,GAIpE,OAAOgB,CACX,EAEMG,GAAgC,CAClC3C,EACAG,EACAF,EACAC,EACAyB,IACiC,CACjC,IAAMY,EAA+B/B,GAAwBR,CAAM,EAEnE,OAAO,MAAM,KAAKuC,EAA6B,OAAO,EACjD,OACIf,GACGA,EAAiB,CAAC,IAAMvB,IACvBC,IAAW,QAAasB,EAAiB,CAAC,IAAMtB,KAChDyB,IAAU,QAAaH,EAAiB,CAAC,IAAMG,EAAM,EAE7D,IAAKH,IACEiB,GAA4BjB,CAAgB,EAC5CQ,GAAwBhC,EAAQG,EAAW,GAAGqB,CAAgB,EAE9Da,GAAyBrC,EAAQG,EAAW,GAAGqB,CAAgB,EAGnEe,EAA6B,QAAQ,OAAOf,CAAgB,EAErDA,EAAiB,CAAC,EAC5B,CACT,EAEaoB,GAA2D,CACpEC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,IAEO,cACKN,CAAgC,CAOxC,YACIO,EACAjD,EACAC,EACAiD,EAA6H,CAE7H,MAAMjD,CAAe,EAErB,KAAK,SAAWgD,EAChB,KAAK,iBAAmBhD,EAExB,IAAMkD,EAAgBR,EAAiBM,CAAO,EAI1CL,EAAqBO,CAAa,GAE9BhB,EAAgBiB,GAAsC,IAC3CA,GAAqCD,EAAeH,CAAiC,CAC/F,IAHL,IAKAK,GAA8BpD,CAAe,EAGjDqD,GAAiB,IAAI,KAAMrD,CAAe,EAC1CsD,GAAgB,IAAI,KAAM,IAAI,GAAK,EAE/BN,EAAQ,QAAU,UAAYjD,GAC9BwD,GAAyB,IAAI,EAGjCvB,EAAwB,KAAMiB,EAAmBjD,CAAe,CACpE,CAEA,IAAI,cAAY,CACZ,OAAO,KAAK,iBAAiB,YACjC,CAEA,IAAI,aAAawD,EAAK,CAClB,KAAK,iBAAiB,aAAeA,CACzC,CAEA,IAAI,kBAAgB,CAChB,OAAO,KAAK,iBAAiB,gBACjC,CAEA,IAAI,iBAAiBA,EAAK,CACtB,KAAK,iBAAiB,iBAAmBA,CAC7C,CAEA,IAAI,uBAAqB,CACrB,OAAO,KAAK,iBAAiB,qBACjC,CAEA,IAAI,sBAAsBA,EAAK,CAC3B,KAAK,iBAAiB,sBAAwBA,CAClD,CAEA,IAAI,SAAO,CACP,OAAO,KAAK,QAChB,CAEA,IAAI,gBAAc,CACd,OAAO,KAAK,iBAAiB,cACjC,CAEA,IAAI,iBAAe,CACf,OAAO,KAAK,iBAAiB,eACjC,CAKO,QAAqDpE,EAA8BC,EAAS,EAAGyB,EAAQ,EAAC,CAE3G,GAAIzB,EAAS,GAAKA,GAAU,KAAK,iBAAiB,gBAC9C,MAAM+C,EAAoB,EAG9B,IAAMc,EAAgBR,EAAiB,KAAK,QAAQ,EAC9CpD,EAAYwD,EAA4BI,CAAa,EAE3D,GAAIN,EAAkBxD,CAAW,GAAKyD,EAAmBzD,CAAW,EAChE,MAAMiD,EAAwB,EAGlC,GAAIoB,GAAYrE,CAAW,EAAG,CAC1B,IAAMsE,EAA6BzD,EAAmBb,CAAW,EAEjE,GAAI,CACA,IAAMuE,EAAaC,GACf,KAAK,iBACLF,EACArE,EACAyB,CAAK,EAGH+C,EAAYC,GAAmB,IAAI,GAErCxE,GAAauE,IACb,KAAK,iBAAiB,WAAW,GAAGF,CAAU,EAG9C,KAAK,QAAQ,QAAU,UAAY,CAACE,GAAaC,GAAmB1E,CAAW,GAC/EmE,GAAyBnE,CAAW,CAE5C,OAAS2E,EAAK,CAEV,MAAIA,EAAI,OAAS,GACP1B,EAAwB,EAG5B0B,CACV,CAWA,GATmC9B,EAC/B,KACsB7C,EACtBC,EACAyB,EACAxB,CAAS,EAImB,CAC5B,IAAM0E,EAASxB,EAAa,CAAC,IAAI,EAA4BpD,CAAY,EAEzE6E,GAAuBD,EAAQ7B,EAA4B7C,CAAS,CAAC,CACzE,CAEA,OAAOF,CACX,CAEA,IAAMc,EAAmBC,GAAoBf,CAAW,EAOxD,GAA2Cc,EAAkB,OAAS,gBAAkBA,EAAiB,WAAa,KAClH,MAAMoC,EAAuB,EAGjC,GAAI,CACA,KAAK,iBAAiB,QAAQpC,EAAkBb,CAAM,GAElDC,GAAawE,GAAmB,IAAI,IACpC,KAAK,iBAAiB,WAAW5D,EAAkBb,CAAM,CAEjE,OAAS0E,EAAK,CAEV,MAAIA,EAAI,OAAS,GACP1B,EAAwB,EAG5B0B,CACV,CAKA,GAHoC7E,GAAwC,KAAME,EAAaC,EAAQC,CAAS,EAG/E,CAC7B,IAAM0E,EAASxB,EAAa,CAAC,IAAI,EAAGpD,CAAW,EAE/C6E,GAAuBD,EAAQ7B,EAA4B7C,CAAS,CAAC,CACzE,CACJ,CAKO,WACH4E,EACA7E,EACAyB,EAAc,CAEd,IAAIa,EAEEuB,EAAgBR,EAAiB,KAAK,QAAQ,EAC9CpD,EAAYwD,EAA4BI,CAAa,EAE3D,GAAIgB,IAAwB,OACxBvC,EAAeF,GAAoB,KAAMnC,CAAS,UAC3C,OAAO4E,GAAwB,SAAU,CAChD,GAAIA,EAAsB,GAAKA,GAAuB,KAAK,gBACvD,MAAM9B,EAAoB,EAG9BT,EAAeE,GAAyB,KAAMvC,EAAW4E,CAAmB,CAChF,KAAO,CAKH,GAJI7E,IAAW,SAAcA,EAAS,GAAKA,GAAU,KAAK,kBAItDoE,GAAYS,CAAmB,GAAKpD,IAAU,SAAcA,EAAQ,GAAKA,GAASoD,EAAoB,gBACtG,MAAM9B,EAAoB,EAK9B,GAFAT,EAAeG,GAA8B,KAAMxC,EAAW4E,EAAqB7E,EAAQyB,CAAK,EAE5Fa,EAAa,SAAW,EACxB,MAAMU,EAAwB,CAEtC,CAGA,QAAWjD,KAAeuC,EAAc,CACpC,IAAMqC,EAASxB,EAAa,CAAC,IAAI,EAAGpD,CAAW,EAE/C6E,GAAuBD,EAAQzB,CAAqB,CACxD,CACJ,GCveR,IAAA4B,GAAoC,SAIvBC,GAAqD,CAC9DC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,IAEO,CACHC,EACAC,EACAC,EACAC,EAA0B,KAC1BC,EAA0B,OACb,CAEb,IAAMC,EAAeH,EAAiB,MAChCI,EAAsB,IAAI,uBAAoBD,CAAY,EAC1DE,EAAqBN,EAAoCX,EAAyBgB,CAAmB,EAAI,KACzGE,EAAa,CACf,IAAI,cAAY,CACZ,OAAOH,CACX,EACA,IAAI,UAAQ,CACR,OAAOF,IAAa,KAAOD,EAAiB,SAAWC,CAC3D,EACA,IAAI,UAAQ,CACR,OAAOC,IAAa,KAAOF,EAAiB,SAAWE,CAC3D,EACA,IAAI,OAAK,CACL,OAAOF,EAAiB,KAC5B,EACA,IAAI,MAAMO,EAAK,CACXP,EAAiB,MAAQO,EAGzBD,EAAW,eAAeC,EAAOT,EAAU,QAAQ,WAAW,CAClE,EACA,oBAAoBU,EAAkB,CAElC,GAAI,OAAOR,EAAiB,qBAAwB,WAC5CK,IAAuB,MACvBD,EAAoB,MAAMN,EAAU,QAAQ,WAAW,EAG3DM,EAAoB,IAAIf,EAAmCmB,CAAU,CAAC,EACtER,EAAiB,oBAAoBQ,CAAU,MAC5C,CACH,IAAMC,EAAoB,MAAM,KAAKL,CAAmB,EAAE,IAAG,EAEzDC,IAAuB,MACvBD,EAAoB,MAAMN,EAAU,QAAQ,WAAW,EAG3DM,EAAoB,IAAIf,EAAmCmB,CAAU,CAAC,EAEtE,IAAME,EAAmB,MAAM,KAAKN,CAAmB,EAAE,IAAG,EAE5DJ,EAAiB,sBAAsBQ,CAAU,EAE7CC,IAAsBC,GAAoBA,IAAqB,SAC3DA,EAAiB,OAAS,yBAC1BV,EAAiB,6BAA6BU,EAAiB,MAAOA,EAAiB,OAAO,EACvFA,EAAiB,OAAS,oBACjCV,EAAiB,wBAAwBU,EAAiB,MAAOA,EAAiB,OAAO,EAClFA,EAAiB,OAAS,WACjCV,EAAiB,eAAeU,EAAiB,MAAOA,EAAiB,SAAS,EAC3EA,EAAiB,OAAS,iBACjCV,EAAiB,oBACbU,EAAiB,OACjBA,EAAiB,UACjBA,EAAiB,QAAQ,EAIzC,CAEA,OAAOJ,CACX,EACA,sBAAsBE,EAAkB,CACpC,OAAIH,IAAuB,MACvBD,EAAoB,MAAMN,EAAU,QAAQ,WAAW,EAG3DM,EAAoB,IAAId,EAA2CkB,CAAU,CAAC,EAC9ER,EAAiB,sBAAsBQ,CAAU,EAE1CF,CACX,EACA,6BAA6BC,EAAeI,EAAe,CAEvD,GAAIJ,IAAU,EACV,MAAM,IAAI,WAId,GAAI,CAAC,OAAO,SAASI,CAAO,GAAKA,EAAU,EACvC,MAAM,IAAI,WAGd,IAAMC,EAAcd,EAAU,QAAQ,YAEtC,OAAIO,IAAuB,MACvBD,EAAoB,MAAMQ,CAAW,EAIrC,MAAM,KAAKR,CAAmB,EAAE,SAAW,IAC3CA,EAAoB,IAAIV,EAA8BS,EAAcS,CAAW,CAAC,EAChFZ,EAAiB,eAAeG,EAAcS,CAAW,GAG7DR,EAAoB,IAAIb,EAA4CgB,EAAOI,CAAO,CAAC,EACnFX,EAAiB,6BAA6BO,EAAOI,CAAO,EAErDL,CACX,EACA,wBAAwBC,EAAeI,EAAe,CAClD,IAAMC,EAAcd,EAAU,QAAQ,YAEtC,OAAIO,IAAuB,MACvBD,EAAoB,MAAMQ,CAAW,EAIrC,MAAM,KAAKR,CAAmB,EAAE,SAAW,IAC3CA,EAAoB,IAAIV,EAA8BS,EAAcS,CAAW,CAAC,EAChFZ,EAAiB,eAAeG,EAAcS,CAAW,GAG7DR,EAAoB,IAAIZ,EAAuCe,EAAOI,CAAO,CAAC,EAC9EX,EAAiB,wBAAwBO,EAAOI,CAAO,EAEhDL,CACX,EACA,gBAAgBO,EAAgBC,EAAmBC,EAAoB,CACnE,OAAIV,IAAuB,MACvBD,EAAoB,MAAMN,EAAU,QAAQ,WAAW,EAG3DM,EAAoB,IAAIX,EAA+BoB,EAAQC,EAAWC,CAAY,CAAC,EACvFf,EAAiB,gBAAgBa,EAAQC,EAAWC,CAAY,EAEzDT,CACX,EACA,eAAeC,EAAeO,EAAiB,CAC3C,OAAIT,IAAuB,MACvBD,EAAoB,MAAMN,EAAU,QAAQ,WAAW,EAG3DM,EAAoB,IAAIV,EAA8Ba,EAAOO,CAAS,CAAC,EACvEd,EAAiB,eAAeO,EAAOO,CAAS,EAEzCR,CACX,EACA,oBAAoBU,EAA0BF,EAAmBG,EAAgB,CAE7E,IAAMC,EAAkBF,aAAkB,aAAeA,EAAS,IAAI,aAAaA,CAAM,EAMzF,GAAIpB,IAAkC,MAAQA,EAA8B,OAAS,qBAAsB,CACvG,IAAMe,EAAUG,EAAYG,EACtBE,EAAarB,EAAU,QAAQ,WAC/BsB,EAAc,KAAK,KAAKN,EAAYK,CAAU,EAC9CE,EAAa,KAAK,MAAMV,EAAUQ,CAAU,EAC5CG,EAA6BD,EAAaD,EAC1CG,EAAqB,IAAI,aAAaD,CAA0B,EAEtE,QAASE,EAAI,EAAGA,EAAIF,EAA4BE,GAAK,EAAG,CACpD,IAAMC,GAAmBP,EAAgB,OAAS,GAAKD,IAAcG,EAAcI,GAAKL,EAAaL,GAC/FY,EAAa,KAAK,MAAMD,CAAc,EACtCE,EAAa,KAAK,KAAKF,CAAc,EAE3CF,EAAmBC,CAAC,EAChBE,IAAeC,EACTT,EAAgBQ,CAAU,GACzB,GAAKD,EAAiBC,IAAeR,EAAgBQ,CAAU,GAC/D,GAAKC,EAAaF,IAAmBP,EAAgBS,CAAU,CAC9E,CAEItB,IAAuB,MACvBD,EAAoB,MAAMN,EAAU,QAAQ,WAAW,EAG3DM,EAAoB,IAAIT,EAAmC4B,EAAoBT,EAAWG,CAAQ,CAAC,EACnGjB,EAAiB,oBAAoBuB,EAAoBT,EAAWG,CAAQ,EAE5E,IAAMW,EAAmBP,EAAaF,EAElCS,EAAmBjB,GACnBd,EAA4BS,EAAYiB,EAAmBA,EAAmB,OAAS,CAAC,EAAGK,CAAgB,EAG/G/B,EAA4BS,EAAYY,EAAgBA,EAAgB,OAAS,CAAC,EAAGP,CAAO,CAChG,MACQN,IAAuB,MACvBD,EAAoB,MAAMN,EAAU,QAAQ,WAAW,EAG3DM,EAAoB,IAAIT,EAAmCuB,EAAiBJ,EAAWG,CAAQ,CAAC,EAChGjB,EAAiB,oBAAoBkB,EAAiBJ,EAAWG,CAAQ,EAG7E,OAAOX,CACX,GAGJ,OAAAnB,EAAgB,IAAImB,EAAYN,CAAgB,EAChDd,EAAyB,IAAIoB,EAAYR,CAAS,EAElDb,EACIqB,EAC2FD,CAAkB,EAG1GC,CACX,ECpOG,IAAMuB,GAAwDC,IAC1D,CACH,OAAOC,EAA6B,CAChC,QAAWC,KAAmBF,EAC1B,GAAIE,EAAgB,OAAS,yBAA0B,CACnD,GAAM,CAAE,QAAAC,EAAS,MAAAC,CAAK,EAAKF,EAE3BD,EAAW,6BAA6BG,EAAOD,CAAO,CAC1D,SAAWD,EAAgB,OAAS,oBAAqB,CACrD,GAAM,CAAE,QAAAC,EAAS,MAAAC,CAAK,EAAKF,EAE3BD,EAAW,wBAAwBG,EAAOD,CAAO,CACrD,SAAWD,EAAgB,OAAS,YAAa,CAC7C,GAAM,CAAE,UAAAG,EAAW,OAAAC,EAAQ,aAAAC,CAAY,EAAKL,EAE5CD,EAAW,gBAAgBK,EAAQD,EAAWE,CAAY,CAC9D,SAAWL,EAAgB,OAAS,WAAY,CAC5C,GAAM,CAAE,UAAAG,EAAW,MAAAD,CAAK,EAAKF,EAE7BD,EAAW,eAAeG,EAAOC,CAAS,CAC9C,SAAWH,EAAgB,OAAS,gBAAiB,CACjD,GAAM,CAAE,SAAAM,EAAU,UAAAH,EAAW,OAAAI,CAAM,EAAKP,EAExCD,EAAW,oBAAoBQ,EAAQJ,EAAWG,CAAQ,CAC9D,KACI,OAAM,IAAI,MAAM,oCAAoC,CAGhE,IC5BF,IAAOE,GAAP,KAAkB,CAGpB,YAAYC,EAAoB,CAC5B,KAAK,KAAO,IAAI,IAAIA,CAAU,CAClC,CAEA,IAAI,MAAI,CACJ,OAAO,KAAK,KAAK,IACrB,CAEO,SAAO,CACV,OAAO,KAAK,KAAK,QAAO,CAC5B,CAEO,QAAQC,EAAoEC,EAAe,KAAI,CAClG,OAAO,KAAK,KAAK,QAAQ,CAACC,EAAUC,IAAWH,EAAS,KAAKC,EAASC,EAAOC,EAAK,IAAI,CAAC,CAC3F,CAEO,IAAIC,EAAO,CACd,OAAO,KAAK,KAAK,IAAIA,CAAI,CAC7B,CAEO,IAAIA,EAAO,CACd,OAAO,KAAK,KAAK,IAAIA,CAAI,CAC7B,CAEO,MAAI,CACP,OAAO,KAAK,KAAK,KAAI,CACzB,CAEO,QAAM,CACT,OAAO,KAAK,KAAK,OAAM,CAC3B,GCZJ,IAAMC,GAAkB,CACpB,aAAc,EAEd,iBAAkB,WAClB,sBAAuB,WACvB,eAAgB,EAChB,gBAAiB,EACjB,cAAe,CAAA,EACf,iBAAkB,CAAA,GAGTC,GAAyE,CAClFC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,IAEO,cACKZ,CAAkD,CAS1D,YAAYa,EAAYC,EAAcC,EAA2C,OAC7E,IAAMC,EAAgBV,EAAiBO,CAAO,EACxCI,EAAYV,EAA4BS,CAAa,EACrDE,EAAgBT,EAAgC,CAAE,GAAGZ,GAAiB,GAAGkB,CAAO,CAAE,EAGxFJ,EAAuCO,CAAa,EAEpD,IAAMC,EAAoCC,GAAwC,IAAIJ,CAAa,EAC7FK,EAAuBF,GAAmC,IAAIL,CAAI,EAElEQ,EACFL,GAAaD,EAAc,QAAU,SAC/BA,GACAO,EAAAlB,EAAkDW,CAAa,KAAC,MAAAO,IAAA,OAAAA,EAAIP,EACxEQ,EAAyBrB,EAC3BmB,EACAL,EAAY,KAAoCJ,EAAU,YAC1DL,EACAM,EACAO,EACAH,CAAa,EAEXO,EACDR,EAAYf,EAA+BY,EAAMI,EAAeG,CAAoB,EAAI,KAO7F,MAAMR,EAAS,GAAMW,EAAwBC,CAAwB,EAErE,IAAMC,EAAsC,CAAA,EAE5CF,EAAuB,WAAW,QAAQ,CAACG,EAAkBC,IAAM,CAC/D,IAAMC,EAAa5B,EAAiB,KAAMgB,EAAWU,CAAgB,EAErED,EAAW,KAAK,CAACE,EAAIC,CAAU,CAAC,CACpC,CAAC,EAED,KAAK,wBAA0BL,EAC/B,KAAK,kBAAoB,KACzB,KAAK,YAAc,IAAIM,GAAYJ,CAAU,EAMzCT,GACAlB,EAA8BiB,EAAsF,IAAI,EAG5H,GAAM,CAAE,aAAAe,CAAY,EAAK3B,EAAwB,IAAI,EAErDM,EAAgCc,EAAwBO,CAAY,CACxE,CAEA,IAAI,kBAAgB,CAChB,OAAO,KAAK,iBAChB,CAEA,IAAI,iBAAiBC,EAAK,CACtB,IAAMC,EAAkB,OAAOD,GAAU,WAAapB,EAAkB,KAA0CoB,CAAK,EAAI,KAE3H,KAAK,wBAAwB,iBAAmBC,EAEhD,IAAMC,EAAyB,KAAK,wBAAwB,iBAE5D,KAAK,kBACDA,IAA2B,MAAQA,IAA2BD,EACxDD,EACiCE,CAC/C,CAEA,IAAI,YAAU,CACV,OAAI,KAAK,cAAgB,KAE2B,KAAK,wBAAwB,WAG1E,KAAK,WAChB,CAEA,IAAI,MAAI,CACJ,OAAO,KAAK,wBAAwB,IACxC,GClIF,SAAUC,GACZC,EAEAC,EACAC,EACAC,EACAC,EAAoB,CAEpB,GAAI,OAAOJ,EAAY,iBAAoB,WAEnCC,EAAOC,CAAG,EAAE,aAAe,IAC3BD,EAAOC,CAAG,EAAI,IAAI,aAAa,GAAG,GAGtCF,EAAY,gBAAgBC,EAAOC,CAAG,EAAGC,EAAeC,CAAY,MAGjE,CACH,IAAMC,EAAcL,EAAY,eAAeG,CAAa,EAG5D,GAAIF,EAAOC,CAAG,EAAE,aAAe,EAC3BD,EAAOC,CAAG,EAAIG,EAAY,MAAMD,EAAcA,EAAe,GAAG,MAC7D,CACH,IAAME,EAAc,IAAI,aAAaD,EAAY,OAAQD,EAAe,aAAa,kBAAmB,GAAG,EAE3GH,EAAOC,CAAG,EAAE,IAAII,CAAW,CAC/B,CACJ,CACJ,CC3CO,IAAMC,GAAgB,CACzBC,EACAC,EACAC,EACAC,EACAC,IACM,CACF,OAAOJ,EAAY,eAAkB,WAEjCC,EAAOC,CAAG,EAAE,aAAe,GAC3BF,EAAY,cAAcC,EAAOC,CAAG,EAAGC,EAAeC,CAAY,EAMlEH,EAAOC,CAAG,EAAE,aAAe,GAC3BF,EAAY,eAAeG,CAAa,EAAE,IAAIF,EAAOC,CAAG,EAAGE,CAAY,CAGnF,ECtBO,IAAMC,GAAqB,CAACC,EAAWC,IAA0C,CACpF,IAAMC,EAA2B,CAAA,EAEjC,QAASC,EAAI,EAAGA,EAAIH,EAAGG,GAAK,EAAG,CAC3B,IAAMC,EAAQ,CAAA,EAERC,EAAS,OAAOJ,GAAM,SAAWA,EAAIA,EAAEE,CAAC,EAE9C,QAASG,EAAI,EAAGA,EAAID,EAAQC,GAAK,EAC7BF,EAAM,KAAK,IAAI,aAAa,GAAG,CAAC,EAGpCF,EAAO,KAAKE,CAAK,CACrB,CAEA,OAAOF,CACX,ECVO,IAAMK,GAA2B,CACpCC,EACAC,IACiC,CACjC,IAAMC,EAAqBC,GAAeC,GAAwBJ,CAAyB,EACrFK,EAAyBC,EAA+CL,CAAK,EAEnF,OAAOE,GAAeD,EAAoBG,CAAsB,CACpE,ECaA,IAAME,GAAgB,MAClBC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,IACoC,CAGpC,IAAMC,EAASN,IAAmB,KAAO,KAAK,KAAKD,EAAM,QAAQ,OAAS,GAAG,EAAI,IAAMC,EAAe,OAChGO,EAAwBL,EAAQ,aAAeA,EAAQ,eACvDM,EAAyBL,EAAmB,OAAO,CAACM,EAAKC,IAAUD,EAAMC,EAAO,CAAC,EACjFC,EACFH,IAA2B,EACrB,KACAP,EAA0B,aAAaO,EAAwBF,EAAQL,EAA0B,UAAU,EAErH,GAAIG,IAAyB,OACzB,MAAM,IAAI,MAAM,oCAAoC,EAGxD,IAAMQ,EAAuBC,GAAwBd,CAAK,EACpDe,EAAwB,MAAMC,GAAyBd,EAA2BF,CAAK,EACvFiB,EAASC,GAAmBf,EAAQ,eAAgBA,EAAQ,YAAY,EACxEgB,EAAUD,GAAmBf,EAAQ,gBAAiBC,CAAkB,EACxEgB,EAA+C,MAAM,KAAKpB,EAAM,WAAW,KAAI,CAAE,EAAE,OACrF,CAACqB,EAAQC,KAAU,CAAE,GAAGD,EAAQ,CAACC,CAAI,EAAG,IAAI,aAAa,GAAG,CAAC,GAC7D,CAAA,CAAE,EAGN,QAASC,EAAI,EAAGA,EAAIhB,EAAQgB,GAAK,IAAK,CAClC,GAAIpB,EAAQ,eAAiB,GAAKF,IAAmB,KACjD,QAASuB,EAAI,EAAGA,EAAIrB,EAAQ,eAAgBqB,GAAK,EAC7C,QAASC,EAAI,EAAGA,EAAItB,EAAQ,aAAcsB,GAAK,EAC3CC,GAAgBzB,EAAgBgB,EAAOO,CAAC,EAAGC,EAAGA,EAAGF,CAAC,EAK1DlB,EAAqB,uBAAyB,QAAaJ,IAAmB,MAC9EI,EAAqB,qBAAqB,QAAQ,CAAC,CAAE,KAAAiB,CAAI,EAAIK,IAAS,CAClED,GAAgBzB,EAAgBmB,EAAYE,EAAMd,EAAwBmB,EAAOJ,CAAC,CACtF,CAAC,EAGL,QAASC,EAAI,EAAGA,EAAIrB,EAAQ,eAAgBqB,GAAK,EAC7C,QAASC,EAAI,EAAGA,EAAIrB,EAAmBoB,CAAC,EAAGC,GAAK,EAExCN,EAAQK,CAAC,EAAEC,CAAC,EAAE,aAAe,IAC7BN,EAAQK,CAAC,EAAEC,CAAC,EAAI,IAAI,aAAa,GAAG,GAKhD,GAAI,CACA,IAAMG,EAAyBX,EAAO,IAAI,CAACY,EAAOF,IAC1Cd,EAAqB,aAAac,CAAK,EAAE,OAAS,EAC3C,CAAA,EAGJE,CACV,EACKC,EAAmBxB,EACrBiB,EAAIrB,EAA0B,WAC9BA,EAA0B,WAC1B,IAAMa,EAAsB,QAAQa,EAAwBT,EAASC,CAAU,CAAC,EAGpF,GAAIR,IAAoB,KACpB,QAASY,EAAI,EAAGO,EAAkC,EAAGP,EAAIrB,EAAQ,gBAAiBqB,GAAK,EAAG,CACtF,QAASC,EAAI,EAAGA,EAAIrB,EAAmBoB,CAAC,EAAGC,GAAK,EAC5CO,GAAcpB,EAAiBO,EAAQK,CAAC,EAAGC,EAAGM,EAAkCN,EAAGF,CAAC,EAGxFQ,GAAmC3B,EAAmBoB,CAAC,CAC3D,CAGJ,GAAI,CAACM,EACD,KAER,OAASG,EAAO,CACZjC,EAAM,cACF,IAAI,WAAW,iBAAkB,CAC7B,MAAOiC,EAAM,MACb,SAAUA,EAAM,SAChB,OAAQA,EAAM,OACd,QAASA,EAAM,QAClB,CAAC,EAGN,KACJ,CACJ,CAEA,OAAOrB,CACX,EAEasB,GAAiF,CAC1FC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACArC,EACAsC,EACAC,EACAC,EACAC,EACAC,EACAC,IAEO,CACH3B,EACAnB,EACAE,IACA,CACA,IAAM6C,EAA2B,IAAI,QAEjCC,EAAoE,KAElEC,EAAkB,MAAOpD,EAA6BE,IAAyD,CACjH,IAAImD,EAAyBT,EAA+C5C,CAAK,EAC7EsD,EAAsG,KAEpGC,EAAyCC,EAAiBH,EAAwBnD,CAAyB,EAC3GE,EAAqB,MAAM,QAAQD,EAAQ,kBAAkB,EAC7DA,EAAQ,mBACR,MAAM,KAAKA,EAAQ,kBAAkB,EAG3C,GAAI0C,IAAsC,KAAM,CAC5C,IAAMpC,EAAyBL,EAAmB,OAAO,CAACM,EAAKC,IAAUD,EAAMC,EAAO,CAAC,EACjF8C,EAA4BlB,EAAgCrC,EAA2B,CACzF,aAAc,KAAK,IAAI,EAAGO,CAAsB,EAChD,iBAAkB,WAClB,sBAAuB,WACvB,gBAAiB,KAAK,IAAI,EAAGA,CAAsB,EACtD,EACKiD,EAAuD,CAAA,EAE7D,QAASnC,EAAI,EAAGA,EAAIvB,EAAM,gBAAiBuB,GAAK,EAC5CmC,EAAyB,KACrBpB,EAA8BpC,EAA2B,CACrD,aAAc,EACd,iBAAkB,WAClB,sBAAuB,WACvB,eAAgBE,EAAmBmB,CAAC,EACvC,CAAC,EAIV,IAAMoC,EAAiBlB,EAAqBvC,EAA2B,CACnE,aAAcC,EAAQ,aACtB,iBAAkBA,EAAQ,iBAC1B,sBAAuBA,EAAQ,sBAC/B,KAAM,EACT,EAEDwD,EAAe,QAAuCvB,EAAuB,KAAK,KAAMsB,CAAwB,EAChHC,EAAe,WAA6ChB,EAA0B,KAAK,KAAMe,CAAwB,EAEzHJ,EAAoB,CAACG,EAA2BC,EAA0BC,CAAc,CAC5F,MAAYJ,IACRF,EAAyB,IAAIR,EAAkC3C,EAA2BoB,CAAI,GAQlG,GALA4B,EAAyB,IACrBhD,EACAoD,IAAsB,KAAOD,EAAyBC,EAAkB,CAAC,CAAC,EAG1EA,IAAsB,KAAM,CAC5B,GAAIH,IAA2B,KAAM,CACjC,GAAI9C,IAAyB,OACzB,MAAM,IAAI,MAAM,oCAAoC,EAGxD,GAAIyC,IAAyC,KACzC,MAAM,IAAI,MAAM,qDAAqD,EAIzE,IAAMtC,EAAwBR,EAAM,aAAeA,EAAM,eACnD4D,EACFvD,EAAqB,uBAAyB,OAAY,EAAIA,EAAqB,qBAAqB,OACtGwD,EAAmBrD,EAAwBoD,EA4EjDT,EAAyBpD,GACrBC,EACA6D,IAAqB,EAAI,KAAO,MA5Ef,SAAW,CAC5B,IAAMC,EAA6B,IAAIhB,EACnCe,EAGA,KAAK,KAAK7D,EAAM,QAAQ,OAAS,GAAG,EAAI,IACxCE,EAA0B,UAAU,EAElC6D,EAA+B,CAAA,EAC/BC,GAA4B,CAAA,EAElC,QAASzC,EAAI,EAAGA,EAAIpB,EAAQ,eAAgBoB,GAAK,EAC7CwC,EAAU,KACNtB,EAAqBqB,EAA4B,CAC7C,aAAc3D,EAAQ,aACtB,iBAAkBA,EAAQ,iBAC1B,sBAAuBA,EAAQ,sBAC/B,KAAM,EACT,CAAC,EAEN6D,GAA0B,KACtBzB,EAAgCuB,EAA4B,CACxD,aAAc3D,EAAQ,aACtB,iBAAkB,WAClB,sBAAuB,WACvB,gBAAiBA,EAAQ,aAC5B,CAAC,EAIV,IAAM8D,GAAsB,MAAM,QAAQ,IACtC,MAAM,KAAKjE,EAAM,WAAW,OAAM,CAAE,EAAE,IAAI,MAAOkE,GAAc,CAC3D,IAAMC,GAAqB3B,EAA+BsB,EAA4B,CAClF,aAAc,EACd,iBAAkB,WAClB,sBAAuB,WACvB,OAAQI,EAAW,MACtB,EAED,aAAMnB,EAAiBe,EAA4BI,EAAYC,GAAmB,MAAM,EAEjFA,EACX,CAAC,CAAC,EAGAC,EAAyB9B,EAA8BwB,EAA4B,CACrF,aAAc,EACd,iBAAkB,WAClB,sBAAuB,WACvB,eAAgB,KAAK,IAAI,EAAGtD,EAAwBoD,CAAkB,EACzE,EAED,QAASrC,EAAI,EAAGA,EAAIpB,EAAQ,eAAgBoB,GAAK,EAAG,CAChDwC,EAAUxC,CAAC,EAAE,QAAQyC,GAA0BzC,CAAC,CAAC,EAEjD,QAASC,GAAI,EAAGA,GAAIrB,EAAQ,aAAcqB,IAAK,EAC3CwC,GAA0BzC,CAAC,EAAE,QAAQ6C,EAAwB5C,GAAGD,EAAIpB,EAAQ,aAAeqB,EAAC,CAEpG,CAEA,OAAW,CAACG,EAAOwC,EAAkB,IAAKF,GAAoB,QAAO,EACjEE,GAAmB,QAAQC,EAAwB,EAAG5D,EAAwBmB,CAAK,EACnFwC,GAAmB,MAAM,CAAC,EAG9B,OAAAC,EAAuB,QAAQN,EAA2B,WAAW,EAErE,MAAM,QAAQ,IACVC,EAAU,IAAKM,GAAarB,EAAwBhD,EAAO8D,EAA4BO,CAAQ,CAAC,CAAC,EAG9FpB,EAAgCa,CAA0B,CACrE,GAIsD,EAClD5D,EACAC,EACAC,EACAC,EACAC,CAAgC,CAExC,CAEA,IAAMM,EAAkB,MAAMuC,EACxBmB,EAAwBjC,EAAkCnC,EAA2B,CACvF,OAAQ,KACR,aAAc,EACd,iBAAkB,MAClB,sBAAuB,WACvB,KAAM,GACN,QAAS,EACT,UAAW,EACX,aAAc,EACjB,EACK,CAACuD,EAA2BC,EAA0BC,CAAc,EAAIL,EAE1E1C,IAAoB,OACpB0D,EAAsB,OAAS1D,EAC/B0D,EAAsB,MAAM,CAAC,GAGjCA,EAAsB,QAAQb,CAAyB,EAEvD,QAASlC,EAAI,EAAGQ,EAAkC,EAAGR,EAAIvB,EAAM,gBAAiBuB,GAAK,EAAG,CACpF,IAAMgD,EAA0Bb,EAAyBnC,CAAC,EAE1D,QAASC,EAAI,EAAGA,EAAIpB,EAAmBmB,CAAC,EAAGC,GAAK,EAC5CiC,EAA0B,QAAQc,EAAyBxC,EAAkCP,EAAGA,CAAC,EAGrGO,GAAmC3B,EAAmBmB,CAAC,CAC3D,CAEA,OAAOoC,CACX,CAEA,GAAKJ,EAUD,OAAW,CAACiB,EAAIN,CAAU,IAAKlE,EAAM,WAAW,QAAO,EACnD,MAAMmC,EACFjC,EACAgE,EAE6Db,EAAuB,WAAY,IAAImB,CAAE,CAAC,MAd/G,QAAW,CAACA,EAAIN,CAAU,IAAKlE,EAAM,WAAW,QAAO,EACnD,MAAM+C,EACF7C,EACAgE,EAE6Db,EAAuB,WAAY,IAAImB,CAAE,CAAC,EAcnH,aAAMxB,EAAwBhD,EAAOE,EAA2BmD,CAAsB,EAE/EA,CACX,EAEA,MAAO,CACH,OACIrD,EACAE,EAAqD,CAErDwC,EAAiCxC,EAA2BF,CAAK,EAEjE,IAAMyE,EAA2CvB,EAAyB,IAAIhD,CAAyB,EAEvG,OAAIuE,IAA6C,OACtC,QAAQ,QAAQA,CAAwC,EAG5DrB,EAAgBpD,EAAOE,CAAyB,CAC3D,EAER,ECpWG,IAAMwE,GAAyE,CAClFC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,IAEO,cAAmDL,CAAqC,CAG3F,YAAoBM,EAAgCC,EAAwB,CACxE,MAAMD,EAAgBC,CAAgB,EADtB,KAAA,eAAAD,EAGhB,KAAK,cACDpB,IAA0B,OACpB,OACA,CACI,UAAW,CAACsB,EAAmBC,IACpBvB,EAAmC,KAAOsB,EAAWC,CAAO,EAGzF,CAEA,IAAI,cAAY,CACZ,OAAO,KAAK,aAChB,CAEO,gBAAc,CACjB,OAAO,IAAItB,EAAqC,IAAK,CACzD,CAEO,oBAAkB,CACrB,OAAO,IAAIG,EAAyC,IAAK,CAC7D,CAEO,aAAaiB,EAA0BG,EAAgBC,EAAkB,CAC5E,OAAO,IAAIvB,EAAuB,CAAE,OAAAsB,EAAQ,iBAAAH,EAAkB,WAAAI,CAAU,CAAE,CAC9E,CAEO,oBAAkB,CACrB,OAAO,IAAItB,EAA8C,IAAK,CAClE,CAEO,oBAAoBuB,EAAiB,EAAC,CACzC,OAAO,IAAIrB,EAA0C,KAAO,CAAE,eAAAqB,CAAc,CAAE,CAClF,CAEO,sBAAsBC,EAAkB,EAAC,CAC5C,OAAO,IAAIrB,EAA4C,KAAO,CAAE,gBAAAqB,CAAe,CAAE,CACrF,CAEO,sBAAoB,CACvB,OAAO,IAAIpB,EAA2C,IAAK,CAC/D,CAEO,iBAAe,CAClB,OAAO,IAAIC,EAAsC,IAAK,CAC1D,CAEO,YAAYoB,EAAe,EAAC,CAC/B,OAAO,IAAIlB,EAAkC,KAAO,CAAE,aAAAkB,CAAY,CAAE,CACxE,CAEO,0BAAwB,CAC3B,OAAO,IAAIjB,EAA+C,IAAK,CACnE,CAEO,YAAU,CACb,OAAO,IAAIC,EAAiC,IAAK,CACrD,CAEO,gBAAgBiB,EAA+BC,EAA0B,CAC5E,OAAO,IAAIjB,EAAsC,KAAO,CAAE,SAAAiB,EAAU,YAAAD,CAAW,CAAE,CACrF,CAEO,kBAAgB,CACnB,OAAO,IAAId,EAAuC,IAAK,CAC3D,CAEO,cAAY,CACf,OAAO,IAAIC,EAAmC,IAAK,CACvD,CAEO,mBACHe,EACAC,EACAC,EAAiD,CAAE,qBAAsB,EAAK,EAAE,CAEhF,OAAO,IAAIhB,EAAqC,KAAO,CAAE,GAAGgB,EAAa,KAAAD,EAAM,KAAAD,CAAI,CAAE,CACzF,CAEO,oBAAkB,CACrB,OAAO,IAAIb,EAAyC,IAAK,CAC7D,CAEO,kBAAgB,CACnB,OAAO,IAAIC,EAAuC,IAAK,CAC3D,CAEO,gBACHe,EACAC,EACAC,EAAoC,CAEpC,OAAO3B,EAAgB,KAAK,eAAgByB,CAAS,EAAE,KAClDG,IACO,OAAOF,GAAoB,YAC3BA,EAAgBE,CAAW,EAGxBA,GAEVC,GAAO,CACJ,MAAI,OAAOF,GAAkB,YACzBA,EAAcE,CAAG,EAGfA,CACV,CAAC,CAET,GC3JR,IAAMC,GAAkB,CACpB,EAAG,EACH,aAAc,EACd,iBAAkB,MAClB,sBAAuB,WACvB,OAAQ,EACR,UAAW,IACX,KAAM,EACN,KAAM,WAGGC,GAAyE,CAClFC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,IAEO,cAAmDP,CAAuB,CAW7E,YAAYQ,EAAYC,EAAuC,CAC3D,IAAMC,EAAgBL,EAAiBG,CAAO,EACxCG,EAAgB,CAAE,GAAGb,GAAiB,GAAGW,CAAO,EAChDG,EAAyBR,EAA6BM,EAAeC,CAAa,EAClFE,EAAYP,EAA4BI,CAAa,EACrDI,EAAyDD,EAAYX,EAA8B,EAAK,KAE9G,MAAMM,EAAS,GAAOI,EAAwBE,CAAwB,EAGtE,KAAK,GAAKb,EAAiB,KAAMY,EAAWD,EAAuB,EAAGG,GAA4BC,EAA0B,EAE5H,KAAK,QAAUf,EACX,KACAY,EACAD,EAAuB,OACvB,KAAO,KAAK,KAAKG,EAA0B,EAC3C,MAAQ,KAAK,KAAKA,EAA0B,CAAC,EAGjD,KAAK,WAAad,EAAiB,KAAMY,EAAWD,EAAuB,UAAWJ,EAAQ,WAAa,EAAG,CAAC,EAE/G,KAAK,MAAQP,EACT,KACAY,EACAD,EAAuB,KACvB,GAAK,KAAK,MAAMG,EAA0B,EAC1CC,EAA0B,EAE9B,KAAK,wBAA0BJ,EAG/BL,EAAqB,KAAM,CAAC,CAChC,CAEA,IAAI,QAAM,CACN,OAAO,KAAK,OAChB,CAEA,IAAI,WAAS,CACT,OAAO,KAAK,UAChB,CAEA,IAAI,MAAI,CACJ,OAAO,KAAK,KAChB,CAEA,IAAI,GAAC,CACD,OAAO,KAAK,EAChB,CAEA,IAAI,MAAI,CACJ,OAAO,KAAK,wBAAwB,IACxC,CAEA,IAAI,KAAKU,EAAK,CACV,KAAK,wBAAwB,KAAOA,CACxC,CAEO,qBAAqBC,EAA2BC,EAA2BC,EAA2B,CAEzG,GAAI,CACA,KAAK,wBAAwB,qBAAqBF,EAAaC,EAAaC,CAAa,CAC7F,OAASC,EAAK,CACV,MAAIA,EAAI,OAAS,GACPlB,EAAwB,EAG5BkB,CACV,CAGA,GAAIH,EAAY,SAAWC,EAAY,QAAUA,EAAY,SAAWC,EAAc,OAClF,MAAMjB,EAAwB,CAEtC,GC3GD,IAAMmB,GAAiF,CAC1FC,EACAC,EACAC,EACAC,EACAC,IAEO,IAAmE,CACtE,IAAMC,EAAkC,IAAI,QAEtCC,EAAyB,MAAOC,EAA6BC,IAAyD,CACxH,IAAIC,EAAyBP,EAA+CK,CAAK,EAM3EG,EAAyCC,EAAiBF,EAAwBD,CAAyB,EAEjH,GAAI,CAACE,EAAwC,CACzC,IAAME,EAAU,CACZ,EAAGH,EAAuB,EAAE,MAC5B,aAAcA,EAAuB,aACrC,iBAAkBA,EAAuB,iBACzC,sBAAuBA,EAAuB,sBAC9C,OAAQA,EAAuB,OAAO,MACtC,UAAWA,EAAuB,UAAU,MAC5C,KAAMA,EAAuB,KAAK,MAClC,KAAMA,EAAuB,MAGjCA,EAAyBR,EAA6BO,EAA2BI,CAAO,CAC5F,CAEA,OAAAP,EAAgC,IAAIG,EAA2BC,CAAsB,EAEhFC,GAMD,MAAMV,EAAkBQ,EAA2BD,EAAM,EAAGE,EAAuB,CAAC,EACpF,MAAMT,EAAkBQ,EAA2BD,EAAM,OAAQE,EAAuB,MAAM,EAC9F,MAAMT,EAAkBQ,EAA2BD,EAAM,UAAWE,EAAuB,SAAS,EACpG,MAAMT,EAAkBQ,EAA2BD,EAAM,KAAME,EAAuB,IAAI,IAR1F,MAAMN,EAAiBK,EAA2BD,EAAM,EAAGE,EAAuB,CAAC,EACnF,MAAMN,EAAiBK,EAA2BD,EAAM,OAAQE,EAAuB,MAAM,EAC7F,MAAMN,EAAiBK,EAA2BD,EAAM,UAAWE,EAAuB,SAAS,EACnG,MAAMN,EAAiBK,EAA2BD,EAAM,KAAME,EAAuB,IAAI,GAQ7F,MAAML,EAAwBG,EAAOC,EAA2BC,CAAsB,EAE/EA,CACX,EAEA,MAAO,CACH,OAAOF,EAA6BC,EAAqD,CACrF,IAAMK,EAAiCR,EAAgC,IAAIG,CAAyB,EAEpG,OAAIK,IAAmC,OAC5B,QAAQ,QAAQA,CAA8B,EAGlDP,EAAuBC,EAAOC,CAAyB,CAClE,EAER,EClEG,IAAMM,GAAiD,CAACC,EAAcC,IAClE,CAACC,EAAQC,IAAQ,CACpB,IAAMC,EAAmBH,EAAY,IAAIC,CAAM,EAE/C,GAAIE,IAAqB,OACrB,OAAOA,EAGX,IAAMC,EAAcL,EAAa,IAAIE,CAAM,EAE3C,GAAIG,IAAgB,OAChB,OAAOA,EAGX,GAAI,CACA,IAAMC,EAAwBH,EAAI,EAElC,OAAIG,aAAiC,SACjCN,EAAa,IAAIE,EAAQI,CAAqB,EAEvCA,EACF,MAAM,IAAM,EAAK,EACjB,KAAMC,IACHP,EAAa,OAAOE,CAAM,EAC1BD,EAAY,IAAIC,EAAQK,CAAe,EAEhCA,EACV,IAGTN,EAAY,IAAIC,EAAQI,CAAqB,EAEtCA,EACX,MAAQ,CACJ,OAAAL,EAAY,IAAIC,EAAQ,EAAK,EAEtB,EACX,CACJ,ECrCJ,IAAMM,GAAkB,CACpB,aAAc,EACd,iBAAkB,WAClB,sBAAuB,WACvB,eAAgB,GAGPC,GAA2E,CACpFC,EACAC,EACAC,EACAC,EACAC,IAEO,cAAoDJ,CAAuB,CAC9E,YAAYK,EAAYC,EAAwC,CAC5D,IAAMC,EAAgBJ,EAAiBE,CAAO,EACxCG,EAAgB,CAAE,GAAGV,GAAiB,GAAGQ,CAAO,EAChDG,EAA0BP,EAA8BK,EAAeC,CAAa,EACpFE,EACDN,EAA4BG,CAAa,EAAIN,EAA+B,EAAK,KAGtF,MAAMI,EAAS,GAAOI,EAAyBC,CAAyB,CAC5E,GCvBD,IAAMC,GAAmF,CAC5FC,EACAC,EACAC,IAEO,IAAmE,CACtE,IAAMC,EAA2B,IAAI,QAE/BC,EAAkB,MAAOC,EAAsBC,IAAyD,CAC1G,IAAIC,EAAkBN,EAAwCI,CAAK,EAKnE,GAAI,CAFoCG,EAAiBD,EAAiBD,CAAyB,EAE7D,CAClC,IAAMG,EAAU,CACZ,aAAcF,EAAgB,aAC9B,iBAAkBA,EAAgB,iBAClC,sBAAuBA,EAAgB,sBACvC,eAAgBA,EAAgB,gBAGpCA,EAAkBP,EAA8BM,EAA2BG,CAAO,CACtF,CAEA,OAAAN,EAAyB,IAAIG,EAA2BC,CAAe,EAEvE,MAAML,EAAwBG,EAAOC,EAA2BC,CAAe,EAExEA,CACX,EAEA,MAAO,CACH,OAAOF,EAAsBC,EAAqD,CAC9E,IAAMI,EAA0BP,EAAyB,IAAIG,CAAyB,EAEtF,OAAII,IAA4B,OACrB,QAAQ,QAAQA,CAAuB,EAG3CN,EAAgBC,EAAOC,CAAyB,CAC3D,EAER,EC5CJ,IAAMK,GAAkB,CACpB,aAAc,EACd,iBAAkB,WAClB,sBAAuB,WACvB,gBAAiB,GAGRC,GAA+E,CACxFC,EACAC,EACAC,EACAC,EACAC,EACAC,IAEO,cAAsDL,CAAuB,CAChF,YAAYM,EAAYC,EAA0C,CAC9D,IAAMC,EAAgBL,EAAiBG,CAAO,EACxCG,EAAgBJ,EAA+B,CAAE,GAAGP,GAAiB,GAAGS,CAAO,CAAE,EACjFG,EAA4BR,EAAgCM,EAAeC,CAAa,EACxFE,EACDP,EAA4BI,CAAa,EAAIP,EAAiC,EAAK,KAGxF,MAAMK,EAAS,GAAOI,EAA2BC,CAA2B,CAChF,GCxBD,IAAMC,GAAuF,CAChGC,EACAC,EACAC,IAEO,IAAmE,CACtE,IAAMC,EAA2B,IAAI,QAE/BC,EAAkB,MAAOC,EAAsBC,IAAyD,CAC1G,IAAIC,EAAkBN,EAAwCI,CAAK,EAKnE,GAAI,CAFoCG,EAAiBD,EAAiBD,CAAyB,EAE7D,CAClC,IAAMG,EAAU,CACZ,aAAcF,EAAgB,aAC9B,iBAAkBA,EAAgB,iBAClC,sBAAuBA,EAAgB,sBACvC,gBAAiBA,EAAgB,iBAGrCA,EAAkBP,EAAgCM,EAA2BG,CAAO,CACxF,CAEA,OAAAN,EAAyB,IAAIG,EAA2BC,CAAe,EAEvE,MAAML,EAAwBG,EAAOC,EAA2BC,CAAe,EAExEA,CACX,EAEA,MAAO,CACH,OAAOF,EAAsBC,EAAqD,CAC9E,IAAMI,EAA0BP,EAAyB,IAAIG,CAAyB,EAEtF,OAAII,IAA4B,OACrB,QAAQ,QAAQA,CAAuB,EAG3CN,EAAgBC,EAAOC,CAAyB,CAC3D,EAER,EC7CG,IAAMK,GAAsDC,GACxD,CAACC,EAA2BC,EAAYC,IACpCH,EAAyBE,EAAYD,EAA2BE,CAAgB,ECDxF,IAAMC,GAAgEC,GAClE,CAACC,EAAkBC,EAAaC,EAAS,EAAGC,EAAQ,IAAK,CAC5D,IAAMC,EAAkBJ,EAAiBE,CAAM,EAE/C,GAAIE,IAAoB,OACpB,MAAML,EAAoB,EAG9B,OAAIM,GAAkBJ,CAAW,EACtBG,EAAgB,QAAQH,EAAa,EAAGE,CAAK,EAGjDC,EAAgB,QAAQH,EAAa,CAAC,CACjD,ECdG,IAAMK,GACTC,GAEO,CAACC,EAAeC,IAAmB,CACtC,IAAMC,EAA8BH,EAAkCC,EAAe,CACjF,OAAQ,KACR,aAAc,EACd,iBAAkB,MAClB,sBAAuB,WACvB,KAAM,GACN,QAAS,EACT,UAAW,EACX,aAAc,EACjB,EACKG,EAAoBH,EAAc,aAAa,EAAG,EAAG,KAAK,EAEhE,OAAAE,EAA4B,OAASC,EACrCD,EAA4B,KAAO,GAEnCA,EAA4B,QAAQD,CAAe,EACnDC,EAA4B,MAAK,EAE1B,IAAK,CACRA,EAA4B,KAAI,EAChCA,EAA4B,WAAWD,CAAe,CAC1D,CACJ,ECfJ,IAAMG,GAAkB,CACpB,aAAc,EACd,iBAAkB,MAClB,sBAAuB,WACvB,OAAQ,GAGCC,GAA6E,CACtFC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,IAEO,cACKN,CAA0D,CAWlE,YAAYO,EAAYC,EAAyC,CAC7D,IAAMC,EAAgBL,EAAiBG,CAAO,EACxCG,EAAgB,CAAE,GAAGZ,GAAiB,GAAGU,CAAO,EAChDG,EAA2BR,EAA+BM,EAAeC,CAAa,EACtFE,EAAYP,EAA4BI,CAAa,EACrDI,EACDD,EAAYV,EAAuC,EAAK,KAG7D,MAAMK,EAAS,GAAOI,EAA0BE,CAA0B,EAE1E,KAAK,4BAA8BA,EACnC,KAAK,0BAA4BF,EAKjC,KAAK,QAAUV,EACX,KACAW,EACAD,EAAyB,OACzBG,GACAC,EAA0B,EAE9B,KAAK,SAAW,IACpB,CAEA,IAAI,QAAM,CACN,OAAO,KAAK,OAChB,CAEA,IAAI,SAAO,CACP,OAAO,KAAK,QAChB,CAEA,IAAI,QAAQC,EAAK,CACb,IAAMC,EAAkB,OAAOD,GAAU,WAAaV,EAAkB,KAAMU,CAAK,EAAI,KAEvF,KAAK,0BAA0B,QAAUC,EAEzC,IAAMC,EAAgB,KAAK,0BAA0B,QAErD,KAAK,SAAWA,IAAkB,MAAQA,IAAkBD,EAAkBD,EAAQE,CAC1F,CAEO,MAAMC,EAAO,EAAC,CAOjB,GANA,KAAK,0BAA0B,MAAMA,CAAI,EAErC,KAAK,8BAAgC,OACrC,KAAK,4BAA4B,MAAQA,GAGzC,KAAK,QAAQ,QAAU,SAAU,CACjCC,GAAyB,IAAI,EAE7B,IAAMC,EAA8B,IAAK,CACrC,KAAK,0BAA0B,oBAAoB,QAASA,CAA2B,EAEnFC,GAAkB,IAAI,GACtBC,GAA0B,IAAI,CAEtC,EAEA,KAAK,0BAA0B,iBAAiB,QAASF,CAA2B,CACxF,CACJ,CAEO,KAAKF,EAAO,EAAC,CAChB,KAAK,0BAA0B,KAAKA,CAAI,EAEpC,KAAK,8BAAgC,OACrC,KAAK,4BAA4B,KAAOA,EAEhD,GC9GD,IAAMK,GAAqF,CAC9FC,EACAC,EACAC,EACAC,EACAC,IAEO,IAAmE,CACtE,IAAMC,EAAoC,IAAI,QAE1CC,EAAuB,KACvBC,EAAsB,KAEpBC,EAA2B,MAAOC,EAA+BC,IAAyD,CAC5H,IAAIC,EAA2BT,EAAiDO,CAAK,EAM/EG,EAA2CC,EAAiBF,EAA0BD,CAAyB,EAErH,GAAI,CAACE,EAA0C,CAC3C,IAAME,EAAU,CACZ,aAAcH,EAAyB,aACvC,iBAAkBA,EAAyB,iBAC3C,sBAAuBA,EAAyB,sBAChD,OAAQA,EAAyB,OAAO,OAG5CA,EAA2BV,EAA+BS,EAA2BI,CAAO,EAExFR,IAAU,MACVK,EAAyB,MAAML,CAAK,EAGpCC,IAAS,MACTI,EAAyB,KAAKJ,CAAI,CAE1C,CAEA,OAAAF,EAAkC,IAAIK,EAA2BC,CAAwB,EAEpFC,EAGD,MAAMZ,EAAkBU,EAA2BD,EAAM,OAAQE,EAAyB,MAAM,EAFhG,MAAMR,EAAiBO,EAA2BD,EAAM,OAAQE,EAAyB,MAAM,EAKnG,MAAMP,EAAwBK,EAAOC,EAA2BC,CAAwB,EAEjFA,CACX,EAEA,MAAO,CACH,IAAI,MAAMI,EAAa,CACnBT,EAAQS,CACZ,EACA,IAAI,KAAKA,EAAa,CAClBR,EAAOQ,CACX,EACA,OACIN,EACAC,EAAqD,CAErD,IAAMM,EAAmCX,EAAkC,IAAIK,CAAyB,EAExG,OAAIM,IAAqC,OAC9B,QAAQ,QAAQA,CAAgC,EAGpDR,EAAyBC,EAAOC,CAAyB,CACpE,EAER,EC5EG,IAAMO,GAA0EC,GAC3EC,IACJD,EAAY,CAAC,EAAIC,EAEVD,EAAY,CAAC,GCH5B,IAAME,GAAkB,CACpB,OAAQ,KACR,aAAc,EACd,iBAAkB,cAClB,sBAAuB,WACvB,qBAAsB,IAGbC,GAAmE,CAC5EC,EACAC,EACAC,EACAC,EACAC,EACAC,IAEO,cAAgDL,CAAuB,CAK1E,YAAYM,EAAYC,EAAoC,CACxD,IAAMC,EAAgBL,EAAiBG,CAAO,EACxCG,EAAgB,CAAE,GAAGX,GAAiB,GAAGS,CAAO,EAChDG,EAAsBR,EAA0BM,EAAeC,CAAa,EAE5EE,EADYP,EAA4BI,CAAa,EACaP,EAA2B,EAAK,KAExG,MAAMK,EAAS,GAAOI,EAAqBC,CAAqB,EAEhE,KAAK,mBAAqB,GAC1B,KAAK,qBAAuBD,EAExBD,EAAc,SAAW,MACzBJ,EAAqB,KAAMI,EAAc,OAAO,QAAQ,CAEhE,CAEA,IAAI,QAAM,CACN,OAAI,KAAK,mBACE,KAGJ,KAAK,qBAAqB,MACrC,CAEA,IAAI,OAAOG,EAAK,CAIZ,GAHA,KAAK,qBAAqB,OAASA,EAG/BA,IAAU,MAAQ,KAAK,qBAAqB,SAAW,KAAM,CAC7D,IAAMJ,EAAgB,KAAK,qBAAqB,QAEhD,KAAK,qBAAqB,OAASA,EAAc,aAAa,EAAG,EAAGA,EAAc,UAAU,EAC5F,KAAK,mBAAqB,GAE1BH,EAAqB,KAAM,CAAC,CAChC,MACI,KAAK,mBAAqB,GAE1BA,EAAqB,KAAM,KAAK,qBAAqB,SAAW,KAAO,EAAI,KAAK,qBAAqB,OAAO,QAAQ,CAE5H,CAEA,IAAI,WAAS,CACT,OAAO,KAAK,qBAAqB,SACrC,CAEA,IAAI,UAAUO,EAAK,CACf,KAAK,qBAAqB,UAAYA,CAC1C,GCpED,IAAMC,GAA2E,CACpFC,EACAC,EACAC,IAEO,IAAmE,CACtE,IAAMC,EAA+B,IAAI,QAEnCC,EAAsB,MAAOC,EAA0BC,IAAyD,CAClH,IAAIC,EAAsBN,EAA4CI,CAAK,EAK3E,GAAI,CAFwCG,EAAiBD,EAAqBD,CAAyB,EAEjE,CACtC,IAAMG,EAAU,CACZ,OAAQF,EAAoB,OAC5B,aAAcA,EAAoB,aAClC,iBAAkBA,EAAoB,iBACtC,sBAAuBA,EAAoB,sBAC3C,qBAAsB,CAACA,EAAoB,WAG/CA,EAAsBP,EAA0BM,EAA2BG,CAAO,CACtF,CAEA,OAAAN,EAA6B,IAAIG,EAA2BC,CAAmB,EAE3EG,GAAuBH,CAAmB,EAC1C,MAAML,EAAwBG,EAAOC,EAA2BC,EAAoB,OAAO,CAAC,CAAC,EAE7F,MAAML,EAAwBG,EAAOC,EAA2BC,CAAmB,EAGhFA,CACX,EAEA,MAAO,CACH,OAAOF,EAA0BC,EAAqD,CAClF,IAAMK,EAA8BR,EAA6B,IAAIG,CAAyB,EAE9F,OAAIK,IAAgC,OACzB,QAAQ,QAAQA,CAA2B,EAG/CP,EAAoBC,EAAOC,CAAyB,CAC/D,EAER,ECnDG,IAAMM,GAAiF,CAC1FC,EACAC,IAEO,CAACC,EAAkBC,EAAQC,IAAc,CAC5C,GAAIH,IAAyC,KACzC,MAAM,IAAI,MAAM,qDAAqD,EAGzE,GAAI,CACA,OAAO,IAAIA,EAAqCC,EAAkBC,EAAQC,CAAU,CACxF,OAASC,EAAK,CAEV,MAAIA,EAAI,OAAS,cACPL,EAAuB,EAG3BK,CACV,CACJ,ECnBG,IAAMC,GAA+C,IAAM,IAAI,aAAa,GAAI,gBAAgB,ECFhG,IAAMC,GAAqBC,GAA2C,CACzE,GAAM,CAAE,MAAAC,EAAO,MAAAC,CAAK,EAAK,IAAI,eAE7B,OAAO,IAAI,QAASC,GAAW,CAC3B,IAAMC,EAAkB,IAAK,CACzBF,EAAM,UAAY,KAElBD,EAAM,MAAK,EACXC,EAAM,MAAK,EAEXC,EAAO,CACX,EAEAD,EAAM,UAAY,IAAME,EAAe,EAEvC,GAAI,CACAH,EAAM,YAAYD,EAAa,CAACA,CAAW,CAAC,CAChD,MAAQ,CAER,SACII,EAAe,CACnB,CACJ,CAAC,CACL,ECnBO,IAAMC,GAAiD,CAC1DC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,IAEO,CAACC,EAAYC,IAAa,CAC7B,IAAMC,EAAgBP,EAAgBK,CAAU,EAAIA,EAAaN,EAAiBM,CAAU,EAG5F,GAAIP,EAAqB,IAAIQ,CAAS,EAAG,CACrC,IAAME,EAAMZ,EAAoB,EAEhC,OAAO,QAAQ,OAAOY,CAAG,CAC7B,CAGA,GAAI,CACAV,EAAqB,IAAIQ,CAAS,CACtC,MAAQ,CAER,CAGA,OAAIX,EAAgBO,EAAoB,IAAMA,EAAmBK,CAAa,CAAC,EACpEA,EAAc,gBAAgBD,CAAS,EAAE,KAAMG,IAElDC,GAAkBJ,CAAS,EAAE,MAAM,IAAK,CAExC,CAAC,EAIIX,EAAgBM,EAAqD,IAClEA,EAAoDQ,CAAW,CAAC,GAGpEL,EAA6CK,CAAW,EAG5Df,EAAiB,IAAIe,CAAW,EAEzBA,EACV,EAIE,IAAI,QAAQ,CAACE,EAASC,IAAU,CACnC,IAAMC,EAAW,SAAW,CAExB,GAAI,CACA,MAAMH,GAAkBJ,CAAS,CACrC,MAAQ,CAER,CACJ,EAEMQ,EAAQN,GAA6B,CACvCI,EAAOJ,CAAG,EACVK,EAAQ,CACZ,EAGA,GAAI,CAEAN,EAAc,gBACVD,EACCG,GAAe,CAGR,OAAOA,EAAY,iBAAoB,aACvCN,EAAkCM,CAAW,EAC7CM,GAAoCN,CAAW,GAGnDf,EAAiB,IAAIe,CAAW,EAEhCI,EAAQ,EAAG,KAAK,IAAMF,EAAQF,CAAW,CAAC,CAC9C,EACCD,GAA6B,CAGtBM,EADAN,IAAQ,KACHX,EAAmB,EAEnBW,CAFqB,CAIlC,CAAC,CAET,OAASA,EAAK,CACVM,EAAKN,CAAG,CACZ,CACJ,CAAC,CACL,ECpGG,IAAMQ,GAA6D,CACtEC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,IAEO,CAACC,EAAWC,IAAS,CACxB,IAAMC,EAAeT,EAAc,IAAIO,CAAS,EAEhD,GAAIE,IAAiB,OACjB,MAAM,IAAI,MAAM,mCAAmC,EAGvD,IAAMC,EAAgBN,EAAiBG,EAAU,OAAO,EAClDI,EAAYL,EAA4BI,CAAa,EAE3D,GAAID,IAAiBD,GAGjB,GAFAR,EAAc,OAAOO,CAAS,EAE1B,CAACI,GAAaN,EAAkBE,CAAS,EAAG,CAC5C,IAAMK,EAAwBV,EAAmBK,CAAS,EACpD,CAAE,QAAAM,CAAO,EAAKZ,EAAwBM,CAAS,EAErD,QAAWO,KAAUD,EACjB,GAAIE,GAA4BD,CAAM,EAAG,CACrC,IAAME,EAA6Bd,EAAmBY,EAAO,CAAC,CAAC,EAE/Df,EAAwCa,EAAuBI,EAA4BF,EAAO,CAAC,EAAGA,EAAO,CAAC,CAAC,CACnH,KAAO,CACH,IAAMG,EAA8Bd,EAAoBW,EAAO,CAAC,CAAC,EAEjEF,EAAsB,QAAQK,EAA6BH,EAAO,CAAC,CAAC,CACxE,CAER,OAEAd,EAAc,IAAIO,EAAWE,EAAeD,CAAK,CAEzD,EC1CJ,IAAMU,GAAkB,CACpB,aAAc,EACd,iBAAkB,MAClB,sBAAuB,WACvB,UAAW,EACX,aAAc,GAGLC,GAA2D,CACpEC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,IAEO,cAA4CN,CAAuB,CAGtE,YAAYO,EAAYC,EAAgC,CACpD,IAAMC,EAAgBL,EAAiBG,CAAO,EACxCG,EAAgB,CAAE,GAAGZ,GAAiB,GAAGU,CAAO,EAChDG,EAAkBR,EAAsBM,EAAeC,CAAa,EACpEE,EAAYP,EAA4BI,CAAa,EACrDI,EAAkDD,EAAYV,EAAwBQ,EAAc,YAAY,EAAI,KAE1H,MAAMH,EAAS,GAAOI,EAAiBE,CAAiB,EAExD,KAAK,WAAaZ,EAAiB,KAAMW,EAAWD,EAAgB,SAAS,EAE7EL,EAAqB,KAAMI,EAAc,YAAY,CACzD,CAEA,IAAI,WAAS,CACT,OAAO,KAAK,UAChB,GCnCD,IAAMI,GAAmE,CAC5EC,EACAC,EACAC,EACAC,EACAC,IAEsEC,GAAwB,CAC1F,IAAMC,EAA2B,IAAI,QAE/BC,EAAkB,MAAOC,EAAsBC,IAAyD,CAC1G,IAAIC,EAAkBR,EAAwCM,CAAK,EAG7DG,EAAkCC,EAAiBF,EAAiBD,CAAyB,EAEnG,GAAI,CAACE,EAAiC,CAClC,IAAME,EAAU,CACZ,aAAcH,EAAgB,aAC9B,iBAAkBA,EAAgB,iBAClC,sBAAuBA,EAAgB,sBACvC,UAAWA,EAAgB,UAAU,MACrC,aAAAL,GAGJK,EAAkBT,EAAsBQ,EAA2BI,CAAO,CAC9E,CAEA,OAAAP,EAAyB,IAAIG,EAA2BC,CAAe,EAElEC,EAGD,MAAMX,EAAkBS,EAA2BD,EAAM,UAAWE,EAAgB,SAAS,EAF7F,MAAMP,EAAiBM,EAA2BD,EAAM,UAAWE,EAAgB,SAAS,EAKhG,MAAMN,EAAwBI,EAAOC,EAA2BC,CAAe,EAExEA,CACX,EAEA,MAAO,CACH,OAAOF,EAAsBC,EAAqD,CAC9E,IAAMK,EAA0BR,EAAyB,IAAIG,CAAyB,EAEtF,OAAIK,IAA4B,OACrB,QAAQ,QAAQA,CAAuB,EAG3CP,EAAgBC,EAAOC,CAAyB,CAC3D,EAER,ECtDG,IAAMM,GAAgGC,GAClG,CAACC,EAAcC,EAAQC,EAAQC,IAC3BJ,EACHC,EAAaG,CAAK,EACjBC,GAA0BA,EAAsB,CAAC,IAAMH,GAAUG,EAAsB,CAAC,IAAMF,CAAM,ECJ1G,IAAMG,GAAoFC,GACtF,CAACC,EAAeC,IAAoB,CACvCF,EAA+BC,CAAa,EAAE,OAAOC,CAAgB,CACzE,ECFG,IAAMC,GAAmCC,GACrC,cAAeA,ECCnB,IAAMC,GAA2C,CAACC,EAA0BC,EAAyBC,IACjG,SAASC,EAAiCC,EAAwBC,EAAqC,CAC1G,IAAMC,EAAYC,GAAYF,CAAQ,EAAIA,EAA0BH,EAAeF,EAA0BK,CAAQ,EAErH,GAAIG,GAAYF,CAAS,EACrB,MAAO,CAAA,EAGX,GAAIF,EAAM,CAAC,IAAME,EACb,MAAO,CAACF,CAAK,EAGjB,GAAIA,EAAM,SAASE,CAAS,EACxB,MAAO,CAAA,EAGX,GAAM,CAAE,QAAAG,CAAO,EAAKR,EAAwBK,CAAS,EAErD,OAAO,MAAM,KAAKG,CAAO,EACpB,IAAKC,GAAqBP,EAAa,CAAC,GAAGC,EAAOE,CAAS,EAAGI,EAAiB,CAAC,CAAC,CAAC,EAClF,OAAO,CAACC,EAAcC,IAAiBD,EAAa,OAAOC,CAAY,EAAG,CAAA,CAAE,CACrF,ECvBJ,IAAMC,GAA4B,CAC9BC,EACAC,EACAC,IACkB,CAClB,IAAMC,EAAkBF,EAAiBC,CAAM,EAE/C,GAAIC,IAAoB,OACpB,MAAMH,EAAoB,EAG9B,OAAOG,CACX,EAEaC,GAAsEJ,GACxE,CAACC,EAAkBI,EAAsB,OAAWH,EAAS,OAAWI,EAAQ,IAC/ED,IAAwB,OACjBJ,EAAiB,QAASE,GAAoBA,EAAgB,WAAU,CAAE,EAGjF,OAAOE,GAAwB,SACxBN,GAA0BC,EAAsBC,EAAkBI,CAAmB,EAAE,WAAU,EAGxGE,GAAkBF,CAAmB,EACjCH,IAAW,OACJD,EAAiB,QAASE,GAAoBA,EAAgB,WAAWE,CAAmB,CAAC,EAGpGC,IAAU,OACHP,GAA0BC,EAAsBC,EAAkBC,CAAM,EAAE,WAAWG,EAAqB,CAAC,EAG/GN,GAA0BC,EAAsBC,EAAkBC,CAAM,EAAE,WAAWG,EAAqB,EAAGC,CAAK,EAGzHJ,IAAW,OACJD,EAAiB,QAASE,GAAoBA,EAAgB,WAAWE,CAAmB,CAAC,EAGjGN,GAA0BC,EAAsBC,EAAkBC,CAAM,EAAE,WAAWG,EAAqB,CAAC,ECjC1H,IAAMG,GAAkB,CACpB,OAAQ,KACR,aAAc,EACd,iBAAkB,cAClB,sBAAuB,WACvB,KAAM,GACN,MAAO,GACP,QAAS,IACT,UAAW,KAGFC,GAAqF,CAC9FC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,IAEO,cAAyDP,CAAuB,CAanF,YAAYQ,EAAYC,EAA6C,CACjE,IAAMC,EAAgBL,EAAiBG,CAAO,EACxCG,EAAgB,CAAE,GAAGb,GAAiB,GAAGW,CAAO,EAChDG,EAA+BT,EAAmCO,EAAeC,CAAa,EAC9FE,EAAYP,EAA4BI,CAAa,EACrDI,EAA+DD,EAAYX,EAAoC,EAAK,KAE1H,MAAMM,EAAS,GAAOI,EAA8BE,CAA8B,EAElF,KAAK,QAAUb,EAAiB,KAAMY,EAAWD,EAA6B,MAAM,EACpF,KAAK,MAAQX,EAAiB,KAAMY,EAAWD,EAA6B,IAAI,EAChF,KAAK,8BAAgCA,EACrC,KAAK,OAASX,EAAiB,KAAMY,EAAWD,EAA6B,KAAK,EAClF,KAAK,SAAWX,EAAiB,KAAMY,EAAWD,EAA6B,OAAO,EACtF,KAAK,WAAaX,EAAiB,KAAMY,EAAWD,EAA6B,SAAS,EAE1FL,EAAqB,KAAM,IAAK,CACpC,CAEA,IAAI,QAAM,CACN,OAAO,KAAK,OAChB,CAGA,IAAI,cAAY,CACZ,OAAO,KAAK,8BAA8B,YAC9C,CAEA,IAAI,aAAaQ,EAAK,CAClB,IAAMC,EAAuB,KAAK,8BAA8B,aAIhE,GAFA,KAAK,8BAA8B,aAAeD,EAE9CA,EAAQ,EACR,WAAK,8BAA8B,aAAeC,EAE5CZ,EAAuB,CAErC,CAMA,IAAI,kBAAgB,CAChB,OAAO,KAAK,8BAA8B,gBAC9C,CAEA,IAAI,iBAAiBW,EAAK,CACtB,IAAMC,EAAuB,KAAK,8BAA8B,iBAIhE,GAFA,KAAK,8BAA8B,iBAAmBD,EAElDA,IAAU,MACV,WAAK,8BAA8B,iBAAmBC,EAEhDZ,EAAuB,CAErC,CAEA,IAAI,MAAI,CACJ,OAAO,KAAK,KAChB,CAEA,IAAI,OAAK,CACL,OAAO,KAAK,MAChB,CAEA,IAAI,WAAS,CAET,OAAI,OAAiC,KAAK,8BAA8B,UAAY,OAAU,SACzD,KAAK,8BAA8B,UAAY,MAG7E,KAAK,8BAA8B,SAC9C,CAEA,IAAI,SAAO,CACP,OAAO,KAAK,QAChB,CAEA,IAAI,WAAS,CACT,OAAO,KAAK,UAChB,GC3HD,IAAMa,GAA6F,CACtGC,EACAC,EACAC,EACAC,EACAC,IAEO,IAAmE,CACtE,IAAMC,EAAwC,IAAI,QAE5CC,EAA+B,MACjCC,EACAC,IACA,CACA,IAAIC,EAA+BP,EAAqDK,CAAK,EAMvFG,EAA+CC,EAAiBF,EAA8BD,CAAyB,EAE7H,GAAI,CAACE,EAA8C,CAC/C,IAAME,EAAU,CACZ,OAAQH,EAA6B,OAAO,MAC5C,aAAcA,EAA6B,aAC3C,iBAAkBA,EAA6B,iBAC/C,sBAAuBA,EAA6B,sBACpD,KAAMA,EAA6B,KAAK,MACxC,MAAOA,EAA6B,MAAM,MAC1C,QAASA,EAA6B,QAAQ,MAC9C,UAAWA,EAA6B,UAAU,OAGtDA,EAA+BR,EAAmCO,EAA2BI,CAAO,CACxG,CAEA,OAAAP,EAAsC,IAAIG,EAA2BC,CAA4B,EAE5FC,GAOD,MAAMV,EAAkBQ,EAA2BD,EAAM,OAAQE,EAA6B,MAAM,EACpG,MAAMT,EAAkBQ,EAA2BD,EAAM,KAAME,EAA6B,IAAI,EAChG,MAAMT,EAAkBQ,EAA2BD,EAAM,MAAOE,EAA6B,KAAK,EAClG,MAAMT,EAAkBQ,EAA2BD,EAAM,QAASE,EAA6B,OAAO,EACtG,MAAMT,EAAkBQ,EAA2BD,EAAM,UAAWE,EAA6B,SAAS,IAV1G,MAAMN,EAAiBK,EAA2BD,EAAM,OAAQE,EAA6B,MAAM,EACnG,MAAMN,EAAiBK,EAA2BD,EAAM,KAAME,EAA6B,IAAI,EAC/F,MAAMN,EAAiBK,EAA2BD,EAAM,MAAOE,EAA6B,KAAK,EACjG,MAAMN,EAAiBK,EAA2BD,EAAM,QAASE,EAA6B,OAAO,EACrG,MAAMN,EAAiBK,EAA2BD,EAAM,UAAWE,EAA6B,SAAS,GAS7G,MAAML,EAAwBG,EAAOC,EAA2BC,CAA4B,EAErFA,CACX,EAEA,MAAO,CACH,OACIF,EACAC,EAAqD,CAErD,IAAMK,EAAuCR,EAAsC,IAAIG,CAAyB,EAEhH,OAAIK,IAAyC,OAClC,QAAQ,QAAQA,CAAoC,EAGxDP,EAA6BC,EAAOC,CAAyB,CACxE,EAER,EC1EG,IAAMM,GAA6C,IAAM,IAAI,aAAa,GAAI,eAAe,ECA7F,IAAMC,GAAgDC,GACjDC,GACJ,IAAI,QAAQ,CAACC,EAASC,IAAU,CAC5B,GAAIH,IAAW,KAAM,CAEjBG,EAAO,IAAI,WAAa,EAExB,MACJ,CAEA,IAAMC,EAAOJ,EAAO,SAAS,KAE7B,GAAII,IAAS,KAETD,EAAO,IAAI,WAAa,MACrB,CACH,IAAME,EAASL,EAAO,SAAS,cAAc,QAAQ,EAE/CM,EAAO,IAAI,KAAK,CAACL,CAAM,EAAG,CAAE,KAAM,wBAAwB,CAAE,EAC5DM,EAAM,IAAI,gBAAgBD,CAAI,EAE9BE,EAAyBR,EAAO,QAEhCS,EAAuC,IAAK,CAC9CT,EAAO,QAAUQ,EAEjB,IAAI,gBAAgBD,CAAG,CAC3B,EAEAP,EAAO,QAAU,CAACU,EAASC,EAAKC,EAAQC,EAAOC,IAAS,CAEpD,GAAIH,IAAQJ,GAAQI,IAAQX,EAAO,SAAS,MAAQY,IAAW,GAAKC,IAAU,EAC1E,OAAAJ,EAAoC,EACpCN,EAAOW,CAAK,EAEL,GAGX,GAAIN,IAA2B,KAC3B,OAAOA,EAAuBE,EAASC,EAAKC,EAAQC,EAAOC,CAAK,CAExE,EAEAT,EAAO,QAAU,IAAK,CAClBI,EAAoC,EAEpCN,EAAO,IAAI,WAAa,CAC5B,EACAE,EAAO,OAAS,IAAK,CACjBI,EAAoC,EACpCP,EAAO,CACX,EACAG,EAAO,IAAME,EACbF,EAAO,KAAO,SAEdD,EAAK,YAAYC,CAAM,CAC3B,CACJ,CAAC,ECxDF,IAAMU,GAAgEC,GAClE,KAAiB,CAGpB,YAAoBC,EAAsC,CAAtC,KAAA,mBAAAA,EAChB,KAAK,WAAa,IAAI,OAC1B,CAEO,iBACHC,EACAC,EACAC,EAA2C,CAE3C,GAAID,IAAa,KAAM,CACnB,IAAIE,EAAuB,KAAK,WAAW,IAAIF,CAAQ,EAEnDE,IAAyB,SACzBA,EAAuBL,EAAkB,KAAMG,CAAQ,EAEnD,OAAOA,GAAa,YACpB,KAAK,WAAW,IAAIA,EAAUE,CAAoB,GAI1D,KAAK,mBAAmB,iBAAiBH,EAAMG,EAAsBD,CAAO,CAChF,CACJ,CAEO,cAAcE,EAAY,CAC7B,OAAO,KAAK,mBAAmB,cAAcA,CAAK,CACtD,CAEO,oBACHJ,EACAC,EACAC,EAAwC,CAExC,IAAMC,EAAuBF,IAAa,KAAO,OAAY,KAAK,WAAW,IAAIA,CAAQ,EAEzF,KAAK,mBAAmB,oBAAoBD,EAAMG,IAAyB,OAAY,KAAOA,EAAsBD,CAAO,CAC/H,GCzCD,IAAMG,GAAoFC,GACtF,CAACC,EAAaC,EAAYC,IAAM,CACnC,OAAO,iBAAiBH,EAAQ,CAC5B,aAAc,CACV,aAAc,GACd,KAAG,CACC,OAAO,KAAK,MAAMC,EAAcC,CAAU,CAC9C,GAEJ,YAAa,CACT,aAAc,GACd,KAAG,CACC,OAAOD,CACX,GAEP,EAED,GAAI,CACA,OAAOE,EAAE,CACb,SACQH,IAAW,OACX,OAAaA,EAAQ,aACrB,OAAaA,EAAQ,YAE7B,CACJ,ECzBG,IAAMI,GAA0CC,GAC5C,MAAOC,GAAO,CACjB,GAAI,CACA,IAAMC,EAAW,MAAM,MAAMD,CAAG,EAEhC,GAAIC,EAAS,GACT,MAAO,CAAC,MAAMA,EAAS,KAAI,EAAIA,EAAS,GAAG,CAEnD,MAAQ,CAER,CAEA,MAAMF,EAAgB,CAC1B,ECXJ,IAAMG,GAAkB,CACpB,aAAc,EACd,iBAAkB,MAClB,sBAAuB,WACvB,KAAM,GAGGC,GAAyD,CAClEC,EACAC,EACAC,EACAC,EACAC,EACAC,IAEO,cAA2CL,CAAuB,CAGrE,YAAYM,EAAYC,EAA+B,CACnD,IAAMC,EAAgBJ,EAAiBE,CAAO,EACxCG,EAAgB,CAAE,GAAGX,GAAiB,GAAGS,CAAO,EAChDG,EAAiBP,EAAqBK,EAAeC,CAAa,EAClEE,EAAYN,EAA4BG,CAAa,EACrDI,EAAiDD,EAAYT,EAAsB,EAAK,KAE9F,MAAMI,EAAS,GAAOI,EAAgBE,CAAgB,EAGtD,KAAK,MAAQX,EAAiB,KAAMU,EAAWD,EAAe,KAAMG,GAA4BC,EAA0B,CAC9H,CAEA,IAAI,MAAI,CACJ,OAAO,KAAK,KAChB,GCjCD,IAAMC,GAAiE,CAC1EC,EACAC,EACAC,EACAC,EACAC,IAEO,IAAmE,CACtE,IAAMC,EAA0B,IAAI,QAE9BC,EAAiB,MAAOC,EAAqBC,IAAyD,CACxG,IAAIC,EAAiBP,EAAuCK,CAAK,EAG3DG,EAAiCC,EAAiBF,EAAgBD,CAAyB,EAEjG,GAAI,CAACE,EAAgC,CACjC,IAAME,EAAU,CACZ,aAAcH,EAAe,aAC7B,iBAAkBA,EAAe,iBACjC,sBAAuBA,EAAe,sBACtC,KAAMA,EAAe,KAAK,OAG9BA,EAAiBR,EAAqBO,EAA2BI,CAAO,CAC5E,CAEA,OAAAP,EAAwB,IAAIG,EAA2BC,CAAc,EAEhEC,EAGD,MAAMV,EAAkBQ,EAA2BD,EAAM,KAAME,EAAe,IAAI,EAFlF,MAAMN,EAAiBK,EAA2BD,EAAM,KAAME,EAAe,IAAI,EAKrF,MAAML,EAAwBG,EAAOC,EAA2BC,CAAc,EAEvEA,CACX,EAEA,MAAO,CACH,OAAOF,EAAqBC,EAAqD,CAC7E,IAAMK,EAAyBR,EAAwB,IAAIG,CAAyB,EAEpF,OAAIK,IAA2B,OACpB,QAAQ,QAAQA,CAAsB,EAG1CP,EAAeC,EAAOC,CAAyB,CAC1D,EAER,ECrDG,IAAMM,GAAiF,CAC1FC,EACAC,IAE4BC,GACUD,EAAeD,EAAmCE,CAAsB,ECJ3G,IAAMC,GAA4DC,GAEjEC,GACsC,CACtC,IAAMC,EAAuBF,EAAwBC,CAAS,EAE9D,GAAIC,EAAqB,WAAa,KAClC,MAAM,IAAI,MAAM,iEAAiE,EAGrF,OAA6CA,EAAqB,QACtE,ECZG,IAAMC,GAA4DC,GAC7DC,GAAa,CAAA,IAAAC,EAAC,OAAAA,EAAAF,EAAuB,IAAIC,CAAS,KAAC,MAAAC,IAAA,OAAAA,EAAI,CAAC,ECA7D,IAAMC,GAA8DC,GAC/DC,GAAc,CAClB,IAAMC,EAAwBF,EAAsDC,CAAU,EAE9F,GAAIC,EAAsB,WAAa,KACnC,MAAM,IAAI,MAAM,kEAAkE,EAGtF,OAAOA,EAAsB,QACjC,ECVG,IAAMC,GAA4EC,GAC7EC,GACGD,EAA+B,IAAIC,CAAa,ECFxD,IAAMC,EAAqD,IAAM,IAAI,aAAa,GAAI,mBAAmB,ECEzG,IAAMC,GAAoDC,GAEzDC,GACiH,CACjH,IAAMC,EAAgBF,EAAa,IAAIC,CAAO,EAE9C,GAAIC,IAAkB,OAClB,MAAMC,EAAuB,EAGjC,OACID,CAER,ECfG,IAAME,GAA2F,CACpGC,EACAC,IAEQC,GAAiB,CACrB,IAAIC,EAA4BH,EAA+B,IAAIE,CAAa,EAEhF,GAAIC,IAA8B,OAC9B,OAAOA,EAGX,GAAIF,IAAyC,KACzC,MAAM,IAAI,MAAM,qDAAqD,EAIzE,OAAAE,EAA4B,IAAIF,EAAqC,EAAG,EAAG,KAAK,EAEhFD,EAA+B,IAAIE,EAAeC,CAAyB,EAEpEA,CACX,ECrBG,IAAMC,GAAgFC,GACjFC,GAAiB,CACrB,IAAMC,EAA8BF,EAAgC,IAAIC,CAAa,EAErF,GAAIC,IAAgC,OAChC,MAAM,IAAI,MAAM,8CAA8C,EAGlE,OAAOA,CACX,ECTG,IAAMC,GAAuD,IAAM,IAAI,aAAa,GAAI,oBAAoB,ECC5G,IAAMC,GAA+CC,GAAmD,CAC3GA,EAAoB,sBAAyBC,GAClC,CAACC,EAA2BC,EAA2BC,IAA+B,CACzF,GAAIF,EAAY,SAAWC,EAAY,QAAUA,EAAY,SAAWC,EAAc,OAClF,MAAMC,GAAwB,EAGlC,OAAOJ,EAAqB,KAAKD,EAAqBE,EAAaC,EAAaC,CAAa,CACjG,GACDJ,EAAoB,oBAAoB,CAC/C,ECTA,IAAMM,GAAkB,CACpB,aAAc,EACd,iBAAkB,MAClB,sBAAuB,YAGdC,GAAmE,CAC5EC,EACAC,EACAC,EACAC,EACAC,EACAC,IAEO,cAAgDL,CAAuB,CAG1E,YACIM,EACAC,EAAgI,CAEhI,IAAMC,EAAgBL,EAAiBG,CAAO,EACxCG,EAAYL,EAA4BI,CAAa,EACrDE,EAAgB,CAAE,GAAGZ,GAAiB,GAAGS,CAAO,EAChDI,EAAsBV,EACxBO,EACAC,EAAY,KAAoCH,EAAU,YAC1DI,CAAa,EAEXE,EACDH,EAAYP,EAA4BQ,EAAc,SAAUA,EAAc,WAAW,EAAI,KAGlG,MAAMJ,EAAS,GAAOK,EAAqBC,CAAqB,EAIhEC,GAA4CF,CAAmB,EAE/D,KAAK,qBAAuBA,EAG5BN,EAAqB,KAAM,CAAC,CAChC,CAEO,qBAAqBS,EAA2BC,EAA2BC,EAA2B,CACzG,OAAO,KAAK,qBAAqB,qBAAqBF,EAAaC,EAAaC,CAAa,CACjG,GChDD,IAAMC,GAAe,CACxBC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,IACA,CACA,IAAMC,EAAcF,EAAM,OAEtBG,EAAIL,EAER,QAASM,EAAI,EAAGA,EAAIF,EAAaE,GAAK,EAAG,CACrC,IAAIC,EAAIZ,EAAY,CAAC,EAAIO,EAAMI,CAAC,EAEhC,QAASE,EAAI,EAAGA,EAAIX,EAAWW,GAAK,EAAG,CACnC,IAAM,EAAKH,EAAIG,EAAMP,EAAe,EAEpCM,GAAKZ,EAAYa,CAAC,EAAIV,EAAQ,CAAC,EAC/BS,GAAKd,EAASe,CAAC,EAAIT,EAAQ,CAAC,CAChC,CAEA,QAASS,EAAIX,EAAWW,EAAIZ,EAAmBY,GAAK,EAChDD,GAAKZ,EAAYa,CAAC,EAAIV,EAASO,EAAIG,EAAMP,EAAe,CAAE,EAG9D,QAASO,EAAIX,EAAWW,EAAId,EAAgBc,GAAK,EAC7CD,GAAKd,EAASe,CAAC,EAAIT,EAASM,EAAIG,EAAMP,EAAe,CAAE,EAG3DH,EAAQO,CAAC,EAAIH,EAAMI,CAAC,EACpBP,EAAQM,CAAC,EAAIE,EAEbF,EAAKA,EAAI,EAAMJ,EAAe,EAE9BE,EAAOG,CAAC,EAAIC,CAChB,CAEA,OAAOF,CACX,ECpCA,IAAMI,GAAmB,CACrBC,EACAC,EACAC,EACAC,IACA,CACA,IAAMC,EAAoBF,aAAoB,aAAeA,EAAW,IAAI,aAAaA,CAAQ,EAC3FG,EAAuBF,aAAuB,aAAeA,EAAc,IAAI,aAAaA,CAAW,EACvGG,EAAiBF,EAAkB,OACnCG,EAAoBF,EAAqB,OACzCG,EAAY,KAAK,IAAIF,EAAgBC,CAAiB,EAE5D,GAAIH,EAAkB,CAAC,IAAM,EAAG,CAC5B,QAASK,EAAI,EAAGA,EAAIH,EAAgBG,GAAK,EACrCJ,EAAqBI,CAAC,GAAKL,EAAkB,CAAC,EAGlD,QAASK,EAAI,EAAGA,EAAIF,EAAmBE,GAAK,EACxCL,EAAkBK,CAAC,GAAKL,EAAkB,CAAC,CAEnD,CAEA,IAAMM,EAAe,GACfC,EAAU,IAAI,aAAaD,CAAY,EACvCE,EAAU,IAAI,aAAaF,CAAY,EAEvCG,EAAiBZ,EAA0B,aAC7CD,EAAe,iBACfA,EAAe,OACfA,EAAe,UAAU,EAGvBc,EAAmBd,EAAe,iBAExC,QAASS,EAAI,EAAGA,EAAIK,EAAkBL,GAAK,EAAG,CAC1C,IAAMM,EAAQf,EAAe,eAAeS,CAAC,EACvCO,EAASH,EAAe,eAAeJ,CAAC,EAE9CE,EAAQ,KAAK,CAAC,EACdC,EAAQ,KAAK,CAAC,EAEdK,GACIb,EACAE,EACAD,EACAE,EACAC,EACAG,EACAC,EACA,EACAF,EACAK,EACAC,CAAM,CAEd,CAEA,OAAOH,CACX,EAEaK,GAA2E,CACpFC,EACAC,EACAC,EACAC,EACAC,IAEO,CAA+DrB,EAA4BC,IAAiC,CAC/H,IAAMqB,EAA2B,IAAI,QAEjCC,EAAmE,KAEjEC,EAAkB,MAAOC,EAA0B1B,IAAyD,CAC9G,IAAI2B,EAAmE,KACnEC,EAAsBT,EAA4CO,CAAK,EAGrEG,EAAsCC,EAAiBF,EAAqB5B,CAAyB,EAwB3G,GArBIA,EAA0B,kBAAoB,OAC9C2B,EAA8BT,EAAkClB,EAA2B,CACvF,OAAQ,KACR,aAAc,EACd,iBAAkB,MAClB,sBAAuB,WACvB,KAAM,GACN,QAAS,EACT,UAAW,EACX,aAAc,EACjB,EACO6B,IAERD,EAAsB5B,EAA0B,gBAA0BE,EAAuBD,CAAQ,GAG7GsB,EAAyB,IACrBvB,EACA2B,IAAgC,KAAOC,EAAsBD,CAA2B,EAGxFA,IAAgC,KAAM,CACtC,GAAIH,IAA0B,KAAM,CAChC,GAAIJ,IAAyC,KACzC,MAAM,IAAI,MAAM,qDAAqD,EAGzE,IAAMW,EAA6B,IAAIX,EAEnCM,EAAM,QAAQ,YAAY,aAE1BA,EAAM,QAAQ,OACd1B,EAA0B,UAAU,EAGxCwB,GAAyB,SAAW,CAChC,MAAMH,EAAwBK,EAAOK,EAA4BA,EAA2B,WAAW,EAEvG,IAAMhC,EAAiB,MAAMuB,EAAgCS,CAA0B,EAEvF,OAAOjC,GAAiBC,EAAgBC,EAA2BC,EAAUC,CAAW,CAC5F,GAAE,CACN,CAEA,IAAMU,EAAiB,MAAMY,EAE7B,OAAAG,EAA4B,OAASf,EACrCe,EAA4B,MAAM,CAAC,EAE5BA,CACX,CAEA,aAAMN,EAAwBK,EAAO1B,EAA2B4B,CAAmB,EAE5EA,CACX,EAEA,MAAO,CACH,OACIF,EACA1B,EAAqD,CAErD,IAAMgC,EAA0BT,EAAyB,IAAIvB,CAAyB,EAEtF,OAAIgC,IAA4B,OACrB,QAAQ,QAAQA,CAAuB,EAG3CP,EAAgBC,EAAO1B,CAAyB,CAC3D,EAER,EC9JG,IAAMiC,GAA2E,CACpFC,EACAC,EACAC,EACAC,EACAC,EACAC,IAEQC,GACG,CAACC,EAAWC,IAAS,CACxB,IAAMC,EAAeT,EAAc,IAAIO,CAAS,EAEhD,GAAIE,IAAiB,OAAW,CAC5B,GAAI,CAACH,GAAaD,EAAkBE,CAAS,EAAG,CAC5C,IAAMG,EAAwBP,EAAmBI,CAAS,EACpD,CAAE,QAAAI,CAAO,EAAKT,EAAwBK,CAAS,EAErD,QAAWK,KAAUD,EACjB,GAAIE,GAA4BD,CAAM,EAAG,CACrC,IAAME,EAA6BX,EAAmBS,EAAO,CAAC,CAAC,EAE/DX,EACIS,EACAI,EACAF,EAAO,CAAC,EACRA,EAAO,CAAC,CAAC,CAEjB,KAAO,CACH,IAAMG,EAA8BX,EAAoBQ,EAAO,CAAC,CAAC,EAEjEF,EAAsB,WAAWK,EAA6BH,EAAO,CAAC,CAAC,CAC3E,CAER,CAEAZ,EAAc,IAAIO,EAAWC,CAAK,CACtC,MACIR,EAAc,IAAIO,EAAWE,EAAeD,CAAK,CAEzD,ECvCD,IAAMQ,GAAqD,CAACC,EAAcC,IACrEC,GAAoF,CACxF,IAAMC,EAAgBH,EAAa,IAASE,CAAQ,EAEpD,OAAOD,EAAqBE,CAAa,GAAKF,EAAqBC,CAAQ,CAC/E,ECLG,IAAME,GAA+C,CAACC,EAAgBC,IACjEC,GAA6DF,EAAe,IAASE,CAAQ,GAAKD,EAAkBC,CAAQ,ECDjI,IAAMC,GAAiD,CAACC,EAAiBC,IACpEC,GAA0DF,EAAgB,IAASE,CAAQ,GAAKD,EAAmBC,CAAQ,ECDhI,IAAMC,GAAmE,CAACC,EAAcC,IACnFC,GAAyG,CAC7G,IAAMC,EAAgBH,EAAa,IAASE,CAAQ,EAEpD,OAAOD,EAA4BE,CAAa,GAAKF,EAA4BC,CAAQ,CAC7F,ECNG,IAAME,GAA4DC,GAC7DC,GACGD,IAAkC,MAAQC,aAAoBD,ECFtE,IAAME,GAAsDC,GACvDC,GACGD,IAAW,MAAQ,OAAOA,EAAO,WAAc,YAAcC,aAAoBD,EAAO,UCFhG,IAAME,GAAwDC,GACzDC,GACGD,IAAW,MAAQ,OAAOA,EAAO,YAAe,YAAcC,aAAoBD,EAAO,WCFjG,IAAME,GAAiD,CAACC,EAAsBC,IACzEC,GACGF,EAAqBE,CAAQ,GAAKD,EAA4BC,CAAQ,ECF9E,IAAMC,GAA0EC,GAC3EC,GACGD,IAAyC,MAAQC,aAAoBD,ECF7E,IAAME,GAAkDC,GAAWA,IAAW,MAAQA,EAAO,gBCC7F,IAAMC,GAA+F,CACxGC,EACAC,EACAC,EACAC,IAEO,cAA0FH,CAAuB,CAIpH,YAAYI,EAAYC,EAAwC,CAC5D,IAAMC,EAAgBJ,EAAiBE,CAAO,EACxCG,EAAoCN,EAAwCK,EAAeD,CAAO,EAGxG,GAAIF,EAA4BG,CAAa,EACzC,MAAM,UAAS,EAGnB,MAAMF,EAAS,GAAMG,EAA0D,IAAI,EAEnF,KAAK,mCAAqCA,CAC9C,CAEA,IAAI,cAAY,CACZ,OAAO,KAAK,mCAAmC,YACnD,GC1BR,IAAMC,GAAkB,CACpB,aAAc,EACd,iBAAkB,WAClB,sBAAuB,YAGdC,GAAuG,CAChHC,EACAC,EACAC,EACAC,IAEO,cAA8FH,CAAuB,CAIxH,YAAYI,EAAYC,EAAoC,CACxD,IAAMC,EAAgBJ,EAAiBE,CAAO,EAG9C,GAAID,EAA4BG,CAAa,EACzC,MAAM,IAAI,UAGd,IAAMC,EAAgB,CAAE,GAAGT,GAAiB,GAAGO,CAAO,EAChDG,EAAwCP,EAA4CK,EAAeC,CAAa,EAEtH,MAAMH,EAAS,GAAOI,EAA8D,IAAI,EAExF,KAAK,uCAAyCA,CAClD,CAEA,IAAI,QAAM,CACN,OAAO,KAAK,uCAAuC,MACvD,GClCD,IAAMC,GAA6F,CACtGC,EACAC,EACAC,EACAC,IAEO,cAAyFH,CAAuB,CAInH,YAAYI,EAAYC,EAAuC,CAC3D,IAAMC,EAAgBJ,EAAiBE,CAAO,EACxCG,EAAmCN,EAAuCK,EAAeD,CAAO,EAGtG,GAAIF,EAA4BG,CAAa,EACzC,MAAM,IAAI,UAGd,MAAMF,EAAS,GAAMG,EAAyD,IAAI,EAElF,KAAK,kCAAoCA,CAC7C,CAEA,IAAI,aAAW,CACX,OAAO,KAAK,kCAAkC,WAClD,GC1BD,IAAMC,GAAuG,CAChHC,EACAC,EACAC,IAEO,cAA8FF,CAAuB,CAExH,YAAYG,EAAYC,EAA4C,CAChE,IAAMC,EAAgBH,EAAiBC,CAAO,EACxCG,EAAwCL,EAA4CI,EAAeD,CAAO,EAEhH,MAAMD,EAAS,GAAMG,EAA8D,IAAI,CAC3F,GCJD,IAAMC,GAA+E,CACxFC,EACAC,EACAC,EACAC,EACAC,IAEO,cAAkCD,CAAwD,CAW7F,YAAYE,EAAgC,CAAA,EAAE,CAC1C,GAAID,IAAkC,KAClC,MAAM,IAAI,MAAM,8CAA8C,EAGlE,IAAIE,EAEJ,GAAI,CACAA,EAAqB,IAAIF,EAA8BC,CAAO,CAClE,OAASE,EAAK,CAEV,MAAIA,EAAI,OAAS,IAAMA,EAAI,UAAY,6BAC7BN,EAAuB,EAG3BM,CACV,CAGA,GAAID,IAAuB,KACvB,MAAMJ,EAAkB,EAI5B,GAAI,CAACM,GAAmBH,EAAQ,WAAW,EACvC,MAAM,IAAI,UACN,uBAAuBA,EAAQ,WAAW,kEAAkE,EAKpH,GAAIA,EAAQ,aAAe,QAAaC,EAAmB,aAAeD,EAAQ,WAC9E,MAAMJ,EAAuB,EAGjC,MAAMK,EAAoB,CAAC,EAE3B,GAAM,CAAE,YAAAG,CAAW,EAAKJ,EAClB,CAAE,WAAAK,CAAU,EAAKJ,EAuCvB,GApCA,KAAK,aACD,OAAOA,EAAmB,aAAgB,SACpCA,EAAmB,YACnBG,IAAgB,WAChB,IAAMC,EACND,IAAgB,eAAiBA,IAAgB,OACjD,IAAMC,EACND,IAAgB,WAChB,KAAOC,EAKN,KAAK,IAAI,EAAG,KAAK,IAAI,IAAK,KAAK,MAAOD,EAAcC,EAAc,GAAG,CAAC,CAAC,EAAI,IAAOA,EAC7F,KAAK,oBAAsBJ,EAGvBF,EAA8B,OAAS,sBACvC,KAAK,gBAAkBE,EAAmB,WAAU,EACpD,KAAK,sBAAwBA,EAAmB,iBAAgB,EAEhE,KAAK,gBAAgB,KAAK,MAAQ,MAElC,KAAK,sBAAsB,QAAQ,KAAK,eAAe,EAAE,QAAQA,EAAmB,WAAW,EAC/F,KAAK,sBAAsB,MAAK,IAEhC,KAAK,gBAAkB,KACvB,KAAK,sBAAwB,MAGjC,KAAK,OAAS,KAMVA,EAAmB,QAAU,UAAW,CACxC,KAAK,OAAS,YAEd,IAAMK,EAAc,IAAK,CACjB,KAAK,SAAW,cAChB,KAAK,OAAS,MAGlBL,EAAmB,oBAAoB,cAAeK,CAAW,CACrE,EAEAL,EAAmB,iBAAiB,cAAeK,CAAW,CAClE,CACJ,CAEA,IAAI,aAAW,CACX,OAAO,KAAK,YAChB,CAEA,IAAI,OAAK,CACL,OAAO,KAAK,SAAW,KAAO,KAAK,OAAS,KAAK,oBAAoB,KACzE,CAEO,OAAK,CAER,OAAI,KAAK,QAAU,SACR,KAAK,oBAAoB,MAAK,EAAG,KAAK,IAAK,CAC9C,MAAMX,EAAuB,CACjC,CAAC,GAID,KAAK,SAAW,cAChB,KAAK,OAAS,MAGX,KAAK,oBAAoB,MAAK,EAAG,KAAK,IAAK,CAC1C,KAAK,kBAAoB,MAAQ,KAAK,wBAA0B,OAChE,KAAK,sBAAsB,KAAI,EAE/B,KAAK,gBAAgB,WAAU,EAC/B,KAAK,sBAAsB,WAAU,GAGzCY,GAAqB,IAAI,CAC7B,CAAC,EACL,CAEO,QAAM,CACT,OAAI,KAAK,SAAW,YACT,IAAI,QAAQ,CAACC,EAASC,IAAU,CACnC,IAAMC,EAAiB,IAAK,CACxB,KAAK,oBAAoB,oBAAoB,cAAeA,CAAc,EAEtE,KAAK,oBAAoB,QAAU,UACnCF,EAAO,EAEP,KAAK,OAAM,EAAG,KAAKA,EAASC,CAAM,CAE1C,EAEA,KAAK,oBAAoB,iBAAiB,cAAeC,CAAc,CAC3E,CAAC,EAGE,KAAK,oBAAoB,OAAM,EAAG,MAAOR,GAAO,CAGnD,MAAIA,IAAQ,QAAaA,EAAI,OAAS,GAC5BP,EAAuB,EAG3BO,CACV,CAAC,CACL,CAEO,SAAO,CACV,OAAO,KAAK,oBAAoB,QAAO,EAAG,MAAOA,GAAO,CAEpD,MAAIA,IAAQ,OACFP,EAAuB,EAG3BO,CACV,CAAC,CACL,GC3LD,IAAMS,GAAuF,CAChGC,EACAC,EACAC,EACAC,EACAC,EACAC,IAEO,cACKH,CAAwD,CAShE,YAAoBI,EAAgCC,EAAwB,CACxE,MAAMD,CAAc,EADJ,KAAA,eAAAA,EAGhBE,GAAc,IAAiB,KAAOF,CAAc,EAEhDH,EAA4BG,CAAc,GAC1CF,EAAgC,IAAIE,EAAgB,IAAI,GAAK,EAGjE,KAAK,aAAe,IAAIN,EAA6C,KAAOO,CAAgB,EAC5F,KAAK,UAAYN,EAAiC,KAAOK,CAAc,EACvE,KAAK,eAAiB,IAC1B,CAEA,IAAI,aAAW,CACX,OAAO,KAAK,eAAe,WAC/B,CAEA,IAAI,aAAW,CACX,OAAO,KAAK,YAChB,CAEA,IAAI,UAAQ,CACR,OAAO,KAAK,SAChB,CAEA,IAAI,eAAa,CACb,OAAO,KAAK,cAChB,CAEA,IAAI,cAAcG,EAAK,CACnB,IAAMC,EAAkB,OAAOD,GAAU,WAAaJ,EAAkB,KAAMI,CAAK,EAAI,KAEvF,KAAK,eAAe,cAAgBC,EAEpC,IAAMC,EAAsB,KAAK,eAAe,cAEhD,KAAK,eAAiBA,IAAwB,MAAQA,IAAwBD,EAAkBD,EAAQE,CAC5G,CAEA,IAAI,YAAU,CACV,OAAO,KAAK,eAAe,UAC/B,CAEA,IAAI,OAAK,CACL,OAAO,KAAK,eAAe,KAC/B,GClED,IAAMC,GAAsBC,GAA0C,CAEzE,IAAMC,EAAc,IAAI,YAAY,CAAC,WAAY,GAAI,WAAY,UAAW,GAAI,OAAQ,MAAO,OAAQ,QAAS,WAAY,EAAG,CAAC,CAAC,EAEjI,GAAI,CAEA,IAAMC,EAAUF,EAAc,gBAA6BC,EAAY,OAAQ,IAAK,CAEpF,CAAC,EAED,OAAIC,IAAY,OACL,IAGXA,EAAQ,MAAM,IAAK,CAEnB,CAAC,EAEM,GACX,MAAQ,CAER,CAEA,MAAO,EACX,ECrBA,IAAMC,GAAkB,CACpB,iBAAkB,GAGTC,GAA6F,CACtGC,EACAC,EACAC,EACAC,EACAC,IAEO,cAAyCD,CAA+D,CAQ3G,YAAYE,EAAoC,CAC5C,GAAM,CAAE,OAAAC,EAAQ,iBAAAC,EAAkB,WAAAC,CAAU,EAAK,CAAE,GAAGV,GAAiB,GAAGO,CAAO,EAE3EI,EAA4BP,EAAgCK,EAAkBD,EAAQE,CAAU,EAGjGR,EAAgBU,GAAoB,IAAMA,GAAmBD,CAAyB,CAAC,GACxFA,EAA0B,iBACtB,eACC,IAAK,CACF,IAAIE,EAAI,EAEFC,EAAyBC,GAAgB,CACvC,KAAK,SAAW,YACZF,EAAI,GACJF,EAA0B,oBAAoB,cAAeG,CAAqB,EAClFC,EAAM,yBAAwB,EAE9B,KAAK,2BAA2BA,CAAK,GAErCF,GAAK,EAGjB,EAEA,OAAOC,CACX,GAAE,CAAE,EAIZ,MAAMH,EAA2BF,CAAgB,EAEjD,KAAK,QAAUD,EACf,KAAK,2BAA6BG,EAClC,KAAK,OAAS,IAClB,CAEA,IAAI,QAAM,CAEN,OAAI,KAAK,2BAA2B,SAAW,OACpC,KAAK,QAGT,KAAK,2BAA2B,MAC3C,CAEA,IAAI,OAAK,CACL,OAAO,KAAK,SAAW,KAAO,KAAK,2BAA2B,MAAQ,KAAK,MAC/E,CAEO,gBAAc,CAKjB,OAAI,KAAK,SAAW,UACT,QAAQ,OAAOR,EAAuB,CAAE,GAGnD,KAAK,OAAS,UAEPG,EAAe,KAAK,YAAa,KAAK,0BAA0B,EAAE,QAAQ,IAAK,CAClF,KAAK,OAAS,KAEdU,GAAqB,IAAI,CAC7B,CAAC,EACL,CAEQ,2BAA2BD,EAAY,CACvC,KAAK,SAAW,KAChB,KAAK,2BAA2B,cAAcA,CAAK,EAEnD,WAAW,IAAM,KAAK,2BAA2BA,CAAK,CAAC,CAE/D,GChGD,IAAME,GAAuD,CAACC,EAAoBC,IAC9E,CAACC,EAAiBC,EAAeC,IAAoB,CACxD,IAAMC,EAAc,IAAI,IAExB,OAAAH,EAAgB,SAAyCI,GAE9C,CAACC,EAAmDC,EAAS,EAAGC,EAAgB,IAA8B,CACjH,IAAMC,EAAkBL,EAAY,OAAS,EAE7C,GAAIJ,EAAkBM,CAAW,EAE0D,OAAAD,EAAS,KAC5FJ,EACAK,EACAC,EACAC,CAAK,EAGTT,EACIK,EACA,CAACE,EAAaC,EAAQC,CAAK,EAC1BE,GAAeA,EAAW,CAAC,IAAMJ,GAAeI,EAAW,CAAC,IAAMH,GAAUG,EAAW,CAAC,IAAMF,EAC/F,EAAI,EAGJC,GACAP,EAAa,EAGVI,EAGXD,EAAQ,KAAKJ,EAAiBK,EAAaC,CAAM,EAEjDR,EACIK,EACA,CAACE,EAAaC,CAAM,EACnBG,GAAeA,EAAW,CAAC,IAAMJ,GAAeI,EAAW,CAAC,IAAMH,EACnE,EAAI,EAGJE,GACAP,EAAa,CAIrB,GACDD,EAAgB,OAAO,EAE1BA,EAAgB,YAAeU,GACpB,CAACC,EAAqEL,EAAiBC,IAAwB,CAClH,IAAMK,EAAeT,EAAY,KAAO,EAExC,GAAIQ,IAAwB,OACxBD,EAAW,MAAMV,CAAe,EAEhCG,EAAY,MAAK,UACV,OAAOQ,GAAwB,SAAU,CAErBD,EAAY,KAAKV,EAAiBW,CAAmB,EAEhF,QAAWF,KAAcN,EACjBM,EAAW,CAAC,IAAME,GAClBR,EAAY,OAAOM,CAAU,CAGzC,KAAO,CACCV,EAAkBY,CAAmB,EAEsCD,EAAY,KACnFV,EACAW,EACAL,EACAC,CAAK,EAImDG,EAAY,KACpEV,EACAW,EACAL,CAAM,EAId,QAAWG,KAAcN,EAEjBM,EAAW,CAAC,IAAME,IACjBL,IAAW,QAAaG,EAAW,CAAC,IAAMH,KAC1CC,IAAU,QAAaE,EAAW,CAAC,IAAMF,IAE1CJ,EAAY,OAAOM,CAAU,CAGzC,CAEA,IAAMI,EAAiBV,EAAY,OAAS,EAExCS,GAAgBC,GAChBX,EAAgB,CAExB,GACDF,EAAgB,UAAU,EAEtBA,CACX,EC1GG,IAAMc,EAA8B,CACvCC,EACAC,EACAC,IACA,CACA,IAAMC,EAAQF,EAAQC,CAAM,EAExBC,IAAU,QAAaA,IAAUH,EAAgBE,CAAM,IACvDF,EAAgBE,CAAM,EAAIC,EAElC,ECNO,IAAMC,EAA+B,CAACC,EAAmCC,IAAoC,CAChHC,EAA4BF,EAAiBC,EAAS,cAAc,EACpEC,EAA4BF,EAAiBC,EAAS,kBAAkB,EACxEC,EAA4BF,EAAiBC,EAAS,uBAAuB,CACjF,ECNO,IAAME,GAAuDC,GACzD,OAAOA,EAAmB,wBAA2B,WCDzD,IAAMC,GAAgDC,GAAiD,CAC1GA,EAAmB,uBAA0BC,GAAuB,CAChE,IAAMC,EAAqB,IAAI,WAAWD,EAAM,MAAM,EAEtDD,EAAmB,sBAAsBE,CAAkB,EAE3D,IAAMC,EAAS,KAAK,IAAID,EAAmB,OAAQF,EAAmB,OAAO,EAE7E,QAASI,EAAI,EAAGA,EAAID,EAAQC,GAAK,EAC7BH,EAAMG,CAAC,GAAKF,EAAmBE,CAAC,EAAI,KAAO,SAG/C,OAAOH,CACX,CACJ,ECVO,IAAMI,GAAqE,CAACC,EAAiBC,IACzF,CAACC,EAAeC,IAAW,CAC9B,IAAMC,EAAqBF,EAAc,eAAc,EAMvD,GAHAG,EAA6BD,EAAoBD,CAAO,EAGpD,EAAEA,EAAQ,YAAcA,EAAQ,aAChC,MAAMF,EAAoB,EAG9B,OAAAK,EAA4BF,EAAoBD,EAAS,SAAS,EAClEG,EAA4BF,EAAoBD,EAAS,aAAa,EACtEG,EAA4BF,EAAoBD,EAAS,aAAa,EACtEG,EAA4BF,EAAoBD,EAAS,uBAAuB,EAI3EH,EAAgBO,GAAqD,IAClEA,GAAoDH,CAAkB,CAAC,GAG3EI,GAA6CJ,CAAkB,EAG5DA,CACX,EC/BG,IAAMK,GAA4EC,GACjFA,IAAW,KACJ,KAGPA,EAAO,eAAe,aAAa,EAC5BA,EAAO,YAGX,KCXJ,IAAMC,EAAuC,CAChDC,EACAC,EACAC,IACA,CACA,IAAMC,EAAQF,EAAQC,CAAU,EAE5BC,IAAU,QAAaA,IAAUH,EAAgBE,CAAU,EAAE,QAC7DF,EAAgBE,CAAU,EAAE,MAAQC,EAE5C,ECPO,IAAMC,GAAwDC,GAAmE,CACpIA,EAA4B,OAAUC,GAAS,CAC3C,IAAIC,EAAc,GAElB,MAAO,CAACC,EAAO,EAAGC,EAAS,EAAGC,IAAqB,CAC/C,GAAIH,EACA,MAAMI,EAAuB,EAGjCL,EAAM,KAAKD,EAA6BG,EAAMC,EAAQC,CAAQ,EAE9DH,EAAc,EAClB,CACJ,GAAGF,EAA4B,KAAK,CACxC,ECfO,IAAMO,GACTC,GACM,CACNA,EAA+B,OAAUC,GAC9B,CAACC,EAAO,EAAGC,EAAS,EAAGC,IAAqB,CAC/C,GAAK,OAAOA,GAAa,UAAYA,EAAW,GAAMD,EAAS,GAAKD,EAAO,EACvE,MAAM,IAAI,WAAW,mCAAmC,EAIAD,EAAO,KAAKD,EAAgCE,EAAMC,EAAQC,CAAQ,CAClI,GACDJ,EAA+B,KAAK,CAC3C,ECbO,IAAMK,GACTC,GACM,CACNA,EAA+B,MAASC,GAC7B,CAACC,EAAO,IAAK,CAChB,GAAIA,EAAO,EACP,MAAM,IAAI,WAAW,kCAAkC,EAG3DD,EAAK,KAAKD,EAAgCE,CAAI,CAClD,GACDF,EAA+B,IAAI,CAC1C,ECNO,IAAMG,GAAuF,CAChGC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,IAEO,CAACC,EAAeC,IAAW,CAC9B,IAAMC,EAA8BF,EAAc,mBAAkB,EAEpE,OAAAG,EAA6BD,EAA6BD,CAAO,EAEjEG,EAAqCF,EAA6BD,EAAS,cAAc,EAEzFI,EAA4BH,EAA6BD,EAAS,QAAQ,EAI1EI,EAA4BH,EAA6BD,EAAS,MAAM,EACxEI,EAA4BH,EAA6BD,EAAS,SAAS,EAC3EI,EAA4BH,EAA6BD,EAAS,WAAW,EAIxEX,EAAgBC,EAA6D,IAC1EA,EAA4DS,CAAa,CAAC,GAG9EM,GAAqDJ,CAA2B,EAK/EZ,EAAgBE,EAA2D,IACxEA,EAA0DQ,CAAa,CAAC,GAG5EH,EAAoDK,CAA2B,EAK9EZ,EAAgBG,EAA2D,IACxEA,EAA0DO,CAAa,CAAC,GAG5EF,EAAmDI,EAA6BF,CAAa,EAK5FV,EAAgBI,EAAkE,IAC/EA,EAAiEM,CAAa,CAAC,GAGnFO,GAA0DL,CAA2B,EAKpFZ,EAAgBK,EAA+D,IAC5EA,EAA8DK,CAAa,CAAC,GAGhFD,EAAuDG,EAA6BF,CAAa,EAKhGV,EAAgBM,EAAiE,IAC9EA,EAAgEI,CAAa,CAAC,GAGlFQ,GAAyDN,CAA2B,EAIxFb,EAAoBW,EAAeE,CAA2B,EAEvDA,CACX,EC5FG,IAAMO,GAA8EC,GACnFA,IAAW,KACJ,KAGPA,EAAO,eAAe,cAAc,EAC7BA,EAAO,aAGXA,EAAO,eAAe,oBAAoB,EAAUA,EAAQ,mBAAqB,KCTrF,IAAMC,GAAqF,CAC9FC,EACAC,IAEO,CAACC,EAAeC,EAAcC,IAAqC,CACtE,IAAMC,EAA6BH,EAAc,YAGjD,GAAIG,EAA2B,eAAiBF,EAC5C,GAAI,CACAE,EAA2B,aAAeF,CAC9C,MAAQ,CAER,CAIAC,GAAqCC,EAA2B,mBAAqB,aACrFA,EAA2B,iBAAmB,YAI9CA,EAA2B,kBAAoB,GAC/C,OAAO,eAAeA,EAA4B,kBAAmB,CACjE,MAAOF,EACV,EAIL,IAAMG,EAAWN,EAAqBE,EAAe,CACjD,aAAAC,EACA,iBAAkBE,EAA2B,iBAC7C,sBAAuBA,EAA2B,sBAClD,KAAM,EACT,EAED,OAAAJ,EACIK,EACA,eACCC,GAAQ,IAAMA,EAAI,KAAKD,CAAQ,EAC/BE,GAASC,GAAS,CACfD,EAAI,KAAKF,EAAUG,CAAK,EAExB,GAAI,CACAJ,EAA2B,aAAeI,CAC9C,OAASC,EAAK,CAEV,GAAID,EAAQJ,EAA2B,gBACnC,MAAMK,CAEd,CACJ,CAAC,EAGLT,EACIK,EACA,mBACCC,GAAQ,IAAMA,EAAI,KAAKD,CAAQ,EAC/BE,GAASC,GAAS,CACfD,EAAI,KAAKF,EAAUG,CAAK,EACxBJ,EAA2B,iBAAmBI,CAClD,CAAC,EAGLR,EACIK,EACA,wBACCC,GAAQ,IAAMA,EAAI,KAAKD,CAAQ,EAC/BE,GAASC,GAAS,CACfD,EAAI,KAAKF,EAAUG,CAAK,EACxBJ,EAA2B,sBAAwBI,CACvD,CAAC,EAGL,OAAO,eAAeH,EAAU,kBAAmB,CAC/C,IAAK,IAAMD,EAA2B,gBACzC,EAGDC,EAAS,QAAQD,CAA0B,EAEmDC,CAClG,EClFG,IAAMK,GAAsFC,GAC3FA,IAAW,KACJ,KAGJA,EAAO,eAAe,kBAAkB,EAAIA,EAAO,iBAAmB,KCL1E,IAAMC,GAA4CC,GAA2D,CAChH,GAAM,CAAE,MAAAC,CAAK,EAAK,IAAI,eAEtB,GAAI,CAEAA,EAAM,YAAYD,CAAuB,CAC7C,SACIC,EAAM,MAAK,CACf,CACJ,ECRO,IAAMC,GAA6E,CACtFC,EACAC,EACAC,EACAC,EACAC,IAEO,CAACC,EAAeC,EAAaC,EAAmCC,EAAMC,EAAsBC,IAAW,CAC1G,GAAIH,IAAsC,KACtC,GAAI,CACA,IAAMI,EAAyB,IAAIJ,EAC/BF,EACAG,EACgCE,CAAO,EAErCE,EAGF,IAAI,IAEJC,EAAgE,KAoGpE,GAlGA,OAAO,iBAAiBF,EAAwB,CAK5C,aAAc,CACV,IAAK,IAAMD,EAAQ,aACnB,IAAK,IAAK,CACN,MAAMV,EAAuB,CACjC,GAEJ,iBAAkB,CACd,IAAK,IAAM,WACX,IAAK,IAAK,CACN,MAAMA,EAAuB,CACjC,GAGJ,iBAAkB,CACd,IAAK,IAAMa,EACX,IAAMC,GAAS,CACP,OAAOD,GAAqB,YAC5BF,EAAuB,oBAAoB,iBAAkBE,CAAgB,EAGjFA,EAAmB,OAAOC,GAAU,WAAaA,EAAQ,KAErD,OAAOD,GAAqB,YAC5BF,EAAuB,iBAAiB,iBAAkBE,CAAgB,CAElF,GAEP,EAEDF,EAAuB,kBAAqBI,GACjC,IAAIC,IAAkG,CACzG,GAAIA,EAAK,CAAC,IAAM,iBAAkB,CAC9B,IAAMC,EACF,OAAOD,EAAK,CAAC,GAAM,WACbA,EAAK,CAAC,EACN,OAAOA,EAAK,CAAC,GAAM,UAAYA,EAAK,CAAC,IAAM,MAAQ,OAAOA,EAAK,CAAC,EAAE,aAAgB,WAClFA,EAAK,CAAC,EAAE,YACR,KAEV,GAAIC,IAA2B,KAAM,CACjC,IAAMC,EAAuBN,EAAsB,IAAII,EAAK,CAAC,CAAC,EAE1DE,IAAyB,OACzBF,EAAK,CAAC,EAAIE,GAEVF,EAAK,CAAC,EAAKG,GAAgB,CAEnBA,EAAM,OAAS,SACf,OAAO,iBAAiBA,EAAO,CAC3B,KAAM,CAAE,MAAO,gBAAgB,EAClC,EAEDF,EAAuBE,CAAK,GAE5BF,EAAuB,IAAI,WAAWD,EAAK,CAAC,EAAG,CAAE,GAAGG,CAAK,CAAE,CAAC,CAEpE,EAEAP,EAAsB,IAAIK,EAAwBD,EAAK,CAAC,CAAC,EAEjE,CACJ,CAGA,OAAAD,EAAiB,KAAKJ,EAAwB,QAASK,EAAK,CAAC,EAAGA,EAAK,CAAC,CAAC,EAEhED,EAAiB,KAAKJ,EAAwB,GAAGK,CAAI,CAChE,GACDL,EAAuB,gBAAgB,EAE1CA,EAAuB,qBAAwBS,GACpC,IAAIJ,IAAqB,CAC5B,GAAIA,EAAK,CAAC,IAAM,iBAAkB,CAC9B,IAAME,EAAuBN,EAAsB,IAAII,EAAK,CAAC,CAAC,EAE1DE,IAAyB,SACzBN,EAAsB,OAAOI,EAAK,CAAC,CAAC,EAEpCA,EAAK,CAAC,EAAIE,EAElB,CAGA,OAAAE,EAAoB,KAAKT,EAAwB,QAASK,EAAK,CAAC,EAAGA,EAAK,CAAC,CAAC,EAEnEI,EAAoB,KAAKT,EAAwBK,EAAK,CAAC,EAAGA,EAAK,CAAC,EAAGA,EAAK,CAAC,CAAC,CACrF,GACDL,EAAuB,mBAAmB,EAMzCD,EAAQ,kBAAoB,EAAG,CAC/B,IAAMW,EAAiBnB,EAAqBG,EAAe,CACvD,aAAc,EACd,iBAAkB,WAClB,sBAAuB,WACvB,KAAM,EACT,EAED,OAAAM,EAAuB,QAAQU,CAAc,EAAE,QAAQhB,EAAc,WAAW,EAMzED,EAAmBO,EAJJ,IAAMU,EAAe,WAAU,EAC5B,IAAMA,EAAe,QAAQhB,EAAc,WAAW,CAGE,CACrF,CAEA,OAAOM,CACX,OAASW,EAAK,CAEV,MAAIA,EAAI,OAAS,GACPnB,EAAuB,EAG3BmB,CACV,CAIJ,GAAIb,IAAyB,OACzB,MAAMN,EAAuB,EAGjC,OAAAoB,GAAyCb,CAAO,EAEzCT,EAAkCI,EAAeC,EAAaG,EAAsBC,CAAO,CACtG,EC/JG,IAAMc,GAAoB,CAACC,EAA4BC,IACtDD,IAAgB,KACT,IAGJ,KAAK,IAAI,IAAK,KAAK,IAAI,MAAO,KAAK,IAAI,EAAG,KAAK,MAAM,KAAK,KAAKA,EAAcC,CAAU,CAAC,CAAC,CAAC,CAAC,ECH/F,IAAMC,GAAgCC,GAClC,IAAI,QAAQ,CAACC,EAASC,IAAU,CACnC,GAAM,CAAE,MAAAC,EAAO,MAAAC,CAAK,EAAK,IAAI,eAE7BD,EAAM,UAAY,CAAC,CAAE,KAAAE,CAAI,IAAM,CAC3BF,EAAM,MAAK,EACXC,EAAM,MAAK,EAEXH,EAAQI,CAAI,CAChB,EACAF,EAAM,eAAiB,CAAC,CAAE,KAAAE,CAAI,IAAM,CAChCF,EAAM,MAAK,EACXC,EAAM,MAAK,EAEXF,EAAOG,CAAI,CACf,EAGAD,EAAM,YAAYJ,CAAuB,CAC7C,CAAC,EClBE,IAAMM,GAAqC,MAC9CC,EACAC,IACiC,CACjC,IAAMC,EAAgC,MAAMC,GAA6BF,CAAuB,EAEhG,OAAO,IAAID,EAAqBE,CAA6B,CACjE,ECLO,IAAME,GAA8B,CACvCC,EACAC,EACAC,EACAC,IACiC,CACjC,IAAIC,EAAqBC,GAAuB,IAAIL,CAAa,EAE7DI,IAAuB,SACvBA,EAAqB,IAAI,QAEzBC,GAAuB,IAAIL,EAAeI,CAAkB,GAGhE,IAAME,EAA+BC,GAAmCL,EAAsBC,CAAuB,EAErH,OAAAC,EAAmB,IAAIH,EAAwBK,CAA4B,EAEpEA,CACX,ECLO,IAAME,GAAuF,CAChGC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,IAEO,CAACC,EAAeC,EAAaC,EAAsBC,IAAW,CACjE,GAAIA,EAAQ,iBAAmB,GAAKA,EAAQ,kBAAoB,EAC5D,MAAMR,EAAuB,EAGjC,IAAMS,EAAqB,MAAM,QAAQD,EAAQ,kBAAkB,EAC7DA,EAAQ,mBACR,MAAM,KAAKA,EAAQ,kBAAkB,EAG3C,GAAIC,EAAmB,KAAMC,GAAiBA,EAAe,CAAC,EAC1D,MAAMV,EAAuB,EAGjC,GAAIS,EAAmB,SAAWD,EAAQ,gBACtC,MAAMf,EAAoB,EAI9B,GAAIe,EAAQ,mBAAqB,WAC7B,MAAMR,EAAuB,EAGjC,IAAMW,EAAwBH,EAAQ,aAAeA,EAAQ,eACvDI,EAAyBH,EAAmB,OAAO,CAACI,EAAKC,IAAUD,EAAMC,EAAO,CAAC,EACjFC,EACFR,EAAqB,uBAAyB,OAAY,EAAIA,EAAqB,qBAAqB,OAG5G,GAAII,EAAwBI,EAAqB,GAAKH,EAAyB,EAC3E,MAAMZ,EAAuB,EAGjC,IAAMgB,EAAiB,IAAI,eACrBC,EAA+B,CAAA,EAC/BC,EAA0D,CAAA,EAEhE,QAASC,EAAI,EAAGA,EAAIX,EAAQ,eAAgBW,GAAK,EAC7CF,EAAU,KACNnB,EAAqBO,EAAe,CAChC,aAAcG,EAAQ,aACtB,iBAAkBA,EAAQ,iBAC1B,sBAAuBA,EAAQ,sBAC/B,KAAM,EACT,CAAC,EAENU,EAA0B,KACtBtB,EAAgCS,EAAe,CAC3C,aAAcG,EAAQ,aACtB,iBAAkB,WAClB,sBAAuB,WACvB,gBAAiBA,EAAQ,aAC5B,CAAC,EAIV,IAAMY,EAAmD,CAAA,EAEzD,GAAIb,EAAqB,uBAAyB,OAC9C,OAAW,CAAE,aAAAc,EAAc,SAAAC,EAAU,SAAAC,GAAU,KAAAC,CAAI,IAAMjB,EAAqB,qBAAsB,CAChG,IAAMkB,EAAqB5B,EAA+BQ,EAAe,CACrE,aAAc,EACd,iBAAkB,WAClB,sBAAuB,WACvB,OACIG,EAAQ,cAAcgB,CAAI,IAAM,OAC1BhB,EAAQ,cAAcgB,CAAI,EAC1BH,IAAiB,OACjB,EACAA,EACb,EAED,OAAO,iBAAiBI,EAAmB,OAAQ,CAC/C,aAAc,CACV,IAAK,IAAOJ,IAAiB,OAAY,EAAIA,GAEjD,SAAU,CACN,IAAK,IAAOC,IAAa,OAAYI,GAA6BJ,GAEtE,SAAU,CACN,IAAK,IAAOC,KAAa,OAAYI,GAA6BJ,IAEzE,EAEDH,EAAoB,KAAKK,CAAkB,CAC/C,CAGJ,IAAMG,EAAyBjC,EAA8BU,EAAe,CACxE,aAAc,EACd,iBAAkB,WAClB,sBAAuB,WACvB,eAAgB,KAAK,IAAI,EAAGM,EAAwBI,CAAkB,EACzE,EACKc,EAAaC,GAAkBxB,EAAaD,EAAc,UAAU,EACpE0B,EAAsBhC,EACxBM,EACAwB,EACAlB,EAAwBI,EAExB,KAAK,IAAI,EAAGH,CAAsB,CAAC,EAEjCoB,EAA4BpC,EAAgCS,EAAe,CAC7E,aAAc,KAAK,IAAI,EAAGO,CAAsB,EAChD,iBAAkB,WAClB,sBAAuB,WACvB,gBAAiB,KAAK,IAAI,EAAGA,CAAsB,EACtD,EACKqB,EAAuD,CAAA,EAE7D,QAASd,EAAI,EAAGA,EAAIX,EAAQ,gBAAiBW,GAAK,EAC9Cc,EAAyB,KACrBtC,EAA8BU,EAAe,CACzC,aAAc,EACd,iBAAkB,WAClB,sBAAuB,WACvB,eAAgBI,EAAmBU,CAAC,EACvC,CAAC,EAIV,QAASA,EAAI,EAAGA,EAAIX,EAAQ,eAAgBW,GAAK,EAAG,CAChDF,EAAUE,CAAC,EAAE,QAAQD,EAA0BC,CAAC,CAAC,EAEjD,QAASe,EAAI,EAAGA,EAAI1B,EAAQ,aAAc0B,GAAK,EAC3ChB,EAA0BC,CAAC,EAAE,QAAQS,EAAwBM,EAAGf,EAAIX,EAAQ,aAAe0B,CAAC,CAEpG,CAEA,IAAMC,EAAe,IAAIC,GACrB7B,EAAqB,uBAAyB,OACxC,CAAA,EACAA,EAAqB,qBAAqB,IAAI,CAAC,CAAE,KAAAiB,CAAI,EAAIa,IAAS,CAC9D,IAAMZ,GAAqBL,EAAoBiB,CAAK,EAEpD,OAAAZ,GAAmB,QAAQG,EAAwB,EAAGjB,EAAwB0B,CAAK,EACnFZ,GAAmB,MAAM,CAAC,EAEU,CAACD,EAAMC,GAAmB,MAAM,CACxE,CAAC,CAAC,EAGZG,EAAuB,QAAQG,CAAmB,EAElD,IAAIO,EAAwB9B,EAAQ,sBAChC+B,EAAgE,KAG9DC,EAAmBhC,EAAQ,kBAAoB,EAAI,CAACuB,CAAmB,EAAIE,EAC3EQ,EAA8B,CAChC,IAAI,YAAU,CACV,OAAOZ,CACX,EACA,IAAI,cAAY,CACZ,OAAOrB,EAAQ,YACnB,EACA,IAAI,aAAakC,EAAC,CAEd,MAAMhD,EAAuB,CACjC,EACA,IAAI,kBAAgB,CAChB,OAAOc,EAAQ,gBACnB,EACA,IAAI,iBAAiBkC,EAAC,CAElB,MAAMhD,EAAuB,CACjC,EACA,IAAI,uBAAqB,CACrB,OAAO4C,CACX,EACA,IAAI,sBAAsBxB,EAAK,CAC3B,QAAW6B,KAAY1B,EACnB0B,EAAS,sBAAwB7B,EAGrCwB,EAAwBxB,CAC5B,EACA,IAAI,SAAO,CACP,OAAOiB,EAAoB,OAC/B,EACA,IAAI,QAAM,CACN,OAAOd,CACX,EACA,IAAI,gBAAc,CACd,OAAOT,EAAQ,cACnB,EACA,IAAI,iBAAe,CACf,OAAOA,EAAQ,eACnB,EACA,IAAI,kBAAgB,CAChB,OAAO+B,CACX,EACA,IAAI,iBAAiBzB,EAAK,CAClB,OAAOyB,GAAqB,YAC5BE,EAA4B,oBAAoB,iBAAkBF,CAAgB,EAGtFA,EAAmB,OAAOzB,GAAU,WAAaA,EAAQ,KAErD,OAAOyB,GAAqB,YAC5BE,EAA4B,iBAAiB,iBAAkBF,CAAgB,CAEvF,EACA,IAAI,YAAU,CACV,OAAOJ,CACX,EACA,IAAI,MAAI,CACJ,OAAOnB,EAAe,KAC1B,EACA,oBAAoB4B,EAAW,CAC3B,OAAOb,EAAoB,iBAAiBa,EAAK,CAAC,EAAGA,EAAK,CAAC,EAAGA,EAAK,CAAC,CAAC,CACzE,EACA,QAAsCpD,EAAuB,KAAK,KAAMgD,CAAgB,EACxF,WAA4CvC,EAA0B,KAAK,KAAMuC,CAAgB,EACjG,iBAAiBI,EAAW,CACxB,OAAOb,EAAoB,cAAca,EAAK,CAAC,CAAC,CACpD,EACA,uBAAuBA,EAAW,CAC9B,OAAOb,EAAoB,oBAAoBa,EAAK,CAAC,EAAGA,EAAK,CAAC,EAAGA,EAAK,CAAC,CAAC,CAC5E,GAGEC,EAAwG,IAAI,IAElH7B,EAAe,MAAM,kBAAqB8B,GAC/B,IAAIF,IAAkG,CACzG,GAAIA,EAAK,CAAC,IAAM,UAAW,CACvB,IAAMG,GACF,OAAOH,EAAK,CAAC,GAAM,WACbA,EAAK,CAAC,EACN,OAAOA,EAAK,CAAC,GAAM,UAAYA,EAAK,CAAC,IAAM,MAAQ,OAAOA,EAAK,CAAC,EAAE,aAAgB,WAClFA,EAAK,CAAC,EAAE,YACR,KAEV,GAAIG,KAA2B,KAAM,CACjC,IAAMC,EAAuBH,EAAsB,IAAID,EAAK,CAAC,CAAC,EAE1DI,IAAyB,OACzBJ,EAAK,CAAC,EAAwCI,GAE9CJ,EAAK,CAAC,EAAKK,GAAgB,CACvB/C,EAAiCG,EAAc,YAAaA,EAAc,WAAY,IAClF0C,GAAuBE,CAAK,CAAC,CAErC,EAEAJ,EAAsB,IAAIE,GAAwBH,EAAK,CAAC,CAAC,EAEjE,CACJ,CAEA,OAAOE,EAAiB,KAAK9B,EAAe,MAAO4B,EAAK,CAAC,EAAGA,EAAK,CAAC,EAAGA,EAAK,CAAC,CAAC,CAChF,GACD5B,EAAe,MAAM,gBAAgB,EAExCA,EAAe,MAAM,qBAAwBkC,GAClC,IAAIN,IAAqB,CAC5B,GAAIA,EAAK,CAAC,IAAM,UAAW,CACvB,IAAMI,GAAuBH,EAAsB,IAAID,EAAK,CAAC,CAAC,EAE1DI,KAAyB,SACzBH,EAAsB,OAAOD,EAAK,CAAC,CAAC,EAEpCA,EAAK,CAAC,EAAII,GAElB,CAEA,OAAOE,EAAoB,KAAKlC,EAAe,MAAO4B,EAAK,CAAC,EAAGA,EAAK,CAAC,EAAGA,EAAK,CAAC,CAAC,CACnF,GACD5B,EAAe,MAAM,mBAAmB,EAE3C,IAAImC,EAAsC,KAE1C,OAAO,eAAenC,EAAe,MAAO,YAAa,CACrD,IAAK,IAAMmC,EACX,IAAMrC,GAAS,CACP,OAAOqC,GAAc,YACrBnC,EAAe,MAAM,oBAAoB,UAAWmC,CAAS,EAGjEA,EAAY,OAAOrC,GAAU,WAAaA,EAAQ,KAE9C,OAAOqC,GAAc,aACrBnC,EAAe,MAAM,iBAAiB,UAAWmC,CAAS,EAC1DnC,EAAe,MAAM,MAAK,EAElC,EACH,EAEDT,EAAqB,UAAU,KAAOS,EAAe,MAErD,IAAIoC,EAAuD,KAEtBC,GACjChD,EACAoC,EACAlC,EACAC,CAAO,EAGkB,KAAM8C,GAAkBF,EAAwBE,CAAa,EAE1F,IAAMC,GAASC,GAAmBhD,EAAQ,eAAgBA,EAAQ,YAAY,EACxEiD,GAAUD,GAAmBhD,EAAQ,gBAAiBC,CAAkB,EACxEiD,EACFnD,EAAqB,uBAAyB,OACxC,CAAA,EACAA,EAAqB,qBAAqB,OACtC,CAACoD,EAAQ,CAAE,KAAAnC,CAAI,KAAQ,CAAE,GAAGmC,EAAQ,CAACnC,CAAI,EAAG,IAAI,aAAa,GAAG,CAAC,GACjE,CAAA,CAAE,EAGZoC,EAAW,GAETC,GAAyB,IAAK,CAC5BrD,EAAQ,gBAAkB,GAC1BuB,EAAoB,WAAWC,CAAyB,EAG5D,QAASb,EAAI,EAAG2C,EAAkC,EAAG3C,EAAIX,EAAQ,gBAAiBW,GAAK,EAAG,CACtF,IAAM4C,GAA0B9B,EAAyBd,CAAC,EAE1D,QAASe,EAAI,EAAGA,EAAIzB,EAAmBU,CAAC,EAAGe,GAAK,EAC5CF,EAA0B,WAAW+B,GAAyBD,EAAkC5B,EAAGA,CAAC,EAGxG4B,GAAmCrD,EAAmBU,CAAC,CAC3D,CACJ,EAEM6C,EAAqB,IAAI,IAG/BjC,EAAoB,eAAiB,CAAC,CAAE,YAAAkC,EAAa,aAAAC,CAAY,IAA4B,CACzF,GAAId,IAA0B,KAAM,CAChC,IAAMe,GAAehE,EAAgCsC,CAA2B,EAEhF,QAAStB,EAAI,EAAGA,EAAIU,EAAYV,GAAK,IAAK,CACtC,QAASe,EAAI,EAAGA,EAAI1B,EAAQ,eAAgB0B,GAAK,EAC7C,QAASkC,GAAI,EAAGA,GAAI5D,EAAQ,aAAc4D,IAAK,EAC3CC,GAAgBJ,EAAaV,GAAOrB,CAAC,EAAGkC,GAAGA,GAAGjD,CAAC,EAInDZ,EAAqB,uBAAyB,QAC9CA,EAAqB,qBAAqB,QAAQ,CAAC,CAAE,KAAAiB,CAAI,EAAIa,KAAS,CAClEgC,GAAgBJ,EAAaP,EAAYlC,EAAMb,EAAwB0B,GAAOlB,CAAC,CACnF,CAAC,EAGL,QAASe,EAAI,EAAGA,EAAI1B,EAAQ,eAAgB0B,GAAK,EAC7C,QAASkC,GAAI,EAAGA,GAAI3D,EAAmByB,CAAC,EAAGkC,IAAK,EAExCX,GAAQvB,CAAC,EAAEkC,EAAC,EAAE,aAAe,IAC7BX,GAAQvB,CAAC,EAAEkC,EAAC,EAAI,IAAI,aAAa,GAAG,GAKhD,GAAI,CACA,IAAME,EAAyBf,GAAO,IAAI,CAACgB,GAAOlC,KAAS,CAGvD,GAFoB8B,GAAa9B,EAAK,EAEtB,KAAO,EACnB,OAAA2B,EAAmB,IAAI3B,GAAOR,EAAa,GAAG,EAEvC0C,GAGX,IAAMC,GAAQR,EAAmB,IAAI3B,EAAK,EAE1C,OAAImC,KAAU,OACH,CAAA,GAGPD,GAAM,MAAOE,IAAgBA,GAAY,MAAOC,IAAWA,KAAW,CAAC,CAAC,IACpEF,KAAU,EACVR,EAAmB,OAAO3B,EAAK,EAE/B2B,EAAmB,IAAI3B,GAAOmC,GAAQ,CAAC,GAIxCD,GACX,CAAC,EAQDX,EANyB1D,EACrBG,EAAc,YAAcc,EAAId,EAAc,WAC9CA,EAAc,WACd,IAA+B+C,EAAuB,QAAQkB,EAAwBb,GAASC,CAAU,CAAC,EAK9G,QAASxB,GAAI,EAAG4B,GAAkC,EAAG5B,GAAI1B,EAAQ,gBAAiB0B,IAAK,EAAG,CACtF,QAASkC,GAAI,EAAGA,GAAI3D,EAAmByB,EAAC,EAAGkC,IAAK,EAC5CO,GAAcT,EAAcT,GAAQvB,EAAC,EAAGkC,GAAGN,GAAkCM,GAAGjD,CAAC,EAGrF2C,IAAmCrD,EAAmByB,EAAC,CAC3D,CACJ,OAAS0C,EAAO,CACZhB,EAAW,GAEXnB,EAA4B,cACxB,IAAI,WAAW,iBAAkB,CAC7B,MAAOmC,EAAM,MACb,SAAUA,EAAM,SAChB,OAAQA,EAAM,OACd,QAASA,EAAM,QAClB,CAAC,CAEV,CAEA,GAAI,CAAChB,EAAU,CACX,QAAS1B,EAAI,EAAGA,EAAI1B,EAAQ,eAAgB0B,GAAK,EAAG,CAChDjB,EAAUiB,CAAC,EAAE,WAAWhB,EAA0BgB,CAAC,CAAC,EAEpD,QAASkC,GAAI,EAAGA,GAAI5D,EAAQ,aAAc4D,IAAK,EAC3ClD,EAA0BC,CAAC,EAAE,WAAWS,EAAwBwC,GAAGlC,EAAI1B,EAAQ,aAAe4D,EAAC,CAEvG,CAEA,GAAI7D,EAAqB,uBAAyB,OAAW,CACzD,IAAMsE,EAAStE,EAAqB,qBAAqB,OAEzD,QAAS2B,GAAI,EAAGA,GAAI2C,EAAQ3C,IAAK,EAAG,CAChC,IAAMT,GAAqBL,EAAoBc,EAAC,EAEhDT,GAAmB,WAAWG,EAAwB,EAAGjB,EAAwBuB,EAAC,EAClFT,GAAmB,KAAI,CAC3B,CACJ,CAEAG,EAAuB,WAAWG,CAAmB,EAErDA,EAAoB,eAAiB,KAEjC+C,GACAjB,GAAsB,EAEtBkB,GAAmB,EAGvB,KACJ,CACJ,CACJ,CACJ,EAEA,IAAID,GAAc,GAGZE,GAAiBlF,EAAqBO,EAAe,CACvD,aAAc,EACd,iBAAkB,WAClB,sBAAuB,WACvB,KAAM,EACT,EAEK4E,GAAmB,IAAMlD,EAAoB,QAAQiD,EAAc,EAAE,QAAQ3E,EAAc,WAAW,EACtG0E,GAAsB,IAAK,CAC7BhD,EAAoB,WAAWiD,EAAc,EAC7CA,GAAe,WAAU,CAC7B,EACME,GAAgB,IAAK,CACvB,GAAItB,EAAU,CACVmB,GAAmB,EAEfvE,EAAQ,gBAAkB,GAC1BuB,EAAoB,QAAQC,CAAyB,EAGzD,QAASb,EAAI,EAAG2C,EAAkC,EAAG3C,EAAIX,EAAQ,gBAAiBW,GAAK,EAAG,CACtF,IAAM4C,GAA0B9B,EAAyBd,CAAC,EAE1D,QAASe,EAAI,EAAGA,EAAIzB,EAAmBU,CAAC,EAAGe,GAAK,EAC5CF,EAA0B,QAAQ+B,GAAyBD,EAAkC5B,EAAGA,CAAC,EAGrG4B,GAAmCrD,EAAmBU,CAAC,CAC3D,CACJ,CAEA2D,GAAc,EAClB,EACMK,GAAmB,IAAK,CACtBvB,IACAqB,GAAgB,EAChBpB,GAAsB,GAG1BiB,GAAc,EAClB,EAEA,OAAAG,GAAgB,EAET7E,EAAmBqC,EAA6ByC,GAAeC,EAAgB,CAC1F,EC/gBG,IAAMC,GAA+D,CAACC,EAAeC,IAAW,CACnG,IAAMC,EAAyBF,EAAc,mBAAkB,EAE/D,OAAAG,EAA6BD,EAAwBD,CAAO,EAE5DG,EAAqCF,EAAwBD,EAAS,GAAG,EACzEG,EAAqCF,EAAwBD,EAAS,QAAQ,EAC9EG,EAAqCF,EAAwBD,EAAS,WAAW,EACjFG,EAAqCF,EAAwBD,EAAS,MAAM,EAE5EI,EAA4BH,EAAwBD,EAAS,MAAM,EAE5DC,CACX,ECfO,IAAMI,GAA+E,CACxFC,EACAC,IAEO,CAACC,EAAeC,IAAW,CAC9B,IAAMC,EAA0BF,EAAc,oBAAoBC,EAAQ,cAAc,EAOxF,OAAIH,IAAkC,MAAQA,EAA8B,OAAS,sBACjFC,EAAsBC,EAAeE,CAAuB,EAGhEC,EAA6BD,EAAyBD,CAAO,EAEtDC,CACX,ECnBG,IAAME,GAA2BC,GAAyD,CAC7F,IAAMC,EAAeD,EAAoB,gBAGzC,OAAO,eAAeA,EAAqB,eAAgB,CACvD,IAAK,IAAMC,EACX,IAAMC,GAAS,CACX,GAAIA,IAAUD,EACV,MAAME,EAAuB,CAErC,EACH,EAGD,OAAO,eAAeH,EAAqB,mBAAoB,CAC3D,IAAK,IAAM,WACX,IAAME,GAAS,CACX,GAAIA,IAAU,WACV,MAAMC,EAAuB,CAErC,EACH,EAGD,OAAO,eAAeH,EAAqB,wBAAyB,CAChE,IAAK,IAAM,WACX,IAAME,GAAS,CACX,GAAIA,IAAU,WACV,MAAMC,EAAuB,CAErC,EACH,CACL,EC/BO,IAAMC,GAAqE,CAACC,EAAeC,IAAW,CACzG,IAAMC,EAA4BF,EAAc,sBAAsBC,EAAQ,eAAe,EAK7F,OAAAE,EAA6BD,EAA2BD,CAAO,EAG/DG,GAAwBF,CAAyB,EAE1CA,CACX,ECVO,IAAMG,GAAiF,CAC1FC,EACAC,EACAC,EACAC,EACAC,IAEO,CAACC,EAAeC,IAAW,CAE9B,GAAID,EAAc,uBAAyB,OACvC,OAAOH,EAAoCG,EAAeC,CAAO,EAGrE,IAAMC,EAA2BF,EAAc,qBAAoB,EAEnE,OAAAG,EAA6BD,EAA0BD,CAAO,EAE9DG,EAAqCF,EAA0BD,EAAS,QAAQ,EAI3EL,EAAgBE,EAAkE,IAC/EA,EAAiEE,CAAa,CAAC,GAGnFK,GAA0DH,CAAwB,EAKjFN,EAAgBG,EAAiE,IAC9EA,EAAgEC,CAAa,CAAC,GAGlFM,GAAyDJ,CAAwB,EAIrFP,EAAoBK,EAAeE,CAAwB,EAEpDA,CACX,EC7CG,IAAMK,GAAuB,CAChCC,EACAC,KAE+CD,EAAU,QAAUC,EAAY,QAAQ,KAAKA,CAAW,EAElDD,EAAU,WAAaC,EAAY,WAAW,KAAKA,CAAW,EAElBD,GCF9F,IAAME,GAA2F,CACpGC,EACAC,EACAC,EACAC,IAEO,CAACC,EAAe,CAAE,OAAAC,EAAQ,GAAGC,CAAgB,IAAM,CACtD,IAAMC,EAAcH,EAAc,aAAa,EAAG,EAAG,KAAK,EACpDI,EAAwBP,EAAkCG,EAAe,CAC3E,OAAQ,KACR,aAAc,EACd,iBAAkB,MAClB,sBAAuB,WACvB,KAAM,GACN,QAAS,EACT,UAAW,EACX,aAAc,EACjB,EACKK,EAAWP,EAAqBE,EAAe,CAAE,GAAGE,EAAkB,KAAMD,CAAM,CAAE,EAGpFK,EAAcH,EAAY,eAAe,CAAC,EAGhDG,EAAY,CAAC,EAAI,EACjBA,EAAY,CAAC,EAAI,EAEjBF,EAAsB,OAASD,EAC/BC,EAAsB,KAAO,GAE7B,IAAMG,EAAgC,CAClC,IAAI,YAAU,CAEd,EACA,IAAI,cAAY,CACZ,OAAOF,EAAS,YACpB,EACA,IAAI,aAAaG,EAAK,CAClBH,EAAS,aAAeG,CAC5B,EACA,IAAI,kBAAgB,CAChB,OAAOH,EAAS,gBACpB,EACA,IAAI,iBAAiBG,EAAK,CACtBH,EAAS,iBAAmBG,CAChC,EACA,IAAI,uBAAqB,CACrB,OAAOH,EAAS,qBACpB,EACA,IAAI,sBAAsBG,EAAK,CAC3BH,EAAS,sBAAwBG,CACrC,EACA,IAAI,SAAO,CACP,OAAOH,EAAS,OACpB,EACA,IAAI,QAAM,CACN,MAAO,CAAA,CACX,EACA,IAAI,gBAAc,CACd,OAAOD,EAAsB,cACjC,EACA,IAAI,iBAAe,CACf,OAAOC,EAAS,eACpB,EACA,IAAI,QAAM,CACN,OAAOA,EAAS,IACpB,EACA,IAAI,SAAO,CACP,OAAOD,EAAsB,OACjC,EACA,IAAI,QAAQI,EAAK,CACbJ,EAAsB,QAAmDI,CAC7E,EACA,oBAAoBC,EAAW,CAC3B,OAAOL,EAAsB,iBAAiBK,EAAK,CAAC,EAAGA,EAAK,CAAC,EAAGA,EAAK,CAAC,CAAC,CAC3E,EACA,iBAAiBA,EAAW,CACxB,OAAOL,EAAsB,cAAcK,EAAK,CAAC,CAAC,CACtD,EACA,uBAAuBA,EAAW,CAC9B,OAAOL,EAAsB,oBAAoBK,EAAK,CAAC,EAAGA,EAAK,CAAC,EAAGA,EAAK,CAAC,CAAC,CAC9E,EACA,MAAMC,EAAO,EAAC,CACVN,EAAsB,MAAM,KAAKA,EAAuBM,CAAI,CAChE,EACA,KAAKA,EAAO,EAAC,CACTN,EAAsB,KAAK,KAAKA,EAAuBM,CAAI,CAC/D,GAGEC,EAAgB,IAAMP,EAAsB,QAAQC,CAAQ,EAC5DO,EAAmB,IAAMR,EAAsB,WAAWC,CAAQ,EAGxE,OAAAT,EAAoBI,EAAeI,CAAqB,EAEjDL,EAAmBc,GAAqBN,EAA+BF,CAAQ,EAAGM,EAAeC,CAAgB,CAC5H,ECrGG,IAAME,GAAuE,CAACC,EAAyBC,IACnG,CAACC,EAAeC,IAAW,CAC9B,IAAMC,EAAsBF,EAAc,gBAAe,EA8BzD,GA5BAG,EAA6BD,EAAqBD,CAAO,EAGrDA,EAAQ,uBAAyBC,EAAoB,YACrDA,EAAoB,UAAY,CAACD,EAAQ,sBAG7CG,EAA4BF,EAAqBD,EAAS,QAAQ,EAG9DA,EAAQ,aAAe,IAI3BF,EACIG,EACA,eACCG,GAAQ,IAAMA,EAAI,KAAKH,CAAmB,EAC1CI,GAASC,GAAS,CACf,GAAIA,EAAQ,EACR,MAAMT,EAAuB,EAGjC,OAAOQ,EAAI,KAAKJ,EAAqBK,CAAK,CAC9C,CAAC,EAIDN,EAAQ,mBAAqB,OAC7B,MAAMH,EAAuB,EAGjC,OAAAC,EACIG,EACA,mBACCG,GAAQ,IAAMA,EAAI,KAAKH,CAAmB,EAC1CI,GAASC,GAAS,CACf,GAAIA,IAAU,MACV,MAAMT,EAAuB,EAGjC,OAAOQ,EAAI,KAAKJ,EAAqBK,CAAK,CAC9C,CAAC,EAGEL,CACX,EClDG,IAAMM,GAAiD,CAACC,EAAeC,IAAW,CACrF,IAAMC,EAAkBF,EAAc,YAAYC,EAAQ,YAAY,EAEtE,OAAAE,EAA6BD,EAAiBD,CAAO,EAErDG,EAAqCF,EAAiBD,EAAS,WAAW,EAEnEC,CACX,ECRO,IAAMG,GAA0FC,GAC5F,CAACC,EAAeC,IAAW,CAC9B,IAAMC,EAA+BF,EAAc,yBAAwB,EAU3E,GARAG,EAA6BD,EAA8BD,CAAO,EAG9DA,EAAQ,aAAe,GAKvBA,EAAQ,mBAAqB,MAC7B,MAAMF,EAAuB,EAGjC,OAAAK,EAAqCF,EAA8BD,EAAS,QAAQ,EACpFG,EAAqCF,EAA8BD,EAAS,MAAM,EAClFG,EAAqCF,EAA8BD,EAAS,OAAO,EACnFG,EAAqCF,EAA8BD,EAAS,SAAS,EACrFG,EAAqCF,EAA8BD,EAAS,WAAW,EAEhFC,CACX,ECvBG,IAAMG,GAA+C,CAACC,EAAeC,IAAW,CACnF,IAAMC,EAAiBF,EAAc,WAAU,EAE/C,OAAAG,EAA6BD,EAAgBD,CAAO,EAEpDG,EAAqCF,EAAgBD,EAAS,MAAM,EAE7DC,CACX,ECTO,IAAMG,GAAwEC,GAC1E,CAACC,EAAeC,EAAaC,IAAW,CAE3C,GAAIF,EAAc,kBAAoB,OAClC,OAAOD,EAA+BC,EAAeC,EAAaC,CAAO,EAI7E,IAAMC,EAAsBH,EAAc,gBAA0BE,EAAQ,YAAuBA,EAAQ,QAAQ,EAEnH,OAAAE,EAA6BD,EAAqBD,CAAO,EAElDC,CACX,ECXJ,SAASE,GAAOC,EAAqBC,EAAmB,CACpD,IAAMC,EAAcD,EAAE,CAAC,EAAIA,EAAE,CAAC,EAAIA,EAAE,CAAC,EAAIA,EAAE,CAAC,EAE5C,MAAO,EAAED,EAAE,CAAC,EAAIC,EAAE,CAAC,EAAID,EAAE,CAAC,EAAIC,EAAE,CAAC,GAAKC,GAAcF,EAAE,CAAC,EAAIC,EAAE,CAAC,EAAID,EAAE,CAAC,EAAIC,EAAE,CAAC,GAAKC,CAAW,CAChG,CAEA,SAASC,GAASH,EAAqBC,EAAmB,CACtD,MAAO,CAACD,EAAE,CAAC,EAAIC,EAAE,CAAC,EAAID,EAAE,CAAC,EAAIC,EAAE,CAAC,EAAGD,EAAE,CAAC,EAAIC,EAAE,CAAC,EAAID,EAAE,CAAC,EAAIC,EAAE,CAAC,CAAC,CAChE,CAEA,SAASG,GAAmBC,EAA2BC,EAAmB,CACtE,IAAIC,EAA2B,CAAC,EAAG,CAAC,EAEpC,QAASC,EAAIH,EAAY,OAAS,EAAGG,GAAK,EAAGA,GAAK,EAC9CD,EAASJ,GAASI,EAAQD,CAAC,EAE3BC,EAAO,CAAC,GAAKF,EAAYG,CAAC,EAG9B,OAAOD,CACX,CAEO,IAAME,GAAiF,CAC1FC,EACAC,EACAC,EACAC,IAEO,CAACC,EAAeC,EAAa,CAAE,aAAAC,EAAc,iBAAAC,EAAkB,sBAAAC,EAAuB,SAAAC,EAAU,YAAAC,CAAW,IAAM,CACpH,IAAMC,EAAaC,GAAkBP,EAAaD,EAAc,UAAU,EACpES,EAAoBJ,aAAoB,aAAeA,EAAW,IAAI,aAAaA,CAAQ,EAC3FK,EAAuBJ,aAAuB,aAAeA,EAAc,IAAI,aAAaA,CAAW,EACvGK,EAAiBF,EAAkB,OACnCG,EAAoBF,EAAqB,OACzCG,EAAY,KAAK,IAAIF,EAAgBC,CAAiB,EAE5D,GAAID,IAAmB,GAAKA,EAAiB,GACzC,MAAMZ,EAAuB,EAGjC,GAAIU,EAAkB,CAAC,IAAM,EACzB,MAAMZ,EAAuB,EAGjC,GAAIe,IAAsB,GAAKA,EAAoB,GAC/C,MAAMb,EAAuB,EAGjC,GAAIW,EAAqB,CAAC,IAAM,EAC5B,MAAMb,EAAuB,EAGjC,GAAIY,EAAkB,CAAC,IAAM,EAAG,CAC5B,QAASf,EAAI,EAAGA,EAAIkB,EAAmBlB,GAAK,EACxCgB,EAAqBhB,CAAC,GAAKe,EAAkB,CAAC,EAGlD,QAASf,EAAI,EAAGA,EAAIiB,EAAgBjB,GAAK,EACrCe,EAAkBf,CAAC,GAAKe,EAAkB,CAAC,CAEnD,CAEA,IAAMK,EAAsBhB,EAAgCE,EAAeO,EAAYL,EAAcA,CAAY,EAEjHY,EAAoB,aAAeZ,EACnCY,EAAoB,iBAAmBX,EACvCW,EAAoB,sBAAwBV,EAE5C,IAAMW,EAAe,GACfC,EAA0B,CAAA,EAC1BC,EAA2B,CAAA,EAC3BC,EAA2B,CAAA,EAEjC,QAASxB,EAAI,EAAGA,EAAIQ,EAAcR,GAAK,EAAG,CACtCsB,EAAc,KAAK,CAAC,EAEpB,IAAMG,EAAU,IAAI,aAAaJ,CAAY,EACvCK,EAAU,IAAI,aAAaL,CAAY,EAE7CI,EAAQ,KAAK,CAAC,EACdC,EAAQ,KAAK,CAAC,EAEdH,EAAS,KAAKE,CAAO,EACrBD,EAAS,KAAKE,CAAO,CACzB,CAGAN,EAAoB,eAAkBO,GAA+B,CACjE,IAAMC,EAAcD,EAAM,YACpBE,EAAeF,EAAM,aAErBG,EAAmBF,EAAY,iBAErC,QAAS5B,EAAI,EAAGA,EAAI8B,EAAkB9B,GAAK,EAAG,CAC1C,IAAM+B,EAAQH,EAAY,eAAe5B,CAAC,EACpCgC,EAASH,EAAa,eAAe7B,CAAC,EAE5CsB,EAActB,CAAC,EAAIiC,GACflB,EACAE,EACAD,EACAE,EACAC,EACAI,EAASvB,CAAC,EACVwB,EAASxB,CAAC,EACVsB,EAActB,CAAC,EACfqB,EACAU,EACAC,CAAM,CAEd,CACJ,EAEA,IAAME,EAAU5B,EAAc,WAAa,EAkE3C,OAAO6B,GAhE0B,CAC7B,IAAI,YAAU,CACV,OAAOtB,CACX,EACA,IAAI,cAAY,CACZ,OAAOO,EAAoB,YAC/B,EACA,IAAI,aAAagB,EAAK,CAClBhB,EAAoB,aAAegB,CACvC,EACA,IAAI,kBAAgB,CAChB,OAAOhB,EAAoB,gBAC/B,EACA,IAAI,iBAAiBgB,EAAK,CACtBhB,EAAoB,iBAAmBgB,CAC3C,EACA,IAAI,uBAAqB,CACrB,OAAOhB,EAAoB,qBAC/B,EACA,IAAI,sBAAsBgB,EAAK,CAC3BhB,EAAoB,sBAAwBgB,CAChD,EACA,IAAI,SAAO,CACP,OAAOhB,EAAoB,OAC/B,EACA,IAAI,QAAM,CACN,MAAO,CAACA,CAAmB,CAC/B,EACA,IAAI,gBAAc,CACd,OAAOA,EAAoB,cAC/B,EACA,IAAI,iBAAe,CACf,OAAOA,EAAoB,eAC/B,EACA,oBAAoBiB,EAAW,CAE3B,OAAOjB,EAAoB,iBAAiBiB,EAAK,CAAC,EAAGA,EAAK,CAAC,EAAGA,EAAK,CAAC,CAAC,CACzE,EACA,iBAAiBA,EAAW,CACxB,OAAOjB,EAAoB,cAAciB,EAAK,CAAC,CAAC,CACpD,EACA,qBAAqBC,EAA2BC,EAA2BC,EAA2B,CAClG,GAAIF,EAAY,SAAWC,EAAY,QAAUA,EAAY,SAAWC,EAAc,OAClF,MAAMtC,EAAwB,EAGlC,IAAMuC,EAASH,EAAY,OAE3B,QAAStC,EAAI,EAAGA,EAAIyC,EAAQzC,GAAK,EAAG,CAChC,IAAM0C,EAAQ,CAAC,KAAK,IAAMJ,EAAYtC,CAAC,EAAIkC,GACrCpC,EAAsB,CAAC,KAAK,IAAI4C,CAAK,EAAG,KAAK,IAAIA,CAAK,CAAC,EACvDC,EAAY/C,GAAmBoB,EAAsBlB,CAAC,EACtDJ,EAAcE,GAAmBmB,EAAmBjB,CAAC,EACrD8C,EAAWrD,GAAOoD,EAAWjD,CAAW,EAE9C6C,EAAYvC,CAAC,EAAI,KAAK,KAAK4C,EAAS,CAAC,EAAIA,EAAS,CAAC,EAAIA,EAAS,CAAC,EAAIA,EAAS,CAAC,CAAC,EAChFJ,EAAcxC,CAAC,EAAI,KAAK,MAAM4C,EAAS,CAAC,EAAGA,EAAS,CAAC,CAAC,CAC1D,CACJ,EACA,uBAAuBP,EAAW,CAC9B,OAAOjB,EAAoB,oBAAoBiB,EAAK,CAAC,EAAGA,EAAK,CAAC,EAAGA,EAAK,CAAC,CAAC,CAC5E,GAGkDjB,CAAmB,CAC7E,ECvLG,IAAMyB,GAAqF,CAACC,EAAoBC,IAC5GD,EAAmB,yBAAyBC,EAAQ,YAAY,ECApE,IAAMC,GAA6F,CAACC,EAAoBC,IAAW,CACtI,IAAMC,EAAwCF,EAAmB,6BAA4B,EAE7F,OAAAG,EAA6BD,EAAuCD,CAAO,EAGvEC,EAAsC,kBAAoB,GAC1D,OAAO,eAAeA,EAAuC,kBAAmB,CAAE,IAAK,IAAM,CAAC,CAAE,EAG7FA,CACX,ECZO,IAAME,GAAmF,CAACC,EAAoB,CAAE,YAAAC,CAAW,IAAM,CACpI,IAAMC,EAAoBD,EAAY,eAAc,EAKpDC,EAAkB,KAAK,CAACC,EAAGC,IAAOD,EAAE,GAAKC,EAAE,GAAK,GAAKD,EAAE,GAAKC,EAAE,GAAK,EAAI,CAAE,EAEzE,IAAMC,EAA4BH,EAAkB,MAAM,EAAG,CAAC,EAExDI,EAAmCN,EAAmB,wBAAwB,IAAI,YAAYK,CAAyB,CAAC,EAM9H,cAAO,eAAeC,EAAkC,cAAe,CAAE,MAAOL,CAAW,CAAE,EAEtFK,CACX,ECnBO,IAAMC,GAA2G,CACpHC,EACAC,IAEO,CAACC,EAAoB,CAAE,iBAAAC,CAAgB,IAAM,CAEhD,GAAI,OAAOD,EAAmB,8BAAiC,WAC3D,OAAOA,EAAmB,6BAA6BC,CAAgB,EAG3E,IAAMC,EAAc,IAAI,YAAY,CAACD,CAAgB,CAAC,EAChDE,EAAmCH,EAAmB,wBAAwBE,CAAW,EAG/F,GAAID,EAAiB,OAAS,QAC1B,MAAMH,EAAuB,EAIjC,GAAIC,EAA4BC,CAAkB,EAC9C,MAAM,IAAI,UAGd,OAAOG,CACX,ECxBG,IAAMC,GAA4FC,GACjGA,IAAW,KACJ,KAGPA,EAAO,eAAe,qBAAqB,EACpCA,EAAO,oBAGXA,EAAO,eAAe,2BAA2B,EAAUA,EAAQ,0BAA4B,KCJnG,IAAMC,GAAyE,CAClFC,EACAC,EACAC,EACAC,EACAC,EACAC,IAEO,CAACC,EAAeC,IAAW,CAC9B,IAAMC,EAAuBF,EAAc,iBAAgB,EAE3D,OAAAG,EAA6BD,EAAsBD,CAAO,EAE1DG,EAAqCF,EAAsBD,EAAS,QAAQ,EAC5EG,EAAqCF,EAAsBD,EAAS,WAAW,EAE3EA,EAAQ,eAAiB,OACzBC,EAAqB,gBAAgBD,EAAQ,YAAY,EAEzDI,EAA4BH,EAAsBD,EAAS,MAAM,EAKhEN,EAAgBC,EAAkE,IAC/EA,EAAiEI,CAAa,CAAC,GAGnFM,GAA0DJ,CAAoB,EAK7EP,EAAgBE,EAA+D,IAC5EA,EAA8DG,CAAa,CAAC,GAGhFD,EAAuDG,EAAsBF,CAAa,EAKzFL,EAAgBG,EAAiE,IAC9EA,EAAgEE,CAAa,CAAC,GAGlFO,GAAyDL,CAAoB,EAIjFR,EAAoBM,EAAeE,CAAoB,EAEhDA,CACX,ECvDG,IAAMM,GAAkEC,GACpE,CAACC,EAAeC,IAAW,CAC9B,IAAMC,EAAmBF,EAAc,aAAY,EAGnD,OAAIE,EAAiB,eAAiB,OAC3BH,EAA4BC,EAAeC,CAAO,GAG7DE,EAA6BD,EAAkBD,CAAO,EAEtDG,EAAqCF,EAAkBD,EAAS,cAAc,EAC9EG,EAAqCF,EAAkBD,EAAS,cAAc,EAC9EG,EAAqCF,EAAkBD,EAAS,cAAc,EAC9EG,EAAqCF,EAAkBD,EAAS,WAAW,EAC3EG,EAAqCF,EAAkBD,EAAS,WAAW,EAC3EG,EAAqCF,EAAkBD,EAAS,WAAW,EAE3EI,EAA4BH,EAAkBD,EAAS,gBAAgB,EACvEI,EAA4BH,EAAkBD,EAAS,gBAAgB,EACvEI,EAA4BH,EAAkBD,EAAS,eAAe,EACtEI,EAA4BH,EAAkBD,EAAS,eAAe,EACtEI,EAA4BH,EAAkBD,EAAS,aAAa,EACpEI,EAA4BH,EAAkBD,EAAS,cAAc,EACrEI,EAA4BH,EAAkBD,EAAS,aAAa,EACpEI,EAA4BH,EAAkBD,EAAS,eAAe,EAE/DC,EACX,EC7BG,IAAMI,GAA2E,CACpFC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,IAEO,CACHC,EACA,CACI,eAAAC,EACA,eAAAC,EACA,cAAAC,EACA,cAAAC,EACA,YAAAC,EACA,aAAAC,EACA,aAAAC,EACA,aAAAC,EACA,aAAAC,EACA,UAAAC,EACA,UAAAC,EACA,UAAAC,EACA,YAAAC,EACA,cAAAC,EACA,GAAGC,CAAgB,IAEvB,CACA,IAAMC,EAAahB,EAAc,aAAY,EAQ7C,GALIe,EAAiB,aAAe,GAKhCA,EAAiB,mBAAqB,MACtC,MAAMnB,EAAuB,EAGjCqB,EAA6BD,EAAYD,CAAgB,EAEzD,IAAMG,EAAyB,CAC3B,aAAc,EACd,iBAAkB,WAClB,sBAAuB,YAGrBC,EAAoB3B,EAA8BQ,EAAe,CACnE,GAAGkB,EACH,sBAAuB,WACvB,eAAgB,EACnB,EACKE,EAAgB3B,EAAqBO,EAAe,CAAE,GAAGe,EAAkB,KAAM,CAAC,CAAE,EACpFM,EAAuB5B,EAAqBO,EAAe,CAAE,GAAGkB,EAAwB,KAAM,CAAC,CAAE,EACjGI,EAAuB7B,EAAqBO,EAAe,CAAE,GAAGkB,EAAwB,KAAM,CAAC,CAAE,EACjGK,EAAuB9B,EAAqBO,EAAe,CAAE,GAAGkB,EAAwB,KAAM,CAAC,CAAE,EACjGM,EAAoB/B,EAAqBO,EAAe,CAAE,GAAGkB,EAAwB,KAAM,CAAC,CAAE,EAC9FO,EAAoBhC,EAAqBO,EAAe,CAAE,GAAGkB,EAAwB,KAAM,CAAC,CAAE,EAC9FQ,EAAoBjC,EAAqBO,EAAe,CAAE,GAAGkB,EAAwB,KAAM,CAAC,CAAE,EAC9FS,EAAsBjC,EAAgCM,EAAe,IAAK,EAAG,CAAC,EAC9E4B,EAAiBjC,EAA2BK,EAAe,CAC7D,GAAGkB,EACH,MAAO,IAAI,aAAa,CAAC,EAAG,CAAC,CAAC,EAC9B,WAAY,OACf,EAEGW,EAA4C,CAACvB,EAAcC,EAAcC,CAAY,EACrFsB,GAAyC,CAACpB,EAAWC,EAAWC,CAAS,EAEvEmB,GAAS,IAAI,aAAa,CAAC,EAGjCJ,EAAoB,eAAiB,CAAC,CAAE,YAAAK,CAAW,IAAM,CACrD,IAAMC,GAAwC,CAC1CnC,EAAekC,EAAaD,GAAQ,CAAC,EACrCjC,EAAekC,EAAaD,GAAQ,CAAC,EACrCjC,EAAekC,EAAaD,GAAQ,CAAC,GAGrCE,GAAY,KAAK,CAACC,GAAOC,KAAUD,KAAUL,EAAgBM,EAAK,CAAC,IACnEnB,EAAW,eAAe,GAAGiB,EAAW,EAExCJ,EAAkBI,IAGtB,IAAMG,GAAoC,CACtCtC,EAAekC,EAAaD,GAAQ,CAAC,EACrCjC,EAAekC,EAAaD,GAAQ,CAAC,EACrCjC,EAAekC,EAAaD,GAAQ,CAAC,GAGrCK,GAAQ,KAAK,CAACF,GAAOC,KAAUD,KAAUJ,GAAaK,EAAK,CAAC,IAC5DnB,EAAW,YAAY,GAAGoB,EAAO,EAEjCN,GAAeM,GAEvB,EAEA,OAAO,eAAed,EAAqB,KAAM,eAAgB,CAAE,IAAK,IAAM,CAAC,CAAE,EACjF,OAAO,eAAeC,EAAqB,KAAM,eAAgB,CAAE,IAAK,IAAM,CAAC,CAAE,EACjF,OAAO,eAAeC,EAAkB,KAAM,eAAgB,CAAE,IAAK,IAAM,CAAC,CAAE,EAC9E,OAAO,eAAeC,EAAkB,KAAM,eAAgB,CAAE,IAAK,IAAM,CAAC,CAAE,EAC9E,OAAO,eAAeC,EAAkB,KAAM,eAAgB,CAAE,IAAK,IAAM,CAAC,CAAE,EAE9E,IAAMW,EAAwB,CAC1B,IAAI,YAAU,CAEd,EACA,IAAI,cAAY,CACZ,OAAOrB,EAAW,YACtB,EACA,IAAI,aAAakB,EAAK,CAElB,GAAIA,EAAQ,EACR,MAAMtC,EAAuB,EAGjCwB,EAAc,aAAec,EAC7BlB,EAAW,aAAekB,CAC9B,EACA,IAAI,kBAAgB,CAChB,OAAOlB,EAAW,gBACtB,EACA,IAAI,iBAAiBkB,EAAK,CAEtB,GAAIA,IAAU,MACV,MAAMtC,EAAuB,EAGjCwB,EAAc,iBAAmBc,EACjClB,EAAW,iBAAmBkB,CAClC,EACA,IAAI,uBAAqB,CACrB,OAAOlB,EAAW,qBACtB,EACA,IAAI,sBAAsBkB,EAAK,CAC3Bd,EAAc,sBAAwBc,EACtClB,EAAW,sBAAwBkB,CACvC,EACA,IAAI,gBAAc,CACd,OAAOlB,EAAW,cACtB,EACA,IAAI,eAAekB,EAAK,CACpBlB,EAAW,eAAiBkB,CAChC,EACA,IAAI,gBAAc,CACd,OAAOlB,EAAW,cACtB,EACA,IAAI,eAAekB,EAAK,CACpBlB,EAAW,eAAiBkB,CAChC,EACA,IAAI,eAAa,CACb,OAAOlB,EAAW,aACtB,EACA,IAAI,cAAckB,EAAK,CAEnB,GAAIA,EAAQ,GAAKA,EAAQ,EACrB,MAAM3C,EAAuB,EAGjCyB,EAAW,cAAgBkB,CAC/B,EACA,IAAI,SAAO,CACP,OAAOlB,EAAW,OACtB,EACA,IAAI,eAAa,CACb,OAAOA,EAAW,aACtB,EACA,IAAI,cAAckB,EAAK,CACnBlB,EAAW,cAAgBkB,CAC/B,EACA,IAAI,QAAM,CACN,MAAO,CAACd,CAAa,CACzB,EACA,IAAI,aAAW,CACX,OAAOJ,EAAW,WACtB,EACA,IAAI,YAAYkB,EAAK,CAEjB,GAAIA,EAAQ,EACR,MAAM,IAAI,WAGdlB,EAAW,YAAckB,CAC7B,EACA,IAAI,gBAAc,CACd,OAAOlB,EAAW,cACtB,EACA,IAAI,iBAAe,CACf,OAAOA,EAAW,eACtB,EACA,IAAI,cAAY,CACZ,OAAOK,EAAqB,IAChC,EACA,IAAI,cAAY,CACZ,OAAOC,EAAqB,IAChC,EACA,IAAI,cAAY,CACZ,OAAOC,EAAqB,IAChC,EACA,IAAI,cAAY,CACZ,OAAOP,EAAW,YACtB,EACA,IAAI,aAAakB,EAAK,CAClBlB,EAAW,aAAekB,CAC9B,EACA,IAAI,WAAS,CACT,OAAOV,EAAkB,IAC7B,EACA,IAAI,WAAS,CACT,OAAOC,EAAkB,IAC7B,EACA,IAAI,WAAS,CACT,OAAOC,EAAkB,IAC7B,EACA,IAAI,aAAW,CACX,OAAOV,EAAW,WACtB,EACA,IAAI,YAAYkB,EAAK,CAEjB,GAAIA,EAAQ,EACR,MAAM,IAAI,WAGdlB,EAAW,YAAckB,CAC7B,EACA,IAAI,eAAa,CACb,OAAOlB,EAAW,aACtB,EACA,IAAI,cAAckB,EAAK,CAEnB,GAAIA,EAAQ,EACR,MAAM,IAAI,WAGdlB,EAAW,cAAgBkB,CAC/B,EACA,oBAAoBI,EAAW,CAC3B,OAAOlB,EAAc,iBAAiBkB,EAAK,CAAC,EAAGA,EAAK,CAAC,EAAGA,EAAK,CAAC,CAAC,CACnE,EACA,iBAAiBA,EAAW,CACxB,OAAOlB,EAAc,cAAckB,EAAK,CAAC,CAAC,CAC9C,EACA,uBAAuBA,EAAW,CAC9B,OAAOlB,EAAc,oBAAoBkB,EAAK,CAAC,EAAGA,EAAK,CAAC,EAAGA,EAAK,CAAC,CAAC,CACtE,GAGArC,IAAmBoC,EAAsB,iBACzCA,EAAsB,eAAiBpC,GAGvCC,IAAmBmC,EAAsB,iBACzCA,EAAsB,eAAiBnC,GAGvCC,IAAkBkC,EAAsB,gBACxCA,EAAsB,cAAgBlC,GAGtCC,IAAkBiC,EAAsB,gBACxCA,EAAsB,cAAgBjC,GAGtCC,IAAgBgC,EAAsB,cACtCA,EAAsB,YAAchC,GAGpCC,IAAiB+B,EAAsB,aAAa,QACpDA,EAAsB,aAAa,MAAQ/B,GAG3CC,IAAiB8B,EAAsB,aAAa,QACpDA,EAAsB,aAAa,MAAQ9B,GAG3CC,IAAiB6B,EAAsB,aAAa,QACpDA,EAAsB,aAAa,MAAQ7B,GAG3CC,IAAiB4B,EAAsB,eACvCA,EAAsB,aAAe5B,GAGrCC,IAAc2B,EAAsB,UAAU,QAC9CA,EAAsB,UAAU,MAAQ3B,GAGxCC,IAAc0B,EAAsB,UAAU,QAC9CA,EAAsB,UAAU,MAAQ1B,GAGxCC,IAAcyB,EAAsB,UAAU,QAC9CA,EAAsB,UAAU,MAAQzB,GAGxCC,IAAgBwB,EAAsB,cACtCA,EAAsB,YAAcxB,GAGpCC,IAAkBuB,EAAsB,gBACxCA,EAAsB,cAAgBvB,IAGtCe,EAAgB,CAAC,IAAM,GAAKA,EAAgB,CAAC,IAAM,GAAKA,EAAgB,CAAC,IAAM,IAC/Eb,EAAW,eAAe,GAAGa,CAAe,GAG5CC,GAAa,CAAC,IAAM,GAAKA,GAAa,CAAC,IAAM,GAAKA,GAAa,CAAC,IAAM,IACtEd,EAAW,YAAY,GAAGc,EAAY,EAG1C,IAAMS,EAAgB,IAAK,CACvBnB,EAAc,QAAQJ,CAAU,EAGhC1B,EAAwC8B,EAAeQ,EAAgB,EAAG,CAAC,EAE3EA,EAAe,QAAQP,CAAoB,EAAE,QAAQF,EAAmB,EAAG,CAAC,EAC5ES,EAAe,QAAQN,CAAoB,EAAE,QAAQH,EAAmB,EAAG,CAAC,EAC5ES,EAAe,QAAQL,CAAoB,EAAE,QAAQJ,EAAmB,EAAG,CAAC,EAC5ES,EAAe,QAAQJ,CAAiB,EAAE,QAAQL,EAAmB,EAAG,CAAC,EACzES,EAAe,QAAQH,CAAiB,EAAE,QAAQN,EAAmB,EAAG,CAAC,EACzES,EAAe,QAAQF,CAAiB,EAAE,QAAQP,EAAmB,EAAG,CAAC,EAEzEA,EAAkB,QAAQQ,CAAmB,EAAE,QAAQ3B,EAAc,WAAW,CACpF,EACMwC,GAAmB,IAAK,CAC1BpB,EAAc,WAAWJ,CAAU,EAGnCnB,EAA6CuB,EAAeQ,EAAgB,EAAG,CAAC,EAEhFA,EAAe,WAAWP,CAAoB,EAC9CA,EAAqB,WAAWF,CAAiB,EACjDS,EAAe,WAAWN,CAAoB,EAC9CA,EAAqB,WAAWH,CAAiB,EACjDS,EAAe,WAAWL,CAAoB,EAC9CA,EAAqB,WAAWJ,CAAiB,EACjDS,EAAe,WAAWJ,CAAiB,EAC3CA,EAAkB,WAAWL,CAAiB,EAC9CS,EAAe,WAAWH,CAAiB,EAC3CA,EAAkB,WAAWN,CAAiB,EAC9CS,EAAe,WAAWF,CAAiB,EAC3CA,EAAkB,WAAWP,CAAiB,EAE9CA,EAAkB,WAAWQ,CAAmB,EAChDA,EAAoB,WAAW3B,EAAc,WAAW,CAC5D,EAEA,OAAOD,EAAmB0C,GAAqBJ,EAAuBrB,CAAU,EAAGuB,EAAeC,EAAgB,CACtH,ECtWG,IAAME,GAAsEC,GACxE,CAACC,EAAe,CAAE,qBAAAC,EAAsB,KAAAC,EAAM,KAAAC,CAAI,IAAM,CAE3D,IAAMC,EAAgBF,aAAgB,aAAeA,EAAO,IAAI,aAAaA,CAAI,EAC3EG,EAAgBF,aAAgB,aAAeA,EAAO,IAAI,aAAaA,CAAI,EAE3EG,EAAqBN,EAAc,mBAAmBK,EAAeD,EAAe,CAAE,qBAAAH,CAAoB,CAAE,EAGlH,GAAI,MAAM,KAAKC,CAAI,EAAE,OAAS,EAC1B,MAAMH,EAAoB,EAG9B,OAAOO,CACX,ECdG,IAAMC,GAAqE,CAC9EC,EACAC,EACAC,EACAC,IAEOH,EAAc,sBAAsBC,EAAYC,EAAuBC,CAAsB,ECJjG,IAAMC,GAA6E,CACtFC,EACAC,IAEO,CAACC,EAAeC,IAAW,CAC9B,IAAMC,EAAmBD,EAAQ,iBAMjC,GAAIC,IAAqB,cACrB,MAAMH,EAAuB,EAIjC,GAAIC,EAAc,qBAAuB,OACrC,OAAOF,EAAkCE,EAAeC,CAAO,EAGnE,IAAME,EAAyBH,EAAc,mBAAkB,EAE/D,OAAAI,EAA6BD,EAAwBF,CAAO,EAE5DI,EAAqCF,EAAwBF,EAAS,KAAK,EAM3E,OAAO,eAAeE,EAAwB,mBAAoB,CAC9D,IAAK,IAAMD,EACX,IAAMI,GAAS,CACX,GAAIA,IAAUJ,EACV,MAAMH,EAAuB,CAErC,EACH,EAEMI,CACX,ECjCG,IAAMI,GAAuF,CAChGC,EACAC,EACAC,EACAC,EACAC,EACAC,IACA,CAGA,IAAMC,EAAW,IAAI,aAAa,CAAC,EAAG,CAAC,CAAC,EAClCC,EAAU,KAAK,GAAK,EACpBC,EAAyB,CAAE,aAAc,EAAG,iBAAkB,WAAY,sBAAuB,UAAU,EAC3GC,EAAqC,CAAE,GAAGD,EAAwB,WAAY,MAAM,EAEpFE,EAA4B,CAC9BC,EACAC,EACAC,EACAC,IACA,CACA,IAAMC,EAAsB,IAAI,aAAa,KAAU,EACjDC,EAAuB,IAAI,aAAa,KAAU,EAExD,QAASC,EAAI,EAAGA,EAAI,MAAYA,GAAK,EAAG,CACpC,IAAMC,EAAKD,EAAK,MAAmBV,EAEnCQ,EAAoBE,CAAC,EAAI,KAAK,IAAIC,CAAC,EACnCF,EAAqBC,CAAC,EAAI,KAAK,IAAIC,CAAC,CACxC,CAEA,IAAMC,EAAejB,EAAqBS,EAAe,CAAE,GAAGH,EAAwB,KAAM,CAAC,CAAE,EAEzFY,EACFjB,EAA2BQ,EAAe,CAAE,GAAGF,EAAoC,MAAOM,CAAmB,CAAE,EAG7GM,EACFlB,EAA2BQ,EAAe,CAAE,GAAGF,EAAoC,MAAOH,CAAQ,CAAE,EAElGgB,EAAgBpB,EAAqBS,EAAe,CAAE,GAAGH,EAAwB,KAAM,CAAC,CAAE,EAE1Fe,EACFpB,EAA2BQ,EAAe,CAAE,GAAGF,EAAoC,MAAOO,CAAoB,CAAE,EAGpH,MAAO,CACH,cAAY,CACRJ,EAAc,QAAQO,CAAY,EAClCP,EAAc,QAAQS,EAAkB,SAAW,OAAYA,EAAoBA,EAAkB,OAAO,CAAC,CAAC,EAC9GT,EAAc,QAAQU,CAAa,EAEnCD,EAAkB,QAAQR,CAAW,EAErCA,EAAY,QAAQO,EAAmB,SAAW,OAAYA,EAAqBA,EAAmB,OAAO,CAAC,CAAC,EAC/GP,EAAY,QAAQU,EAAoB,SAAW,OAAYA,EAAsBA,EAAoB,OAAO,CAAC,CAAC,EAElHH,EAAmB,QAAQD,EAAa,IAAI,EAC5CI,EAAoB,QAAQD,EAAc,IAAI,EAE9CH,EAAa,QAAQL,EAAmB,EAAG,CAAC,EAC5CQ,EAAc,QAAQR,EAAmB,EAAG,CAAC,CACjD,EACA,iBAAe,CACXF,EAAc,WAAWO,CAAY,EACrCP,EAAc,WAAWS,EAAkB,SAAW,OAAYA,EAAoBA,EAAkB,OAAO,CAAC,CAAC,EACjHT,EAAc,WAAWU,CAAa,EAEtCD,EAAkB,WAAWR,CAAW,EAExCA,EAAY,WAAWO,EAAmB,SAAW,OAAYA,EAAqBA,EAAmB,OAAO,CAAC,CAAC,EAClHP,EAAY,WAAWU,EAAoB,SAAW,OAAYA,EAAsBA,EAAoB,OAAO,CAAC,CAAC,EAErHH,EAAmB,WAAWD,EAAa,IAAI,EAC/CI,EAAoB,WAAWD,EAAc,IAAI,EAEjDH,EAAa,WAAWL,EAAmB,EAAG,CAAC,EAC/CQ,EAAc,WAAWR,EAAmB,EAAG,CAAC,CACpD,EAER,EAEMU,EAA8B,CAChCb,EACAC,EACAC,EACAC,IACA,CACA,IAAMW,EAAwC,IAAI,aAAa,KAAU,EACnEC,EAAyC,IAAI,aAAa,KAAU,EACpEC,EAAyC,IAAI,aAAa,KAAU,EACpEC,EAA0C,IAAI,aAAa,KAAU,EAErEC,EAAc,KAAK,MAAM,MAAa,CAAC,EAE7C,QAASZ,EAAI,EAAGA,EAAI,MAAYA,GAAK,EACjC,GAAIA,EAAIY,EAAa,CACjB,IAAMX,GAAMD,EAAIY,IAAgB,MAAiBA,GAAgBtB,EAEjEkB,EAAsCR,CAAC,EAAI,KAAK,IAAIC,CAAC,EACrDQ,EAAuCT,CAAC,EAAI,KAAK,IAAIC,CAAC,EACtDS,EAAuCV,CAAC,EAAI,EAC5CW,EAAwCX,CAAC,EAAI,CACjD,KAAO,CACH,IAAMC,EAAKD,GAAK,MAAiBY,GAAgBtB,EAEjDkB,EAAsCR,CAAC,EAAI,EAC3CS,EAAuCT,CAAC,EAAI,EAC5CU,EAAuCV,CAAC,EAAI,KAAK,IAAIC,CAAC,EACtDU,EAAwCX,CAAC,EAAI,KAAK,IAAIC,CAAC,CAC3D,CAGJ,IAAMY,EAAsB7B,EAAgCU,EAAe,CACvE,aAAc,EACd,iBAAkB,WAClB,sBAAuB,WACvB,gBAAiB,EACpB,EACKoB,EAAiC7B,EAAqBS,EAAe,CAAE,GAAGH,EAAwB,KAAM,CAAC,CAAE,EAE3GwB,EAAmE7B,EAA2BQ,EAAe,CAC/G,GAAGF,EACH,MAAOgB,EACV,EACKQ,EAAkC/B,EAAqBS,EAAe,CAAE,GAAGH,EAAwB,KAAM,CAAC,CAAE,EAE5G0B,EAAoE/B,EAA2BQ,EAAe,CAChH,GAAGF,EACH,MAAOiB,EACV,EAEKL,EACFlB,EAA2BQ,EAAe,CAAE,GAAGF,EAAoC,MAAOH,CAAQ,CAAE,EAElG6B,EAAkCjC,EAAqBS,EAAe,CAAE,GAAGH,EAAwB,KAAM,CAAC,CAAE,EAE5G4B,EAAoEjC,EAA2BQ,EAAe,CAChH,GAAGF,EACH,MAAOkB,EACV,EACKU,EAAmCnC,EAAqBS,EAAe,CAAE,GAAGH,EAAwB,KAAM,CAAC,CAAE,EAE7G8B,EAAqEnC,EAA2BQ,EAAe,CACjH,GAAGF,EACH,MAAOmB,EACV,EAED,MAAO,CACH,cAAY,CACRhB,EAAc,QAAQkB,CAAmB,EACzClB,EAAc,QAAQS,EAAkB,SAAW,OAAYA,EAAoBA,EAAkB,OAAO,CAAC,CAAC,EAE9GS,EAAoB,QAAQC,EAAgC,CAAC,EAC7DD,EAAoB,QAAQG,EAAiC,CAAC,EAC9DH,EAAoB,QAAQK,EAAiC,CAAC,EAC9DL,EAAoB,QAAQO,EAAkC,CAAC,EAE/DhB,EAAkB,QAAQR,CAAW,EAErCA,EAAY,QACRmB,EAAqC,SAAW,OAC1CA,EACAA,EAAqC,OAAO,CAAC,CAAC,EAExDnB,EAAY,QACRqB,EAAsC,SAAW,OAC3CA,EACAA,EAAsC,OAAO,CAAC,CAAC,EAEzDrB,EAAY,QACRuB,EAAsC,SAAW,OAC3CA,EACAA,EAAsC,OAAO,CAAC,CAAC,EAEzDvB,EAAY,QACRyB,EAAuC,SAAW,OAC5CA,EACAA,EAAuC,OAAO,CAAC,CAAC,EAG1DN,EAAqC,QAAQD,EAA+B,IAAI,EAChFG,EAAsC,QAAQD,EAAgC,IAAI,EAClFG,EAAsC,QAAQD,EAAgC,IAAI,EAClFG,EAAuC,QAAQD,EAAiC,IAAI,EAEpFN,EAA+B,QAAQjB,EAAmB,EAAG,CAAC,EAC9DqB,EAAgC,QAAQrB,EAAmB,EAAG,CAAC,EAE/DmB,EAAgC,QAAQnB,EAAmB,EAAG,CAAC,EAC/DuB,EAAiC,QAAQvB,EAAmB,EAAG,CAAC,CACpE,EACA,iBAAe,CACXF,EAAc,WAAWkB,CAAmB,EAC5ClB,EAAc,WAAWS,EAAkB,SAAW,OAAYA,EAAoBA,EAAkB,OAAO,CAAC,CAAC,EAEjHS,EAAoB,WAAWC,EAAgC,CAAC,EAChED,EAAoB,WAAWG,EAAiC,CAAC,EACjEH,EAAoB,WAAWK,EAAiC,CAAC,EACjEL,EAAoB,WAAWO,EAAkC,CAAC,EAElEhB,EAAkB,WAAWR,CAAW,EAExCA,EAAY,WACRmB,EAAqC,SAAW,OAC1CA,EACAA,EAAqC,OAAO,CAAC,CAAC,EAExDnB,EAAY,WACRqB,EAAsC,SAAW,OAC3CA,EACAA,EAAsC,OAAO,CAAC,CAAC,EAEzDrB,EAAY,WACRuB,EAAsC,SAAW,OAC3CA,EACAA,EAAsC,OAAO,CAAC,CAAC,EAEzDvB,EAAY,WACRyB,EAAuC,SAAW,OAC5CA,EACAA,EAAuC,OAAO,CAAC,CAAC,EAG1DN,EAAqC,WAAWD,EAA+B,IAAI,EACnFG,EAAsC,WAAWD,EAAgC,IAAI,EACrFG,EAAsC,WAAWD,EAAgC,IAAI,EACrFG,EAAuC,WAAWD,EAAiC,IAAI,EAEvFN,EAA+B,WAAWjB,EAAmB,EAAG,CAAC,EACjEqB,EAAgC,WAAWrB,EAAmB,EAAG,CAAC,EAElEmB,EAAgC,WAAWnB,EAAmB,EAAG,CAAC,EAClEuB,EAAiC,WAAWvB,EAAmB,EAAG,CAAC,CACvE,EAER,EAEMyB,EAAqB,CACvB5B,EACA6B,EACA5B,EACAC,EACAC,IACA,CACA,GAAI0B,IAAiB,EACjB,OAAO9B,EAA0BC,EAAeC,EAAeC,EAAaC,CAAiB,EAGjG,GAAI0B,IAAiB,EACjB,OAAOhB,EAA4Bb,EAAeC,EAAeC,EAAaC,CAAiB,EAGnG,MAAMV,EAAuB,CACjC,EAEA,MAAO,CAACO,EAAe,CAAE,aAAA6B,EAAc,iBAAAC,EAAkB,IAAAC,EAAK,GAAGC,CAAgB,IAAM,CACnF,GAAIF,IAAqB,MACrB,MAAMrC,EAAuB,EAGjC,IAAMU,EAAoBd,EAA8BW,EAAe,CACnE,GAAGgC,EACH,aAAc,EACd,iBAAAF,EACA,eAAgB,EACnB,EACK7B,EAAgBV,EAAqBS,EAAe,CAAE,GAAGgC,EAAkB,aAAAH,EAAc,iBAAAC,EAAkB,KAAM,CAAC,CAAE,EACpH5B,EAAcX,EAAqBS,EAAe,CACpD,aAAc,EACd,iBAAkB,WAClB,sBAAuB,WACvB,KAAM+B,EACT,EAEG,CAAE,aAAAE,EAAc,gBAAAC,CAAe,EAAKN,EACpC5B,EACA6B,EACA5B,EACAC,EACAC,CAAiB,EAGrB,OAAO,eAAeD,EAAY,KAAM,eAAgB,CAAE,IAAK,IAAM,CAAC,CAAE,EACxE,OAAO,eAAeA,EAAY,KAAM,WAAY,CAAE,IAAK,IAAM,CAAC,CAAE,EACpE,OAAO,eAAeA,EAAY,KAAM,WAAY,CAAE,IAAK,IAAM,EAAE,CAAE,EAErE,IAAMiC,EAAqC,CACvC,IAAI,YAAU,CAEd,EACA,IAAI,cAAY,CACZ,OAAOlC,EAAc,YACzB,EACA,IAAI,aAAamC,EAAK,CACdnC,EAAc,eAAiBmC,IAC3BC,GACAH,EAAe,EAGlB,CAAE,aAAAD,EAAc,gBAAAC,CAAe,EAAKN,EACjC5B,EACAoC,EACAnC,EACAC,EACAC,CAAiB,EAGjBkC,GACAJ,EAAY,GAIpBhC,EAAc,aAAemC,CACjC,EACA,IAAI,kBAAgB,CAChB,OAAOnC,EAAc,gBACzB,EACA,IAAI,iBAAiBmC,EAAK,CACtB,GAAIA,IAAU,eAAiBA,IAAU,MACrC,MAAM3C,EAAuB,EAGjCQ,EAAc,iBAAmBmC,CACrC,EACA,IAAI,uBAAqB,CACrB,OAAOnC,EAAc,qBACzB,EACA,IAAI,sBAAsBmC,EAAK,CAC3BnC,EAAc,sBAAwBmC,CAC1C,EACA,IAAI,SAAO,CACP,OAAOnC,EAAc,OACzB,EACA,IAAI,QAAM,CACN,MAAO,CAACA,CAAa,CACzB,EACA,IAAI,gBAAc,CACd,OAAOA,EAAc,cACzB,EACA,IAAI,iBAAe,CACf,OAAOA,EAAc,eACzB,EACA,IAAI,KAAG,CACH,OAAOC,EAAY,IACvB,EACA,oBAAoBoC,EAAW,CAC3B,OAAOrC,EAAc,iBAAiBqC,EAAK,CAAC,EAAGA,EAAK,CAAC,EAAGA,EAAK,CAAC,CAAC,CACnE,EACA,iBAAiBA,EAAW,CACxB,OAAOrC,EAAc,cAAcqC,EAAK,CAAC,CAAC,CAC9C,EACA,uBAAuBA,EAAW,CAC9B,OAAOrC,EAAc,oBAAoBqC,EAAK,CAAC,EAAGA,EAAK,CAAC,EAAGA,EAAK,CAAC,CAAC,CACtE,GAGAD,EAAc,GAEZE,EAAgB,IAAK,CACvBN,EAAY,EAEZI,EAAc,EAClB,EACMG,EAAmB,IAAK,CAC1BN,EAAe,EAEfG,EAAc,EAClB,EAEA,OAAO3C,EACH+C,GAAqBN,EAAoChC,CAAiB,EAC1EoC,EACAC,CAAgB,CAExB,CACJ,EC/XO,IAAME,GAAyE,CAClFC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,IAEO,CAACC,EAAeC,IAAW,CAC9B,IAAMC,EAAuBF,EAAc,iBAAgB,EAQ3D,GACIF,IAAkC,MAClCA,EAA8B,OAAS,sBACvCE,EAAc,WAAU,EAAG,KAAK,iBAAmB,OAEnD,OAAOL,EAAgCK,EAAeC,CAAO,EAGjEE,EAA6BD,EAAsBD,CAAO,EAE1D,IAAMG,EAAQH,EAAQ,QAAU,MAAQA,EAAQ,iBAAiB,aAAeA,EAAQ,MAAQ,IAAI,aAAaA,EAAQ,KAAK,EAG9H,GAAIG,IAAU,MAAQA,EAAM,OAAS,EACjC,MAAMV,EAAuB,EAIjCW,EAA4BH,EAAsB,CAAE,MAAAE,CAAK,EAAI,OAAO,EACpEC,EAA4BH,EAAsBD,EAAS,YAAY,EAEvE,IAAIK,EAA6D,KAC7DC,EAAc,GAElB,OAAAR,EACIG,EACA,QACCM,GAAQ,IAAMA,EAAI,KAAKN,CAAoB,EAC3CO,GAASC,IACND,EAAI,KAAKP,EAAsBQ,CAAK,EAEhCH,IACIX,EAAUc,CAAK,GAAKJ,IAA0C,KAC9DA,EAAwCb,EACpCO,EACAE,CAAoB,EAEjB,CAACN,EAAUc,CAAK,GAAKJ,IAA0C,OACtEA,EAAqC,EACrCA,EAAwC,OAIzCI,EACV,EAmBEb,EAAmBK,EAhBJ,IAAK,CACvBK,EAAc,GAEVX,EAAUM,EAAqB,KAAK,IACpCI,EAAwCb,EAA2CO,EAAeE,CAAoB,EAE9H,EACyB,IAAK,CAC1BK,EAAc,GAEVD,IAA0C,OAC1CA,EAAqC,EACrCA,EAAwC,KAEhD,CAE+E,CACnF,EClFG,IAAMK,GAAmF,CAC5FC,EACAC,EACAC,EACAC,EACAC,IAEO,CAACC,EAAe,CAAE,MAAAC,EAAO,WAAAC,EAAY,GAAGC,CAAgB,IAAM,CACjE,IAAMC,EAAyBJ,EAAc,iBAAgB,EACvDK,EAAyBL,EAAc,iBAAgB,EAE7DM,EAA6BF,EAAwBD,CAAgB,EACrEG,EAA6BD,EAAwBF,CAAgB,EAErE,IAAMI,EAAgBV,EAAqBG,EAAe,CAAE,GAAGG,EAAkB,KAAM,CAAC,CAAE,EACpFK,EAAiBX,EAAqBG,EAAe,CAAE,GAAGG,EAAkB,KAAM,EAAE,CAAE,EACtFM,EAAiBZ,EAAqBG,EAAe,CAAE,GAAGG,EAAkB,KAAM,CAAC,CAAE,EACrFO,EAAiBb,EAAqBG,EAAe,CAAE,GAAGG,EAAkB,KAAM,EAAE,CAAE,EAExFQ,EAA6D,KAC7DC,EAAc,GACdC,EAAyD,KAEvDC,EAA4B,CAC9B,IAAI,YAAU,CAEd,EACA,IAAI,cAAY,CACZ,OAAOV,EAAuB,YAClC,EACA,IAAI,aAAaW,EAAK,CAClBR,EAAc,aAAeQ,EAC7BP,EAAe,aAAeO,EAC9BX,EAAuB,aAAeW,EACtCN,EAAe,aAAeM,EAC9BV,EAAuB,aAAeU,EACtCL,EAAe,aAAeK,CAClC,EACA,IAAI,kBAAgB,CAChB,OAAOX,EAAuB,gBAClC,EACA,IAAI,iBAAiBW,EAAK,CACtBR,EAAc,iBAAmBQ,EACjCP,EAAe,iBAAmBO,EAClCX,EAAuB,iBAAmBW,EAC1CN,EAAe,iBAAmBM,EAClCV,EAAuB,iBAAmBU,EAC1CL,EAAe,iBAAmBK,CACtC,EACA,IAAI,uBAAqB,CACrB,OAAOX,EAAuB,qBAClC,EACA,IAAI,sBAAsBW,EAAK,CAC3BR,EAAc,sBAAwBQ,EACtCP,EAAe,sBAAwBO,EACvCX,EAAuB,sBAAwBW,EAC/CN,EAAe,sBAAwBM,EACvCV,EAAuB,sBAAwBU,EAC/CL,EAAe,sBAAwBK,CAC3C,EACA,IAAI,SAAO,CACP,OAAOX,EAAuB,OAClC,EACA,IAAI,OAAK,CACL,OAAOS,CACX,EACA,IAAI,MAAME,EAAK,CAEX,GAAIA,IAAU,MAAQA,EAAM,OAAS,EACjC,MAAMnB,EAAuB,EAGjC,GAAImB,IAAU,KACVX,EAAuB,MAAQW,EAC/BV,EAAuB,MAAQU,MAC5B,CACH,IAAMC,EAAcD,EAAM,OAEpBE,EAAgB,IAAI,aAAaD,EAAc,EAAKA,EAAc,CAAE,EACpEE,EAAgB,IAAI,aAAaF,EAAc,EAAKA,EAAc,CAAE,EAE1EC,EAAc,CAAC,EAAIF,EAAM,CAAC,EAC1BG,EAAc,CAAC,EAAI,CAACH,EAAMC,EAAc,CAAC,EAEzC,IAAMG,EAAS,KAAK,MAAMH,EAAc,GAAK,CAAC,EACxCI,GAAeJ,EAAc,GAAK,EAAI,EAE5C,QAASK,EAAI,EAAGA,EAAIF,EAAQE,GAAK,EAAG,CAChC,IAAMC,EAAkBD,EAAIF,EAAUC,EAEhCG,EAAa,KAAK,MAAMD,CAAc,EACtCE,EAAa,KAAK,KAAKF,CAAc,EAE3CL,EAAcI,CAAC,EACXE,IAAeC,EACTT,EAAMQ,CAAU,GACf,GAAKD,EAAiBC,IAAeR,EAAMQ,CAAU,GACrD,GAAKC,EAAaF,IAAmBP,EAAMS,CAAU,EAChEN,EAAcG,CAAC,EACXE,IAAeC,EACT,CAACT,EAAMC,EAAc,EAAIO,CAAU,EACnC,GAAG,GAAKD,EAAiBC,IAAeR,EAAMC,EAAc,EAAIO,CAAU,IACzE,GAAKC,EAAaF,IAAmBP,EAAMC,EAAc,EAAIQ,CAAU,CACtF,CAEAP,EAAcE,CAAM,EAAIH,EAAc,IAAM,EAAID,EAAMI,EAAS,CAAC,GAAKJ,EAAMI,EAAS,CAAC,EAAIJ,EAAMI,EAAS,CAAC,GAAK,EAE9Gf,EAAuB,MAAQa,EAC/BZ,EAAuB,MAAQa,CACnC,CAEAL,EAAkBE,EAEdH,IACId,EAAUe,CAAe,GAAKF,IAA0C,KACxEA,EAAwChB,EAA2CK,EAAeO,CAAa,EACxGI,IAA0C,OACjDA,EAAqC,EACrCA,EAAwC,MAGpD,EACA,IAAI,QAAM,CACN,MAAO,CAACJ,CAAa,CACzB,EACA,IAAI,gBAAc,CACd,OAAOH,EAAuB,cAClC,EACA,IAAI,iBAAe,CACf,OAAOA,EAAuB,eAClC,EACA,IAAI,YAAU,CACV,OAAOA,EAAuB,UAClC,EACA,IAAI,WAAWW,EAAK,CAChBX,EAAuB,WAAaW,EACpCV,EAAuB,WAAaU,CACxC,EACA,oBAAoBU,EAAW,CAC3B,OAAOlB,EAAc,iBAAiBkB,EAAK,CAAC,EAAGA,EAAK,CAAC,EAAGA,EAAK,CAAC,CAAC,CACnE,EACA,iBAAiBA,EAAW,CACxB,OAAOlB,EAAc,cAAckB,EAAK,CAAC,CAAC,CAC9C,EACA,uBAAuBA,EAAW,CAC9B,OAAOlB,EAAc,oBAAoBkB,EAAK,CAAC,EAAGA,EAAK,CAAC,EAAGA,EAAK,CAAC,CAAC,CACtE,GAGAxB,IAAU,OAEVa,EAA0B,MAAQb,aAAiB,aAAeA,EAAQ,IAAI,aAAaA,CAAK,GAGhGC,IAAeY,EAA0B,aACzCA,EAA0B,WAAaZ,GAG3C,IAAMwB,EAAgB,IAAK,CACvBnB,EAAc,QAAQH,CAAsB,EAAE,QAAQK,CAAc,EAEpEF,EAAc,QAAQC,CAAc,EAAE,QAAQH,CAAsB,EAAE,QAAQK,CAAc,EAAE,QAAQD,CAAc,EAEpHG,EAAc,GAEVd,EAAUe,CAAe,IACzBF,EAAwChB,EAA2CK,EAAeO,CAAa,EAEvH,EACMoB,EAAmB,IAAK,CAC1BpB,EAAc,WAAWH,CAAsB,EAC/CA,EAAuB,WAAWK,CAAc,EAEhDF,EAAc,WAAWC,CAAc,EACvCA,EAAe,WAAWH,CAAsB,EAChDA,EAAuB,WAAWK,CAAc,EAChDA,EAAe,WAAWD,CAAc,EAExCG,EAAc,GAEVD,IAA0C,OAC1CA,EAAqC,EACrCA,EAAwC,KAEhD,EAEA,OAAOZ,EAAmB6B,GAAqBd,EAA2BL,CAAc,EAAGiB,EAAeC,CAAgB,CAC9H,EC7LG,IAAME,GAAqD,IAAM,IAAI,aAAa,GAAI,mBAAmB,ECGhH,IAAMC,GAAkB,CACpB,iBAAkB,GAGTC,GAA+E,CACxFC,EACAC,EACAC,EACAC,EACAC,IAEO,cAAkCJ,CAAiD,CAStF,YAAYK,EAAyCC,EAAYC,EAAU,CACvE,IAAIC,EAEJ,GAAI,OAAOH,GAAM,UAAYC,IAAM,QAAaC,IAAM,OAClDC,EAAU,CAAE,OAAQF,EAAG,iBAAkBD,EAAG,WAAYE,CAAC,UAClD,OAAOF,GAAM,SACpBG,EAAUH,MAEV,OAAM,IAAI,MAAM,qCAAqC,EAGzD,GAAM,CAAE,OAAAI,EAAQ,iBAAAC,EAAkB,WAAAC,CAAU,EAAK,CAAE,GAAGb,GAAiB,GAAGU,CAAO,EAE3EI,EAA4BT,EAAgCO,EAAkBD,EAAQE,CAAU,EAGjGV,EAAgBY,GAAoB,IAAMA,GAAmBD,CAAyB,CAAC,GACxFA,EAA0B,iBACtB,eACC,IAAK,CACF,IAAIE,EAAI,EAEFC,EAAyBC,GAAgB,CACvC,KAAK,SAAW,YACZF,EAAI,GACJF,EAA0B,oBAAoB,cAAeG,CAAqB,EAClFC,EAAM,yBAAwB,EAE9B,KAAK,2BAA2BA,CAAK,GAErCF,GAAK,EAGjB,EAEA,OAAOC,CACX,GAAE,CAAE,EAIZ,MAAMH,EAA2BF,CAAgB,EAEjD,KAAK,QAAUD,EACf,KAAK,2BAA6BG,EAClC,KAAK,OAAS,IAClB,CAEA,IAAI,QAAM,CAEN,OAAI,KAAK,2BAA2B,SAAW,OACpC,KAAK,QAGT,KAAK,2BAA2B,MAC3C,CAEA,IAAI,OAAK,CACL,OAAO,KAAK,SAAW,KAAO,KAAK,2BAA2B,MAAQ,KAAK,MAC/E,CAEO,gBAAc,CAKjB,OAAI,KAAK,SAAW,UACT,QAAQ,OAAOV,EAAuB,CAAE,GAGnD,KAAK,OAAS,UAEPE,EAAe,KAAK,YAAa,KAAK,0BAA0B,EAAE,QAAQ,IAAK,CAClF,KAAK,OAAS,KAEda,GAAqB,IAAI,CAC7B,CAAC,EACL,CAEQ,2BAA2BD,EAAY,CACvC,KAAK,SAAW,KAChB,KAAK,2BAA2B,cAAcA,CAAK,EAEnD,WAAW,IAAM,KAAK,2BAA2BA,CAAK,CAAC,CAE/D,GCzFR,IAAME,GAAkB,CACpB,aAAc,EACd,iBAAkB,MAClB,sBAAuB,WACvB,OAAQ,EACR,UAAW,IACX,aAAc,OACd,KAAM,QAGGC,GAAqE,CAC9EC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,IAEO,cACKN,CAA0D,CAalE,YAAYO,EAAYC,EAAqC,CACzD,IAAMC,EAAgBL,EAAiBG,CAAO,EACxCG,EAAgB,CAAE,GAAGZ,GAAiB,GAAGU,CAAO,EAChDG,EAAuBT,EAA2BO,EAAeC,CAAa,EAC9EE,EAAYP,EAA4BI,CAAa,EACrDI,EAAsDD,EAAYT,EAA4B,EAAK,KACnGW,EAAUP,EAAQ,WAAa,EAErC,MAAMA,EAAS,GAAOI,EAAsBE,CAAsB,EAGlE,KAAK,QAAUZ,EAAiB,KAAMW,EAAWD,EAAqB,OAAQ,OAAQ,OAAO,EAE7F,KAAK,WAAaV,EAAiB,KAAMW,EAAWD,EAAqB,UAAWG,EAAS,CAACA,CAAO,EACrG,KAAK,sBAAwBH,EAC7B,KAAK,SAAW,KAChB,KAAK,wBAA0BE,EAE3B,KAAK,0BAA4B,MAAQH,EAAc,eAAiB,SACjB,KAAK,wBAAyB,aACjFA,EAAc,aAE1B,CAEA,IAAI,QAAM,CACN,OAAO,KAAK,OAChB,CAEA,IAAI,WAAS,CACT,OAAO,KAAK,UAChB,CAEA,IAAI,SAAO,CACP,OAAO,KAAK,QAChB,CAEA,IAAI,QAAQK,EAAK,CACb,IAAMC,EAAkB,OAAOD,GAAU,WAAaT,EAAkB,KAAMS,CAAK,EAAI,KAEvF,KAAK,sBAAsB,QAAUC,EAErC,IAAMC,EAAgB,KAAK,sBAAsB,QAEjD,KAAK,SAAWA,IAAkB,MAAQA,IAAkBD,EAAkBD,EAAQE,CAC1F,CAEA,IAAI,MAAI,CACJ,OAAO,KAAK,sBAAsB,IACtC,CAEA,IAAI,KAAKF,EAAK,CACV,KAAK,sBAAsB,KAAOA,EAE9B,KAAK,0BAA4B,OACjC,KAAK,wBAAwB,aAAe,KAEpD,CAEO,gBAAgBG,EAA0B,CAC7C,KAAK,sBAAsB,gBAAgBA,CAAY,EAEnD,KAAK,0BAA4B,OACjC,KAAK,wBAAwB,aAAeA,EAEpD,CAEO,MAAMC,EAAO,EAAC,CAOjB,GANA,KAAK,sBAAsB,MAAMA,CAAI,EAEjC,KAAK,0BAA4B,OACjC,KAAK,wBAAwB,MAAQA,GAGrC,KAAK,QAAQ,QAAU,SAAU,CACjCC,GAAyB,IAAI,EAE7B,IAAMC,EAA8B,IAAK,CACrC,KAAK,sBAAsB,oBAAoB,QAASA,CAA2B,EAE/EC,GAAkB,IAAI,GACtBC,GAA0B,IAAI,CAEtC,EAEA,KAAK,sBAAsB,iBAAiB,QAASF,CAA2B,CACpF,CACJ,CAEO,KAAKF,EAAO,EAAC,CAChB,KAAK,sBAAsB,KAAKA,CAAI,EAEhC,KAAK,0BAA4B,OACjC,KAAK,wBAAwB,KAAOA,EAE5C,GC/ID,IAAMK,GAA6E,CACtFC,EACAC,EACAC,EACAC,EACAC,IAEO,IAAmE,CACtE,IAAMC,EAAgC,IAAI,QAEtCC,EAAqC,KACrCC,EAAuB,KACvBC,EAAsB,KAEpBC,EAAuB,MAAOC,EAA2BC,IAAyD,CACpH,IAAIC,EAAuBV,EAA6CQ,CAAK,EAGvEG,EAAuCC,EAAiBF,EAAsBD,CAAyB,EAE7G,GAAI,CAACE,EAAsC,CACvC,IAAME,EAAU,CACZ,aAAcH,EAAqB,aACnC,iBAAkBA,EAAqB,iBACvC,sBAAuBA,EAAqB,sBAC5C,OAAQA,EAAqB,OAAO,MACpC,UAAWA,EAAqB,UAAU,MAC1C,aAAcN,IAAiB,KAAO,OAAYA,EAClD,KAAMM,EAAqB,MAG/BA,EAAuBX,EAA2BU,EAA2BI,CAAO,EAEhFR,IAAU,MACVK,EAAqB,MAAML,CAAK,EAGhCC,IAAS,MACTI,EAAqB,KAAKJ,CAAI,CAEtC,CAEA,OAAAH,EAA8B,IAAIM,EAA2BC,CAAoB,EAE5EC,GAID,MAAMb,EAAkBW,EAA2BD,EAAM,OAAQE,EAAqB,MAAM,EAC5F,MAAMZ,EAAkBW,EAA2BD,EAAM,UAAWE,EAAqB,SAAS,IAJlG,MAAMT,EAAiBQ,EAA2BD,EAAM,OAAQE,EAAqB,MAAM,EAC3F,MAAMT,EAAiBQ,EAA2BD,EAAM,UAAWE,EAAqB,SAAS,GAMrG,MAAMR,EAAwBM,EAAOC,EAA2BC,CAAoB,EAE7EA,CACX,EAEA,MAAO,CACH,IAAI,aAAaI,EAA2B,CACxCV,EAAeU,CACnB,EACA,IAAI,MAAMA,EAAa,CACnBT,EAAQS,CACZ,EACA,IAAI,KAAKA,EAAa,CAClBR,EAAOQ,CACX,EACA,OAAON,EAA2BC,EAAqD,CACnF,IAAMM,EAA+BZ,EAA8B,IAAIM,CAAyB,EAEhG,OAAIM,IAAiC,OAC1B,QAAQ,QAAQA,CAA4B,EAGhDR,EAAqBC,EAAOC,CAAyB,CAChE,EAER,ECtEJ,IAAMO,GAAkB,CACpB,aAAc,EACd,iBAAkB,cAClB,sBAAuB,WACvB,eAAgB,IAChB,eAAgB,IAChB,cAAe,EACf,cAAe,UACf,YAAa,IACb,aAAc,EACd,aAAc,EACd,aAAc,EACd,aAAc,aACd,UAAW,EACX,UAAW,EACX,UAAW,EACX,YAAa,EACb,cAAe,GAGNC,GAA6D,CACtEC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,IAEO,cAA6CN,CAAuB,CAevE,YAAYO,EAAYC,EAAiC,CACrD,IAAMC,EAAgBL,EAAiBG,CAAO,EACxCG,EAAgB,CAAE,GAAGZ,GAAiB,GAAGU,CAAO,EAChDG,EAAmBT,EAAuBO,EAAeC,CAAa,EACtEE,EAAYP,EAA4BI,CAAa,EACrDI,EAAmDD,EAAYT,EAAwB,EAAK,KAElG,MAAMI,EAAS,GAAOI,EAAkBE,CAAkB,EAE1D,KAAK,kBAAoBF,EAEzB,KAAK,cAAgBV,EACjB,KACAW,EACAD,EAAiB,aACjBG,GACAC,EAA0B,EAE9B,KAAK,cAAgBd,EACjB,KACAW,EACAD,EAAiB,aACjBG,GACAC,EAA0B,EAE9B,KAAK,cAAgBd,EACjB,KACAW,EACAD,EAAiB,aACjBG,GACAC,EAA0B,EAE9B,KAAK,WAAad,EACd,KACAW,EACAD,EAAiB,UACjBG,GACAC,EAA0B,EAE9B,KAAK,WAAad,EACd,KACAW,EACAD,EAAiB,UACjBG,GACAC,EAA0B,EAE9B,KAAK,WAAad,EACd,KACAW,EACAD,EAAiB,UACjBG,GACAC,EAA0B,EAI9BT,EAAqB,KAAM,CAAC,CAChC,CAEA,IAAI,gBAAc,CACd,OAAO,KAAK,kBAAkB,cAClC,CAEA,IAAI,eAAeU,EAAK,CACpB,KAAK,kBAAkB,eAAiBA,CAC5C,CAEA,IAAI,gBAAc,CACd,OAAO,KAAK,kBAAkB,cAClC,CAEA,IAAI,eAAeA,EAAK,CACpB,KAAK,kBAAkB,eAAiBA,CAC5C,CAEA,IAAI,eAAa,CACb,OAAO,KAAK,kBAAkB,aAClC,CAEA,IAAI,cAAcA,EAAK,CACnB,KAAK,kBAAkB,cAAgBA,CAC3C,CAEA,IAAI,eAAa,CACb,OAAO,KAAK,kBAAkB,aAClC,CAEA,IAAI,cAAcA,EAAK,CACnB,KAAK,kBAAkB,cAAgBA,CAC3C,CAEA,IAAI,aAAW,CACX,OAAO,KAAK,kBAAkB,WAClC,CAEA,IAAI,YAAYA,EAAK,CACjB,KAAK,kBAAkB,YAAcA,CACzC,CAEA,IAAI,cAAY,CACZ,OAAO,KAAK,aAChB,CAEA,IAAI,cAAY,CACZ,OAAO,KAAK,aAChB,CAEA,IAAI,cAAY,CACZ,OAAO,KAAK,aAChB,CAEA,IAAI,cAAY,CACZ,OAAO,KAAK,kBAAkB,YAClC,CAEA,IAAI,aAAaA,EAAK,CAClB,KAAK,kBAAkB,aAAeA,CAC1C,CAEA,IAAI,WAAS,CACT,OAAO,KAAK,UAChB,CAEA,IAAI,WAAS,CACT,OAAO,KAAK,UAChB,CAEA,IAAI,WAAS,CACT,OAAO,KAAK,UAChB,CAEA,IAAI,aAAW,CACX,OAAO,KAAK,kBAAkB,WAClC,CAEA,IAAI,YAAYA,EAAK,CACjB,KAAK,kBAAkB,YAAcA,CACzC,CAEA,IAAI,eAAa,CACb,OAAO,KAAK,kBAAkB,aAClC,CAEA,IAAI,cAAcA,EAAK,CACnB,KAAK,kBAAkB,cAAgBA,CAC3C,GC5LD,IAAMC,GAAqE,CAC9EC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,IAEO,IAAmE,CACtE,IAAMC,EAA2B,IAAI,QAEjCC,EAA4D,KAE1DC,EAAkB,MAAOC,EAAuBC,IAAyD,CAC3G,IAAIC,EAAyC,KACzCC,EAAmBX,EAAyCQ,CAAK,EAE/DI,EAAyB,CAC3B,aAAcD,EAAiB,aAC/B,iBAAkBA,EAAiB,iBACnC,sBAAuBA,EAAiB,uBAEtCE,EAAgC,CAClC,GAAGD,EACH,eAAgBD,EAAiB,eACjC,eAAgBA,EAAiB,eACjC,cAAeA,EAAiB,cAChC,cAAeA,EAAiB,cAChC,YAAaA,EAAiB,YAC9B,aAAcA,EAAiB,aAC/B,YAAaA,EAAiB,YAC9B,cAAeA,EAAiB,eAI9BG,EAAmCC,EAAiBJ,EAAkBF,CAAyB,EAGrG,GAAI,eAAgBE,EAChBD,EAAiBZ,EAAqBW,EAA2B,CAAE,GAAGG,EAAwB,KAAM,CAAC,CAAE,UAChG,CAACE,EAAkC,CAC1C,IAAME,EAAU,CACZ,GAAGH,EACH,aAAcF,EAAiB,aAAa,MAC5C,aAAcA,EAAiB,aAAa,MAC5C,aAAcA,EAAiB,aAAa,MAC5C,UAAWA,EAAiB,UAAU,MACtC,UAAWA,EAAiB,UAAU,MACtC,UAAWA,EAAiB,UAAU,OAG1CA,EAAmBZ,EAAuBU,EAA2BO,CAAO,CAChF,CAIA,GAFAX,EAAyB,IAAII,EAA2BC,IAAmB,KAAOC,EAAmBD,CAAc,EAE/GA,IAAmB,KAAM,CACzB,GAAIJ,IAA0B,KAAM,CAChC,GAAIL,IAAyC,KACzC,MAAM,IAAI,MAAM,qDAAqD,EAGzE,IAAMgB,EAA6B,IAAIhB,EACnC,EAEAO,EAAM,QAAQ,OACdC,EAA0B,UAAU,EAElCS,EAA0BtB,EAA8BqB,EAA4B,CACtF,aAAc,EACd,iBAAkB,WAClB,sBAAuB,WACvB,eAAgB,EACnB,EACDC,EAAwB,QAAQD,EAA2B,WAAW,EAEtEX,GAAyB,SAAW,CAChC,IAAMa,EAA4B,MAAM,QAAQ,IAC5C,CACIX,EAAM,aACNA,EAAM,aACNA,EAAM,aACNA,EAAM,UACNA,EAAM,UACNA,EAAM,WACR,IAAI,MAAOY,EAAYC,IAAS,CAC9B,IAAMC,EAA2BzB,EAA+BoB,EAA4B,CACxF,aAAc,EACd,iBAAkB,WAClB,sBAAuB,WACvB,OAAQI,IAAU,EAAI,EAAI,EAC7B,EAED,aAAMnB,EAAiBe,EAA4BG,EAAYE,EAAyB,MAAM,EAEvFA,CACX,CAAC,CAAC,EAGN,QAASC,EAAI,EAAGA,EAAI,EAAGA,GAAK,EACxBJ,EAA0BI,CAAC,EAAE,QAAQL,EAAyB,EAAGK,CAAC,EAClEJ,EAA0BI,CAAC,EAAE,MAAM,CAAC,EAGxC,OAAOnB,EAAgCa,CAA0B,CACrE,GAAE,CACN,CAEA,IAAMO,EAAiB,MAAMlB,EACvBmB,EAAgB3B,EAAqBW,EAA2B,CAAE,GAAGG,EAAwB,KAAM,CAAC,CAAE,EAE5G,MAAMT,EAAwBK,EAAOC,EAA2BgB,CAAa,EAE7E,IAAMC,EAA+B,CAAA,EAErC,QAASH,EAAI,EAAGA,EAAIC,EAAe,iBAAkBD,GAAK,EACtDG,EAAa,KAAKF,EAAe,eAAeD,CAAC,CAAC,EAGtD,IAAII,EAAkB,CAACD,EAAa,CAAC,EAAE,CAAC,EAAGA,EAAa,CAAC,EAAE,CAAC,EAAGA,EAAa,CAAC,EAAE,CAAC,CAAC,EAC7EE,EAAe,CAACF,EAAa,CAAC,EAAE,CAAC,EAAGA,EAAa,CAAC,EAAE,CAAC,EAAGA,EAAa,CAAC,EAAE,CAAC,CAAC,EAC1EG,EAAe/B,EAAqBW,EAA2B,CAAE,GAAGG,EAAwB,KAAM,CAAC,CAAE,EACrGkB,EAAoB/B,EAAuBU,EAA2B,CACtE,GAAGI,EACH,aAAcc,EAAgB,CAAC,EAC/B,aAAcA,EAAgB,CAAC,EAC/B,aAAcA,EAAgB,CAAC,EAC/B,UAAWC,EAAa,CAAC,EACzB,UAAWA,EAAa,CAAC,EACzB,UAAWA,EAAa,CAAC,EAC5B,EAEDH,EAAc,QAAQI,CAAY,EAAE,QAAiCC,EAAmB,OAAO,CAAC,CAAC,EACjGA,EAAkB,QAAQpB,CAAc,EAExC,QAASa,EAAI,IAAKA,EAAIC,EAAe,OAAQD,GAAK,IAAK,CACnD,IAAMQ,EAAwC,CAACL,EAAa,CAAC,EAAEH,CAAC,EAAGG,EAAa,CAAC,EAAEH,CAAC,EAAGG,EAAa,CAAC,EAAEH,CAAC,CAAC,EACnGS,EAAoC,CAACN,EAAa,CAAC,EAAEH,CAAC,EAAGG,EAAa,CAAC,EAAEH,CAAC,EAAGG,EAAa,CAAC,EAAEH,CAAC,CAAC,EAErG,GACIQ,EAAY,KAAK,CAACE,EAAOZ,IAAUY,IAAUN,EAAgBN,CAAK,CAAC,GACnEW,EAAQ,KAAK,CAACC,EAAOZ,IAAUY,IAAUL,EAAaP,CAAK,CAAC,EAC9D,CACEM,EAAkBI,EAClBH,EAAeI,EAEf,IAAME,EAAcX,EAAId,EAA0B,WAElDoB,EAAa,KAAK,eAAe,EAAGK,CAAW,EAE/CL,EAAe/B,EAAqBW,EAA2B,CAAE,GAAGG,EAAwB,KAAM,CAAC,CAAE,EACrGkB,EAAoB/B,EAAuBU,EAA2B,CAClE,GAAGI,EACH,aAAcc,EAAgB,CAAC,EAC/B,aAAcA,EAAgB,CAAC,EAC/B,aAAcA,EAAgB,CAAC,EAC/B,UAAWC,EAAa,CAAC,EACzB,UAAWA,EAAa,CAAC,EACzB,UAAWA,EAAa,CAAC,EAC5B,EAEDC,EAAa,KAAK,eAAe,EAAGK,CAAW,EAE/CT,EAAc,QAAQI,CAAY,EAAE,QAAiCC,EAAmB,OAAO,CAAC,CAAC,EACjGA,EAAkB,QAAQpB,CAAc,CAC5C,CACJ,CAEA,OAAOA,CACX,CAEA,OAAKI,GAQD,MAAMnB,EAAkBc,EAA2BD,EAAM,aAAcG,EAAiB,YAAY,EACpG,MAAMhB,EAAkBc,EAA2BD,EAAM,aAAcG,EAAiB,YAAY,EACpG,MAAMhB,EAAkBc,EAA2BD,EAAM,aAAcG,EAAiB,YAAY,EACpG,MAAMhB,EAAkBc,EAA2BD,EAAM,UAAWG,EAAiB,SAAS,EAC9F,MAAMhB,EAAkBc,EAA2BD,EAAM,UAAWG,EAAiB,SAAS,EAC9F,MAAMhB,EAAkBc,EAA2BD,EAAM,UAAWG,EAAiB,SAAS,IAZ9F,MAAMT,EAAiBO,EAA2BD,EAAM,aAAcG,EAAiB,YAAY,EACnG,MAAMT,EAAiBO,EAA2BD,EAAM,aAAcG,EAAiB,YAAY,EACnG,MAAMT,EAAiBO,EAA2BD,EAAM,aAAcG,EAAiB,YAAY,EACnG,MAAMT,EAAiBO,EAA2BD,EAAM,UAAWG,EAAiB,SAAS,EAC7F,MAAMT,EAAiBO,EAA2BD,EAAM,UAAWG,EAAiB,SAAS,EAC7F,MAAMT,EAAiBO,EAA2BD,EAAM,UAAWG,EAAiB,SAAS,GAU7FwB,GAAuBxB,CAAgB,EACvC,MAAMR,EAAwBK,EAAOC,EAA2BE,EAAiB,OAAO,CAAC,CAAC,EAE1F,MAAMR,EAAwBK,EAAOC,EAA2BE,CAAgB,EAG7EA,CACX,EAEA,MAAO,CACH,OACIH,EACAC,EAAqD,CAErD,IAAM2B,EAA2C/B,EAAyB,IAAII,CAAyB,EAEvG,OAAI2B,IAA6C,OACtC,QAAQ,QAAQA,CAAwC,EAG5D7B,EAAgBC,EAAOC,CAAyB,CAC3D,EAER,EC9NJ,IAAM4B,GAAkB,CACpB,qBAAsB,IAGbC,GAAiE,CAC1EC,EACAC,EACAC,EACAC,IAEO,MAAMC,EAAY,CACrB,YAAYC,EAAYC,EAAuC,CAC3D,IAAMC,EAAgBN,EAAiBI,CAAO,EACxCG,EAAgBL,EAA4B,CAAE,GAAGL,GAAiB,GAAGQ,CAAO,CAAE,EAC9EG,EAAeT,EAAyBO,EAAeC,CAAa,EAE1E,OAAAN,EAAkB,IAAIO,CAAY,EAG3BA,CACX,CAEO,OAAQ,OAAO,WAAW,EAAEC,EAAiB,CAChD,OACKA,IAAa,MAAQ,OAAOA,GAAa,UAAY,OAAO,eAAeA,CAAQ,IAAMN,GAAa,WACvGF,EAAkB,IAASQ,CAAQ,CAE3C,GC5BD,IAAMC,GAAmD,CAACC,EAAuBC,IAC7E,CAACC,EAA2BC,EAAYC,KAChBJ,EAAsBG,CAAU,EAExC,OAAOC,CAAgB,EAEnCH,EAAyBE,EAAYD,EAA2BE,CAAgB,GCLxF,IAAMC,GAAiE,CAC1EC,EACAC,EACAC,IAEO,MAAOC,EAAWC,EAA2BC,IAAmB,CACnE,IAAMC,EAAuBN,EAAwBG,CAAS,EAE9D,MAAM,QAAQ,IACVG,EAAqB,aAChB,IAAI,CAACC,EAAaC,IACf,MAAM,KAAKD,CAAW,EAAE,IAAI,MAAO,CAACE,EAAQC,CAAM,IAAK,CAEnD,IAAMC,EAA0B,MADNV,EAAqBQ,CAAM,EACG,OAAOA,EAAQL,CAAyB,EAC1FQ,EAA+DT,EAAU,QAAQ,YAEnF,CAACD,EAAeO,CAAM,IAAMN,IAAcS,GAAe,CAACV,EAAeC,CAAS,IAClFQ,EAAwB,QAAQN,EAAiBK,EAAQF,CAAK,CAEtE,CAAC,CAAC,EAEL,OAAO,CAACK,EAAsBC,IAAsB,CAAC,GAAGD,EAAsB,GAAGC,CAAiB,EAAG,CAAA,CAAE,CAAC,CAErH,ECvBG,IAAMC,GAAmE,CAC5EC,EACAC,EACAC,IAEO,MACHC,EACAC,EACAC,IACe,CACf,IAAMC,EAAwBL,EAA4BE,CAAU,EAEpE,MAAM,QAAQ,IACV,MAAM,KAAKG,EAAsB,YAAY,EAAE,IAAI,MAAO,CAACC,EAAQC,CAAM,IAAK,CAE1E,IAAMC,EAA0B,MADNT,EAAqBO,CAAM,EACG,OAAOA,EAAQH,CAAyB,EAE3FF,EAAeK,CAAM,GACtBE,EAAwB,QAAQJ,EAAkBG,CAAM,CAEhE,CAAC,CAAC,CAEV,ECrBG,IAAME,GAAiF,CAC1FC,EACAC,EACAC,EACAC,IAEQC,GAEAJ,EAAgBK,GAAoB,IAAMA,GAAmBD,CAAyB,CAAC,EAEhF,QAAQ,QACXJ,EAAgBG,EAA2CA,CAAyC,CAAC,EACvG,KAAMG,GAA6C,CACjD,GAAI,CAACA,EAA2C,CAC5C,IAAMC,EAAsBL,EAAgCE,EAA2B,IAAK,EAAG,CAAC,EAEhGA,EAA0B,WAAa,IAAK,CACxCG,EAAoB,eAAiB,KACrCA,EAAoB,WAAU,CAClC,EACAA,EAAoB,eAAiB,IAAMH,EAA0B,YAErEG,EAAoB,QAAQH,EAA0B,WAAW,CACrE,CAEA,OAAOA,EAA0B,eAAc,CACnD,CAAC,EAGE,IAAI,QAA6BI,GAAW,CAE/C,IAAMC,EAAWR,EAAqBG,EAA2B,CAC7D,aAAc,EACd,iBAAkB,WAClB,sBAAuB,WACvB,KAAM,EACT,EAEDA,EAA0B,WAAcM,GAAuC,CAC3ED,EAAS,WAAU,EAEnBD,EAAQE,EAAM,cAAc,CAChC,EAEAD,EAAS,QAAQL,EAA0B,WAAW,EAEtDA,EAA0B,eAAc,CAC5C,CAAC,ECjDF,IAAMO,GAAkFC,GACpF,CAACC,EAAwBC,IAAgB,CAC5CF,EAAkC,IAAIC,EAAwBC,CAAY,CAC9E,ECHG,IAAMC,GAA4DC,GAC9D,CAACC,EAAWC,IAAaF,EAAuB,IAAIC,EAAWC,CAAQ,ECA3E,IAAMC,GAA+C,CACxDC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,IAEO,CAACC,EAAaC,IACjBP,EAAqBM,CAAW,EAC3B,OAAOA,EAAaC,CAAyB,EAK7C,KAAK,IACF,QAAQ,IACJ,MAAM,KAAKN,EAA+BM,CAAyB,CAAC,EAAE,IAAKC,GACvER,EAAqBQ,CAAgB,EAAE,OAAOA,EAAkBD,CAAyB,CAAC,CAC7F,CACJ,EAEJ,KAAK,IAAML,EAAgCK,CAAyB,CAAC,EACrE,KAAME,IAGC,OAAOA,EAAY,iBAAoB,YACvCL,EAAkCK,CAAW,EAC7CC,GAAoCD,CAAW,GAG9CV,EAAgBI,EAAqD,IAClEA,EAAoDM,CAAW,CAAC,GAGpEJ,EAA6CI,CAAW,EAG5DX,EAAiB,IAAIW,CAAW,EAEzBA,EACV,EC3Cb,IAAME,GAAkB,CACpB,aAAc,EAKd,iBAAkB,WAClB,sBAAuB,WACvB,IAAK,GAGIC,GAAyE,CAClFC,EACAC,EACAC,EACAC,EACAC,EACAC,IAEO,cAAmDL,CAAuB,CAG7E,YAAYM,EAAYC,EAAuC,CAC3D,IAAMC,EAAgBJ,EAAiBE,CAAO,EACxCG,EAAgB,CAAE,GAAGX,GAAiB,GAAGS,CAAO,EAChDG,EAAyBR,EAA6BM,EAAeC,CAAa,EAClFE,EAAYN,EAA4BG,CAAa,EACrDI,EAAyDD,EAAYR,EAA8B,EAAK,KAE9G,MAAMG,EAAS,GAAOI,EAAwBE,CAAwB,EAEtE,KAAK,KAAOX,EAAiB,KAAMU,EAAWD,EAAuB,GAAG,CAC5E,CAEA,IAAI,KAAG,CACH,OAAO,KAAK,IAChB,GClCD,IAAMG,GAAiF,CAC1FC,EACAC,EACAC,EACAC,EACAC,IAEO,IAAmE,CACtE,IAAMC,EAAkC,IAAI,QAEtCC,EAAyB,MAAOC,EAA6BC,IAAyD,CACxH,IAAIC,EAAyBP,EAA+CK,CAAK,EAM3EG,EAAyCC,EAAiBF,EAAwBD,CAAyB,EAEjH,GAAI,CAACE,EAAwC,CACzC,IAAME,EAAU,CACZ,aAAcH,EAAuB,aACrC,iBAAkBA,EAAuB,iBACzC,sBAAuBA,EAAuB,sBAC9C,IAAKA,EAAuB,IAAI,OAGpCA,EAAyBR,EAA6BO,EAA2BI,CAAO,CAC5F,CAEA,OAAAP,EAAgC,IAAIG,EAA2BC,CAAsB,EAEhFC,EAGD,MAAMV,EAAkBQ,EAA2BD,EAAM,IAAKE,EAAuB,GAAG,EAFxF,MAAMN,EAAiBK,EAA2BD,EAAM,IAAKE,EAAuB,GAAG,EAKvFI,GAAuBJ,CAAsB,EAC7C,MAAML,EAAwBG,EAAOC,EAA2BC,EAAuB,OAAO,CAAC,CAAC,EAEhG,MAAML,EAAwBG,EAAOC,EAA2BC,CAAsB,EAGnFA,CACX,EAEA,MAAO,CACH,OAAOF,EAA6BC,EAAqD,CACrF,IAAMM,EAAiCT,EAAgC,IAAIG,CAAyB,EAEpG,OAAIM,IAAmC,OAC5B,QAAQ,QAAQA,CAA8B,EAGlDR,EAAuBC,EAAOC,CAAyB,CAClE,EAER,EC5DG,IAAMO,GAAsFC,GACxF,IAAK,CACR,GAAIA,IAAiC,KACjC,MAAO,GAGX,GAAI,CACA,IAAIA,EAA6B,CAAE,OAAQ,EAAG,WAAY,KAAK,CAAE,CACrE,MAAQ,CACJ,MAAO,EACX,CAEA,MAAO,EACX,ECbG,IAAMC,GAAyG,CAClHC,EACAC,IAEO,SAAW,CAEd,GAAID,IAAsC,KACtC,MAAO,GAGX,GAAIC,IAAyC,KACzC,MAAO,GAGX,IAAMC,EAAO,IAAI,KACb,CAAC,sHAAsH,EACvH,CACI,KAAM,wCACT,EAGCC,EAAsB,IAAIF,EAAqC,EAAG,IAAK,KAAK,EAC5EG,EAAM,IAAI,gBAAgBF,CAAI,EAEhCG,EAA0B,GAC1BC,EAAiC,GAErC,GAAI,CACA,MAAMH,EAAoB,aAAa,UAAUC,CAAG,EAEpD,IAAMG,EAAmB,IAAIP,EAAkCG,EAAqB,IAAK,CAAE,gBAAiB,CAAC,CAAE,EACzGK,EAAaL,EAAoB,iBAAgB,EAEvDI,EAAiB,KAAK,UAAY,IAAOF,EAA0B,GACnEE,EAAiB,iBAAmB,IAAOD,EAAiC,GAE5EE,EAAW,QAAQD,CAAgB,EACnCC,EAAW,MAAM,CAAC,EAElB,MAAML,EAAoB,eAAc,EAGxC,MAAM,IAAI,QAASM,GAAY,WAAWA,CAAO,CAAC,CACtD,MAAQ,CAER,SACI,IAAI,gBAAgBL,CAAG,CAC3B,CAEA,OAAOC,GAA2B,CAACC,CACvC,ECnDG,IAAMI,GAAqG,CAC9GC,EACAC,IAEO,IAAK,CACR,GAAIA,IAAyC,KACzC,OAAO,QAAQ,QAAQ,EAAK,EAGhC,IAAMC,EAA4B,IAAID,EAAqC,EAAG,EAAG,KAAK,EAGhFE,EAAWH,EAAqBE,EAA2B,CAC7D,aAAc,EACd,iBAAkB,WAClB,sBAAuB,WACvB,KAAM,EACT,EAGD,OAAO,IAAI,QAASE,GAAW,CAC3BF,EAA0B,WAAa,IAAK,CACxCC,EAAS,WAAU,EAEnBC,EAAQF,EAA0B,cAAgB,CAAC,CACvD,EACAA,EAA0B,eAAc,CAC5C,CAAC,CACL,EC5BG,IAAMG,GAA2C,IAAM,IAAI,aAAa,GAAI,cAAc,ECCjG,IAAMC,GAAkB,CACpB,aAAc,EACd,iBAAkB,MAClB,sBAAuB,WACvB,MAAO,KACP,WAAY,QAGHC,GAAqE,CAC9EC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,IAEO,cAAiDN,CAAuB,CAK3E,YAAYO,EAAYC,EAAqC,CACzD,IAAMC,EAAgBL,EAAiBG,CAAO,EACxCG,EAAgB,CAAE,GAAGZ,GAAiB,GAAGU,CAAO,EAChDG,EAAuBT,EAA2BO,EAAeC,CAAa,EAE9EE,EADYP,EAA4BI,CAAa,EACcN,EAA4B,EAAK,KAG1G,MAAMI,EAAS,GAAMI,EAAsBC,CAAsB,EAEjE,KAAK,kBAAoB,GACzB,KAAK,sBAAwBD,EAG7BL,EAAqB,KAAM,CAAC,CAChC,CAEA,IAAI,OAAK,CACL,OAAI,KAAK,kBACE,KAGJ,KAAK,sBAAsB,KACtC,CAEA,IAAI,MAAMO,EAAK,CAEX,GAAIA,IAAU,KACV,KAAK,kBAAoB,GACzB,KAAK,sBAAsB,MAAQ,IAAI,aAAa,CAAC,EAAG,CAAC,CAAC,MACvD,CAGH,GAAIA,EAAM,OAAS,EACf,MAAMZ,EAAuB,EAGjC,KAAK,kBAAoB,GACzB,KAAK,sBAAsB,MAAQY,CACvC,CACJ,CAEA,IAAI,YAAU,CACV,OAAO,KAAK,sBAAsB,UACtC,CAEA,IAAI,WAAWA,EAAK,CAChB,KAAK,sBAAsB,WAAaA,CAC5C,GCpED,IAAMC,GAA6E,CACtFC,EACAC,EACAC,IAEO,IAAmE,CACtE,IAAMC,EAAgC,IAAI,QAEpCC,EAAuB,MAAOC,EAA2BC,IAAyD,CACpH,IAAIC,EAAuBN,EAA6CI,CAAK,EAK7E,GAAI,CAFyCG,EAAiBD,EAAsBD,CAAyB,EAElE,CACvC,IAAMG,EAAU,CACZ,aAAcF,EAAqB,aACnC,iBAAkBA,EAAqB,iBACvC,sBAAuBA,EAAqB,sBAC5C,MAAOA,EAAqB,MAC5B,WAAYA,EAAqB,YAGrCA,EAAuBP,EAA2BM,EAA2BG,CAAO,CACxF,CAEA,OAAAN,EAA8B,IAAIG,EAA2BC,CAAoB,EAE7EG,GAAuBH,CAAoB,EAC3C,MAAML,EAAwBG,EAAOC,EAA2BC,EAAqB,OAAO,CAAC,CAAC,EAE9F,MAAML,EAAwBG,EAAOC,EAA2BC,CAAoB,EAGjFA,CACX,EAEA,MAAO,CACH,OAAOF,EAA2BC,EAAqD,CACnF,IAAMK,EAA+BR,EAA8B,IAAIG,CAAyB,EAEhG,OAAIK,IAAiC,OAC1B,QAAQ,QAAQA,CAA4B,EAGhDP,EAAqBC,EAAOC,CAAyB,CAChE,EAER,ECnDG,IAAMM,GAA+B,IAAO,OAAO,OAAW,IAAc,KAAgB,OCA5F,IAAMC,GAAqF,CAC9FC,EACAC,IAEQC,GAAyC,CAC7CA,EAAY,gBAAkB,CAACC,EAAaC,EAAuBC,EAAuB,IAAK,CAC3F,IAAMC,EAAeN,EAA4BK,CAAoB,EAC/DE,EAAgBP,EAA4BI,CAAqB,EAEvE,GAAIG,GAAiBL,EAAY,iBAC7B,MAAMD,EAAoB,EAG9B,IAAMO,EAAoBN,EAAY,OAChCO,EAAcP,EAAY,eAAeK,CAAa,EACtDG,EAAoBP,EAAY,OAEtC,QAASQ,EAAIL,EAAe,EAAI,CAACA,EAAe,EAAGK,EAAIL,EAAeE,GAAqBG,EAAID,EAAmBC,GAAK,EACnHR,EAAYQ,CAAC,EAAIF,EAAYE,EAAIL,CAAY,CAErD,EAEAJ,EAAY,cAAgB,CAACU,EAAQR,EAAuBC,EAAuB,IAAK,CACpF,IAAMC,EAAeN,EAA4BK,CAAoB,EAC/DE,EAAgBP,EAA4BI,CAAqB,EAEvE,GAAIG,GAAiBL,EAAY,iBAC7B,MAAMD,EAAoB,EAG9B,IAAMO,EAAoBN,EAAY,OAChCO,EAAcP,EAAY,eAAeK,CAAa,EACtDM,EAAeD,EAAO,OAE5B,QAASD,EAAIL,EAAe,EAAI,CAACA,EAAe,EAAGK,EAAIL,EAAeE,GAAqBG,EAAIE,EAAcF,GAAK,EAC9GF,EAAYE,EAAIL,CAAY,EAAIM,EAAOD,CAAC,CAEhD,CACJ,ECtCG,IAAMG,GACTC,GAEQC,GAAyC,CAC7CA,EAAY,iBAAoBC,GACrB,CAACC,EAA2BC,EAA+BC,EAAuB,IAAK,CAC1F,IAAMC,EAAeN,EAA4BK,CAAoB,EAC/DE,EAAgBP,EAA4BI,CAAqB,EAEvE,GAAIE,EAAeL,EAAY,OAC3B,OAAOC,EAAgB,KAAKD,EAAaE,EAAaI,EAAeD,CAAY,CAEzF,GACDL,EAAY,eAAe,EAE9BA,EAAY,eAAkBO,GACnB,CAACC,EAAsBL,EAA+BC,EAAuB,IAAK,CACrF,IAAMC,EAAeN,EAA4BK,CAAoB,EAC/DE,EAAgBP,EAA4BI,CAAqB,EAEvE,GAAIE,EAAeL,EAAY,OAC3B,OAAOO,EAAc,KAAKP,EAAaQ,EAAQF,EAAeD,CAAY,CAElF,GACDL,EAAY,aAAa,CAChC,ECzBG,IAAMS,GACTC,GAEO,CAACC,EAA6BC,IAAiB,CAClD,IAAMC,EAAkBD,EAAc,aAAa,EAAG,EAAG,KAAK,EAE1DD,EAA4B,SAAW,OACvCA,EAA4B,OAASE,GAGzCH,EACIC,EACA,SACCG,GAAQ,IAAK,CACV,IAAMC,EAAQD,EAAI,KAAKH,CAA2B,EAElD,OAAOI,IAAUF,EAAkB,KAAOE,CAC9C,EACCC,GAASD,GACCC,EAAI,KAAKL,EAA6BI,IAAU,KAAOF,EAAkBE,CAAK,CACxF,CAET,ECtBG,IAAME,GAA6D,CAACC,EAAyBC,IACzF,CAACC,EAAeC,IAAqB,CAExCA,EAAkB,aAAe,EACjCA,EAAkB,iBAAmB,WAGrC,OAAO,eAAeA,EAAmB,eAAgB,CACrD,IAAK,IAAM,EACX,IAAK,IAAK,CACN,MAAMH,EAAuB,CACjC,EACH,EAED,OAAO,eAAeG,EAAmB,mBAAoB,CACzD,IAAK,IAAM,WACX,IAAK,IAAK,CACN,MAAMH,EAAuB,CACjC,EACH,EAGD,IAAMI,EAAwBF,EAAc,mBAAkB,EAW9DD,EAAmBE,EATG,IAAK,CACvB,IAAME,EAASF,EAAkB,eAEjC,QAASG,EAAI,EAAGA,EAAID,EAAQC,GAAK,EAC7BF,EAAsB,QAAQD,EAAmB,EAAGG,CAAC,CAE7D,EACyB,IAAMF,EAAsB,WAAWD,CAAiB,CAEZ,CACzE,EClCG,IAAMI,GAA0C,CAACC,EAAaC,EAAQC,IAErEF,EAAY,kBAAoB,OACzBA,EAAY,eAAeE,CAAa,EAAE,CAAC,GAGtDF,EAAY,gBAAgBC,EAAQC,CAAa,EAE1CD,EAAO,CAAC,GCRZ,IAAME,GAAiCC,GAAS,CACnD,GAAIA,IAAU,KACV,MAAO,GAGX,IAAMC,EAASD,EAAM,OAErB,OAAIC,EAAS,IAAM,EACRD,EAAM,KAAK,MAAMC,EAAS,CAAC,CAAC,IAAM,EAGtCD,EAAMC,EAAS,EAAI,CAAC,EAAID,EAAMC,EAAS,CAAC,IAAM,CACzD,ECZO,IAAMC,GAAkD,CAACC,EAAQC,EAAUC,EAAcC,IAAgB,CAC5G,IAAIC,EAAYJ,EAEhB,KAAO,CAACI,EAAU,eAAeH,CAAQ,GACrCG,EAAY,OAAO,eAAeA,CAAS,EAG/C,GAAM,CAAE,IAAAC,EAAK,IAAAC,CAAG,EAAmC,OAAO,yBAAyBF,EAAWH,CAAQ,EAEtG,OAAO,eAAeD,EAAQC,EAAU,CAAE,IAAKC,EAAaG,CAAG,EAAG,IAAKF,EAAaG,CAAG,CAAC,CAAE,CAC9F,ECVO,IAAMC,GAA6EC,IAC/E,CACH,GAAGA,EACH,mBACIA,EAAQ,qBAAuB,OACzBA,EAAQ,mBACRA,EAAQ,iBAAmB,GAAKA,EAAQ,kBAAoB,EAM5D,CAACA,EAAQ,YAAY,EACrB,MAAM,KAAK,CAAE,OAAQA,EAAQ,eAAe,EAAI,IAAM,CAAC,ICblE,IAAMC,GAA2EC,IAC7E,CAAE,GAAGA,EAAS,aAAcA,EAAQ,eAAe,GCDvD,IAAMC,GAAqEC,GAAW,CACzF,GAAM,CAAE,KAAAC,EAAM,KAAAC,CAAI,EAAKF,EAEvB,OAAIC,IAAS,OACLC,IAAS,OACF,CAAE,GAAGF,EAAS,KAAM,CAAC,EAAG,CAAC,EAAG,KAAM,CAAC,EAAG,CAAC,CAAC,EAG5C,CAAE,GAAGA,EAAS,KAAM,MAAM,KAAKE,EAAM,IAAM,CAAC,EAAG,KAAAA,CAAI,EAG1DA,IAAS,OACF,CAAE,GAAGF,EAAS,KAAAC,EAAM,KAAM,MAAM,KAAKA,EAAM,IAAM,CAAC,CAAC,EAGvD,CAAE,GAAGD,EAAS,KAAAC,EAAM,KAAAC,CAAI,CACnC,EChBO,IAAMC,GAAoE,CAACC,EAAYC,EAAOC,IAAa,CAC9G,GAAI,CACAF,EAAW,eAAeC,EAAOC,CAAS,CAC9C,OAASC,EAAK,CACV,GAAIA,EAAI,OAAS,EACb,MAAMA,EAGVJ,GAA4BC,EAAYC,EAAOC,EAAY,IAAI,CACnE,CACJ,ECVO,IAAME,GAA+DC,GAAiC,CACzG,IAAMC,EAA8BD,EAAc,mBAAkB,EAEpEC,EAA4B,MAAK,EAEjC,GAAI,CACAA,EAA4B,MAAK,CACrC,MAAQ,CACJ,MAAO,EACX,CAEA,MAAO,EACX,ECZO,IAAMC,GAA6DC,GAAiC,CACvG,IAAMC,EAA8BD,EAAc,mBAAkB,EAC9DE,EAAoBF,EAAc,aAAa,EAAG,EAAG,KAAK,EAEhEC,EAA4B,OAASC,EAErC,GAAI,CACAD,EAA4B,MAAM,EAAG,CAAC,CAC1C,MAAQ,CACJ,MAAO,EACX,CAEA,MAAO,EACX,ECbO,IAAME,GAA6DC,GAAiC,CACvG,IAAMC,EAA8BD,EAAc,mBAAkB,EAEpEC,EAA4B,MAAK,EAEjC,GAAI,CACAA,EAA4B,KAAI,CACpC,MAAQ,CACJ,MAAO,EACX,CAEA,MAAO,EACX,ECZO,IAAMC,GAAoEC,GAAiC,CAC9G,IAAMC,EAA8BD,EAAc,iBAAgB,EAElE,GAAI,CACAC,EAA4B,MAAM,EAAE,CACxC,OAASC,EAAK,CACV,OAAOA,aAAe,UAC1B,CAEA,MAAO,EACX,ECVO,IAAMC,GAAiEC,GAAiC,CAC3G,IAAMC,EAAoBD,EAAc,aAAa,EAAG,EAAG,KAAK,EAC1DE,EAA8BF,EAAc,mBAAkB,EAEpEE,EAA4B,OAASD,EACrCC,EAA4B,MAAK,EACjCA,EAA4B,KAAI,EAEhC,GAAI,CACA,OAAAA,EAA4B,KAAI,EAEzB,EACX,MAAQ,CACJ,MAAO,EACX,CACJ,ECfO,IAAMC,GAAmEC,GAAiC,CAC7G,IAAMC,EAA8BD,EAAc,iBAAgB,EAElE,GAAI,CACAC,EAA4B,KAAK,EAAE,CACvC,OAASC,EAAK,CACV,OAAOA,aAAe,UAC1B,CAEA,MAAO,EACX,ECVO,IAAMC,GAA2FC,GAA2B,CAC/H,GAAM,CAAE,MAAAC,EAAO,MAAAC,CAAK,EAAK,IAAI,eAE7B,GAAI,CAEAD,EAAM,YAAYD,CAAuB,CAC7C,SACIC,EAAM,MAAK,EACXC,EAAM,MAAK,CACf,CACJ,ECVO,IAAMC,GAAsDC,GAAmE,CAClIA,EAA4B,OAAUC,GAC3B,CAACC,EAAO,EAAGC,EAAS,EAAGC,IAAqB,CAC/C,IAAMC,EAASL,EAA4B,OAErCM,EAAgBD,IAAW,KAAOF,EAAS,KAAK,IAAIE,EAAO,SAAUF,CAAM,EAG7EE,IAAW,MAAQC,EAAgBD,EAAO,SAAW,GAAML,EAA4B,QAAQ,WAC/FC,EAAM,KAAKD,EAA6BE,EAAM,EAAG,CAAC,EAElDD,EAAM,KAAKD,EAA6BE,EAAMI,EAAeF,CAAQ,CAE7E,GACDJ,EAA4B,KAAK,CACxC,ECdO,IAAMO,GAA0H,CACnIC,EACAC,IACA,CACA,IAAMC,EAAiBD,EAAc,WAAU,EAE/CD,EAA+B,QAAQE,CAAc,EAErD,IAAMC,GAAuBC,GAClB,IAAK,CAEiCA,EAAY,KAAKJ,EAAgCE,CAAc,EACxGF,EAA+B,oBAAoB,QAASG,CAAkB,CAClF,GACDH,EAA+B,UAAU,EAE5CA,EAA+B,iBAAiB,QAASG,CAAkB,EAE3EE,GAAqBL,EAAgCE,CAAc,EAEnEF,EAA+B,MAASM,GAAQ,CAC5C,IAAIC,EAAY,GAEhB,MAAO,CAACC,EAAO,IAAK,CAChB,GAAID,EACA,GAAI,CACAD,EAAK,KAAKN,EAAgCQ,CAAI,CAClD,MAAQ,CACJN,EAAe,KAAK,eAAe,EAAGM,CAAI,CAC9C,MAEAF,EAAK,KAAKN,EAAgCQ,CAAI,EAE9CD,EAAY,EAEpB,CACJ,GAAGP,EAA+B,IAAI,CAC1C,ECtCO,IAAMS,GAAgD,CAACC,EAAQC,IAC1DC,GAAS,CACb,IAAMC,EAAa,CAAE,MAAOH,CAAM,EAOlC,OALA,OAAO,iBAAiBE,EAAO,CAC3B,cAAeC,EACf,OAAQA,EACX,EAEG,OAAOF,GAAkB,WAClBA,EAAc,KAAKD,EAAQE,CAAK,EAGpCD,EAAc,YAAY,KAAKD,EAAQE,CAAK,CACvD,E/O8QJ,IAAME,GAAsCC,GAA0CC,EAAkB,EAClGC,GAAuCC,GAA2CF,EAAkB,EACpGG,GAAyCC,GAA6CC,EAAkB,EACxGC,GAAyB,IAAI,QAC7BC,GAAuBC,GAA2BF,EAAsB,EACxEG,GAAkBC,GAAsB,IAAI,IAAO,IAAI,OAAS,EAChEC,GAASC,GAAY,EACrBC,GAA2BC,GAAgCL,GAAiBM,EAAoB,EAChGC,GAAuBC,GAA2BC,EAAuB,EACzEC,GAA0BC,GAA8BF,GAAyBF,GAAsBK,EAAc,EACrHC,GAA6BC,GAAkCV,GAA0BW,EAAoBL,EAAuB,EACpIM,EAAmBC,GAAuBC,EAAa,EACvDC,GAAuCC,GAA2ClB,EAAM,EACxFmB,EAA8BC,GAAkCH,EAAoC,EACpGI,GAAsD,IAAI,QAC1DC,GAAyBC,GAA6BC,EAAiB,EACvEC,GAAgCC,GAAoC1B,EAAM,EAC1E2B,GAAuBC,GAA2BH,EAA6B,EAC/EI,GAAoBC,GAAwB9B,EAAM,EAClD+B,GAAqBC,GAAyBhC,EAAM,EACpDiC,GAAoCC,GAAwClC,EAAM,EAClFmC,GAAuBC,GACzBC,GAA8BC,EAA4B,EAC1DC,GACIpD,GACAG,GACAkD,GACAhD,GACAiD,GACAlC,GACAX,GACA8C,GACA7B,EACAxB,GACAsD,GACAjC,GACAkC,EAAkB,EAEtB9C,GACA+C,GACIC,GACAL,GACAlC,GACAM,EACAkC,GACAJ,EAAiB,EAErBvC,GACA4C,GACAC,GACAC,GACIV,GACAM,GACAvC,GACAM,EACAkC,GACAjC,EACA6B,GACAxB,CAA2B,EAE/BgC,GAAmB9B,GAA0Bd,GAAyB6C,EAAc,EACpF9B,GACAR,EACAa,GACAE,GACAE,GACAZ,EACAc,EAAiC,EAE/BoB,GAAoDC,GACtDnB,GACAxB,GACAP,GACAF,GACAY,EACAK,CAA2B,EAO/B,IAAMoC,GAAsC,IAAI,QAC1CC,GAA+BC,GAAmCC,EAAM,EACxEC,GAA8BC,GAAkC,IAAI,YAAY,CAAC,CAAC,EAClFC,GAAoCC,GAAwCH,GAA6BI,EAAoB,EAC7HC,GAA+CC,GAAmDN,EAA2B,EAC7HO,GAAkDC,GACpDZ,GACAa,GACAC,GACAb,GACAc,GACAC,GAAwCf,EAA4B,EACpEK,GACAG,EAA4C,EAOhD,IAAMQ,GAAsBC,GAA0BC,EAAoB,EACpEC,GAA2BC,GAA+BC,GAAsBC,GAA0BC,EAAc,EACxHC,GAAoBC,GAAwBN,EAAwB,EACpEO,GAAoCC,GACtCX,GACAY,GACAC,GACAC,GACAC,GACAC,GACAC,GACAC,GACAC,GACAC,GAAyDC,EAAkB,EAC3EC,EAAsD,EAEpDC,GAAmBC,GAAuBC,GAA4BnB,EAAwB,EAAGH,EAAwB,EACzHuB,GAAsCC,GACxCnB,GACAE,GACAkB,EACAL,GACAM,EAAuB,EAErBC,GAAmBC,GACrBC,GAA+BC,EAA6B,EAC5DC,GACAC,GACAC,GACA,sCACA,8CACA,+CACA,0CACA,kCACA,iCACA,sCACAC,GACAC,EAA2B,EAEzBC,GAAsEC,GACxEC,GACAf,GACAI,GACAY,EACAhC,GACAiC,EACAC,EACAC,EAAiB,EAOrB,IAAMC,GAAkCC,GACpCC,GACAC,GACAC,GACAC,EACAC,GAAwCC,GAAsBC,EAAkB,EAChFC,EACAC,EACAC,EAAuB,EAErBC,GAAiCC,GACnCC,GACAC,GACAC,EACAC,GACAN,EAAuB,EAErBO,GAAuBC,GAA2BC,EAAsB,EACxEC,GAA4DC,GAC9DpB,GACAqB,GACAX,GACAY,GACAT,GACAN,EACAC,EACAQ,EAAoB,EAElBO,GAAqBC,GAAyBC,GAAoBC,EAAiB,EACnFC,GAAwBC,GAA4BzB,EAAyBoB,EAAkB,EAC/FM,GAAgCC,GAAqCC,GAA+BJ,EAAqB,EACzHK,GAAkCC,GACpCJ,GACAf,EACAL,EAAuB,EAErByB,GAA8DC,GAChEnC,GACAgC,GACAH,GACAtB,EACAC,CAA2B,EAEzB4B,GAAoCC,GACtCC,GACAxB,EACAL,EAAuB,EAErB8B,GAAkEC,GACpExC,GACAoC,GACAE,GACA/B,EACAC,EACAiC,EAA8B,EAE5BC,GAAsCC,GACxCC,GACAC,GACAxC,GACAkB,EAAkB,EAEhBuB,GAAiCC,GACnCH,GACAI,GACAN,GACAO,GACAC,EAA+D,EAE7DC,GAAmCC,GACrCxC,GACAkC,GACAhC,EACAC,GACAN,EAAuB,EAErB4C,GAAgEC,GAClEtD,GACAqB,GACA8B,GACAL,GACAvC,EACAC,EACA+C,EAAiB,EAEfC,GAA4BC,GAAiCC,GAAyBpD,EAAkB,EACxGqD,GAA8BC,GAChCJ,GACA1C,EACAL,EAAuB,EAErBoD,GAAsDC,GACxD9D,GACA2D,GACAH,GACAjD,EACAC,EACAQ,EAAoB,EAElB+C,GAA0BC,GAC5BpD,GACAqD,GACAnD,EACAC,GACAN,EAAuB,EAErByD,GAA8CC,GAChDnE,GACAqB,GACA0C,GACAE,GACA1D,EACAC,EACAQ,EAAoB,EAElBoD,GAAqCC,GAA0CX,EAAuB,EACtGY,GAAuCC,GACzC3D,GACAwD,GACAtD,EACAC,GACAN,EAAuB,EAErB+D,GAAwEC,GAC1EzE,GACAqB,GACAiD,GACAF,GACAV,GACAnD,EACAC,EACAQ,EAAoB,EAElB0D,GAAyBC,GAC3B/D,GACAP,GACAS,EACAC,GACAN,EAAuB,EAErBmE,GAA4CC,GAC9C7E,GACAqB,GACAqD,GACArE,GACAE,EACAC,CAA2B,EAEzBsE,GAAiCC,GACnCzD,GACAnB,EACA6E,GACAtB,EAAuB,EAErBuB,GAAkCC,GACpClC,GACA3C,GACA2E,GACAG,GAAgD9E,GAAsB+E,EAAoC,CAAC,EAEzGC,GAA8BC,GAChCzC,GACA/B,EACAsE,GACA3E,GACAwE,EAA+B,EAE7BM,GAA4BC,GAAiCV,EAA8B,EAC3FW,GAAsDC,GACxD1F,GACAuF,GACAF,GACA9E,EACAC,EACAQ,EAAoB,EAElB2E,GAAsBC,GACxBvE,GACAQ,GACAiB,GACAkC,GACAtB,GACAmC,GACArF,EACAF,EAAkB,EAEhBwF,GAAoE,IAAI,QACxEC,GAAqCC,GACvClG,GACA6F,GACAM,GACAzF,EACAsF,GACAvC,EAAiB,EAEf2C,GAA6BC,GAC/BvD,GACAI,GACAC,GACAmD,GACAlD,GACAmD,EAAsD,EAEpDC,GAA+BC,GACjC3F,GACAsF,GACApF,EACAC,GACAN,EAAuB,EAErB+F,GAAwDC,GAC1DzG,GACAqB,GACA6E,GACAI,GACA/F,EACAC,EACA+C,EAAiB,EAEfmD,GAA6CC,GAAkD9D,EAAiC,EAChI+D,GAAkCC,GACpCH,GACAvG,EACAE,GACAyG,GACAvF,EAAkB,EAEhBwF,GAA6BC,GAC/BN,GACAvG,EACAyG,GACAE,GACAvF,GACAQ,GACAzB,EAAkB,EAEhB2G,GAA8BC,GAChCC,GACAhH,EACA0B,GACAxB,GACA2E,GACA+B,GACArD,GACA0D,GACAvB,GACAtE,EAAkB,EAEhB8F,GAAyBC,GAA8BL,EAA2B,EAClFM,GAA2BC,GAC7B5G,GACAiB,GACAiB,GACAzC,GACAgH,GACAvG,EACAsE,GACArE,GACAN,GACAwE,EAA+B,EAE7BwC,GAAgDC,GAClD1H,GACAqB,GACAgG,GACAE,GACAhH,EACAC,EACAQ,EAAoB,EAElB2G,GAA2BC,GAAgC1H,EAAoB,EAC/E2H,GAAoDC,GACtDH,GACApH,EACA,IAAI,QACJwH,EAA2B,EAEzBC,GAAqCC,GACvCpG,GACAS,GACAjC,GACA0G,GACArD,GACAnC,E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",
  "names": ["require_bundle", "__commonJSMin", "exports", "module", "global", "factory", "createAddUniqueNumber", "generateUniqueNumber", "set", "number", "createCache", "lastNumberWeakMap", "collection", "nextNumber", "MAX_SAFE_INTEGER", "TWO_TO_THE_POWER_OF_TWENTY_NINE", "TWO_TO_THE_POWER_OF_THIRTY", "createGenerateUniqueNumber", "cache", "lastNumber", "LAST_NUMBER_WEAK_MAP", "addUniqueNumber", "require_arrayWithHoles", "__commonJSMin", "exports", "module", "_arrayWithHoles", "arr", "require_iterableToArrayLimit", "__commonJSMin", "exports", "module", "_iterableToArrayLimit", "r", "l", "t", "e", "n", "i", "a", "f", "o", "require_arrayLikeToArray", "__commonJSMin", "exports", "module", "_arrayLikeToArray", "arr", "len", "i", "arr2", "require_unsupportedIterableToArray", "__commonJSMin", "exports", "module", "arrayLikeToArray", "_unsupportedIterableToArray", "o", "minLen", "n", "require_nonIterableRest", "__commonJSMin", "exports", "module", "_nonIterableRest", "require_slicedToArray", "__commonJSMin", "exports", "module", "arrayWithHoles", "iterableToArrayLimit", "unsupportedIterableToArray", "nonIterableRest", "_slicedToArray", "arr", "i", "require_classCallCheck", "__commonJSMin", "exports", "module", "_classCallCheck", "instance", "Constructor", "require_typeof", "__commonJSMin", "exports", "module", "_typeof", "o", "require_toPrimitive", "__commonJSMin", "exports", "module", "_typeof", "toPrimitive", "t", "r", "e", "i", "require_toPropertyKey", "__commonJSMin", "exports", "module", "_typeof", "toPrimitive", "toPropertyKey", "t", "i", "require_createClass", "__commonJSMin", "exports", "module", "toPropertyKey", "_defineProperties", "target", "props", "i", "descriptor", "_createClass", "Constructor", "protoProps", "staticProps", "require_bundle", "__commonJSMin", "exports", "module", "global", "factory", "_slicedToArray", "_classCallCheck", "_createClass", "createExtendedExponentialRampToValueAutomationEvent", "value", "endTime", "insertTime", "createExtendedLinearRampToValueAutomationEvent", "createSetValueAutomationEvent", "startTime", "createSetValueCurveAutomationEvent", "values", "duration", "getTargetValueAtTime", "time", "valueAtStartTime", "_ref", "target", "timeConstant", "isExponentialRampToValueAutomationEvent", "automationEvent", "isLinearRampToValueAutomationEvent", "isAnyRampToValueAutomationEvent", "isSetValueAutomationEvent", "isSetValueCurveAutomationEvent", "getValueOfAutomationEventAtIndexAtTime", "automationEvents", "index", "defaultValue", "getEndTimeAndValueOfPreviousAutomationEvent", "currentAutomationEvent", "nextAutomationEvent", "isCancelAndHoldAutomationEvent", "isCancelScheduledValuesAutomationEvent", "getEventTime", "getExponentialRampValueAtTime", "getLinearRampValueAtTime", "interpolateValue", "theoreticIndex", "lowerIndex", "upperIndex", "getValueCurveValueAtTime", "isSetTargetAutomationEvent", "AutomationEventList", "_Symbol$iterator", "eventTime", "removedAutomationEvent", "lastAutomationEvent", "startValue", "truncatedAutomationEvent", "ratio", "length", "fraction", "i", "factor", "_index", "previousAutomationEvent", "persistentAutomationEvent", "remainingAutomationEvents", "firstRemainingAutomationEvent", "indexOfNextEvent", "indexOfCurrentEvent", "_getEndTimeAndValueOf", "_getEndTimeAndValueOf2", "_getEndTimeAndValueOf3", "_getEndTimeAndValueOf4", "_startTime", "_value", "createCancelAndHoldAutomationEvent", "cancelTime", "createCancelScheduledValuesAutomationEvent", "createExponentialRampToValueAutomationEvent", "createLinearRampToValueAutomationEvent", "createSetTargetAutomationEvent", "Obj", "target", "thisArg", "args", "args2", "enumerate", "list", "value", "index", "ws", "menu", "keys", "WS_ENDPOINT", "WS", "CONNECT_BUTTON", "AVAILABLE_PLAYERS", "event", "id", "sendRequest", "player", "head", "ids", "e", "data", "runJsonData", "request", "index", "enumerate", "playerInstance", "_p", "i", "key", "value", "headInstance", "ballInstance", "import_fast_unique_numbers", "import_automation_events", "createAbortError", "createAddActiveInputConnectionToAudioNode", "insertElementInSet", "activeInputs", "source", "output", "input", "eventListener", "ignoreDuplicates", "activeInputConnection", "createAddAudioNodeConnections", "audioNodeConnectionsStore", "audioNode", "audioNodeRenderer", "nativeAudioNode", "activeInputs", "i", "createAddAudioParamConnections", "audioParamConnectionsStore", "audioParam", "audioParamRenderer", "ACTIVE_AUDIO_NODE_STORE", "AUDIO_NODE_CONNECTIONS_STORE", "AUDIO_NODE_STORE", "AUDIO_PARAM_CONNECTIONS_STORE", "AUDIO_PARAM_STORE", "CONTEXT_STORE", "EVENT_LISTENERS", "CYCLE_COUNTERS", "NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS", "NODE_TO_PROCESSOR_MAPS", "handler", "isConstructible", "constructible", "proxy", "IMPORT_STATEMENT_REGEX", "splitImportStatements", "source", "url", "importStatements", "sourceWithoutImportStatements", "result", "unresolvedUrl", "importStatementWithResolvedUrl", "verifyParameterDescriptors", "parameterDescriptors", "verifyProcessorCtor", "processorCtor", "isConstructible", "createAddAudioWorkletModule", "cacheTestResult", "createNotSupportedError", "evaluateSource", "exposeCurrentFrameAndCurrentTime", "fetchSource", "getNativeContext", "getOrCreateBackupOfflineAudioContext", "isNativeOfflineAudioContext", "nativeAudioWorkletNodeConstructor", "ongoingRequests", "resolvedRequests", "testAudioWorkletProcessorPostMessageSupport", "window", "index", "context", "moduleURL", "options", "resolvedRequestsOfContext", "ongoingRequestsOfContext", "promiseOfOngoingRequest", "nativeContext", "promise", "source", "absoluteUrl", "importStatements", "sourceWithoutImportStatements", "splitImportStatements", "wrappedSource", "evaluateAudioWorkletGlobalScope", "name", "nodeNameToProcessorConstructorMap", "NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS", "isSupportingPostMessage", "currentIndex", "blob", "url", "backupOfflineAudioContext", "nativeContextOrBackupOfflineAudioContext", "updatedResolvedRequestsOfContext", "updatedOngoingRequestsOfContext", "getValueForKey", "map", "key", "value", "pickElementFromSet", "set", "predicate", "matchingElements", "matchingElement", "deletePassiveInputConnectionToAudioNode", "passiveInputs", "source", "output", "input", "passiveInputConnections", "getValueForKey", "matchingConnection", "pickElementFromSet", "passiveInputConnection", "getEventListenersOfAudioNode", "audioNode", "getValueForKey", "EVENT_LISTENERS", "setInternalStateToActive", "audioNode", "ACTIVE_AUDIO_NODE_STORE", "getEventListenersOfAudioNode", "eventListener", "isAudioWorkletNode", "audioNode", "setInternalStateToPassive", "audioNode", "ACTIVE_AUDIO_NODE_STORE", "getEventListenersOfAudioNode", "eventListener", "setInternalStateToPassiveWhenNecessary", "audioNode", "activeInputs", "isAudioWorkletNode", "connections", "setInternalStateToPassive", "createAddConnectionToAudioNode", "addActiveInputConnectionToAudioNode", "addPassiveInputConnectionToAudioNode", "connectNativeAudioNodeToNativeAudioNode", "deleteActiveInputConnectionToAudioNode", "disconnectNativeAudioNodeFromNativeAudioNode", "getAudioNodeConnections", "getAudioNodeTailTime", "getEventListenersOfAudioNode", "getNativeAudioNode", "insertElementInSet", "isActiveAudioNode", "isPartOfACycle", "isPassiveAudioNode", "tailTimeTimeoutIds", "source", "destination", "output", "input", "isOffline", "activeInputs", "passiveInputs", "outputs", "eventListeners", "eventListener", "isActive", "nativeDestinationAudioNode", "nativeSourceAudioNode", "partialConnection", "deletePassiveInputConnectionToAudioNode", "setInternalStateToActive", "tailTime", "setInternalStateToPassiveWhenNecessary", "tailTimeTimeoutId", "outputConnection", "createAddPassiveInputConnectionToAudioNode", "insertElementInSet", "passiveInputs", "input", "source", "output", "eventListener", "ignoreDuplicates", "passiveInputConnections", "passiveInputConnection", "createAddSilentConnection", "createNativeGainNode", "nativeContext", "nativeAudioScheduledSourceNode", "nativeGainNode", "disconnect", "createAddUnrenderedAudioWorkletNode", "getUnrenderedAudioWorkletNodes", "nativeContext", "audioWorkletNode", "DEFAULT_OPTIONS", "createAnalyserNodeConstructor", "audionNodeConstructor", "createAnalyserNodeRenderer", "createIndexSizeError", "createNativeAnalyserNode", "getNativeContext", "isNativeOfflineAudioContext", "context", "options", "nativeContext", "mergedOptions", "nativeAnalyserNode", "analyserNodeRenderer", "value", "maxDecibels", "minDecibels", "array", "isOwnedByContext", "nativeAudioNode", "nativeContext", "createAnalyserNodeRendererFactory", "createNativeAnalyserNode", "getNativeAudioNode", "renderInputsOfAudioNode", "renderedNativeAnalyserNodes", "createAnalyserNode", "proxy", "nativeOfflineAudioContext", "nativeAnalyserNode", "isOwnedByContext", "options", "renderedNativeAnalyserNode", "testAudioBufferCopyChannelMethodsOutOfBoundsSupport", "nativeAudioBuffer", "createIndexSizeError", "wrapAudioBufferGetChannelDataMethod", "audioBuffer", "getChannelData", "channel", "err", "createIndexSizeError", "DEFAULT_OPTIONS", "createAudioBufferConstructor", "audioBufferStore", "cacheTestResult", "createNotSupportedError", "nativeAudioBufferConstructor", "nativeOfflineAudioContextConstructor", "testNativeAudioBufferConstructorSupport", "wrapAudioBufferCopyChannelMethods", "wrapAudioBufferCopyChannelMethodsOutOfBounds", "nativeOfflineAudioContext", "AudioBuffer", "options", "length", "numberOfChannels", "sampleRate", "audioBuffer", "wrapAudioBufferGetChannelDataMethod", "testAudioBufferCopyChannelMethodsOutOfBoundsSupport", "instance", "MOST_NEGATIVE_SINGLE_FLOAT", "MOST_POSITIVE_SINGLE_FLOAT", "isActiveAudioNode", "audioNode", "ACTIVE_AUDIO_NODE_STORE", "DEFAULT_OPTIONS", "createAudioBufferSourceNodeConstructor", "audioNodeConstructor", "createAudioBufferSourceNodeRenderer", "createAudioParam", "createInvalidStateError", "createNativeAudioBufferSourceNode", "getNativeContext", "isNativeOfflineAudioContext", "wrapEventListener", "context", "options", "nativeContext", "mergedOptions", "nativeAudioBufferSourceNode", "isOffline", "audioBufferSourceNodeRenderer", "MOST_POSITIVE_SINGLE_FLOAT", "MOST_NEGATIVE_SINGLE_FLOAT", "value", "wrappedListener", "nativeOnEnded", "when", "offset", "duration", "setInternalStateToActive", "resetInternalStateToPassive", "isActiveAudioNode", "setInternalStateToPassive", "createAudioBufferSourceNodeRendererFactory", "connectAudioParam", "createNativeAudioBufferSourceNode", "getNativeAudioNode", "renderAutomation", "renderInputsOfAudioNode", "renderedNativeAudioBufferSourceNodes", "start", "stop", "createAudioBufferSourceNode", "proxy", "nativeOfflineAudioContext", "nativeAudioBufferSourceNode", "nativeAudioBufferSourceNodeIsOwnedByContext", "isOwnedByContext", "options", "value", "renderedNativeAudioBufferSourceNode", "isAudioBufferSourceNode", "audioNode", "isBiquadFilterNode", "audioNode", "isConstantSourceNode", "audioNode", "isGainNode", "audioNode", "isOscillatorNode", "audioNode", "isStereoPannerNode", "audioNode", "getAudioNodeConnections", "audioNode", "getValueForKey", "AUDIO_NODE_CONNECTIONS_STORE", "getAudioParamConnections", "audioParam", "getValueForKey", "AUDIO_PARAM_CONNECTIONS_STORE", "deactivateActiveAudioNodeInputConnections", "audioNode", "trace", "activeInputs", "getAudioNodeConnections", "connections", "source", "audioParams", "isAudioBufferSourceNode", "isAudioWorkletNode", "isBiquadFilterNode", "isConstantSourceNode", "isGainNode", "isOscillatorNode", "isStereoPannerNode", "audioParam", "audioParamConnections", "getAudioParamConnections", "isActiveAudioNode", "setInternalStateToPassive", "deactivateAudioGraph", "context", "deactivateActiveAudioNodeInputConnections", "isValidLatencyHint", "latencyHint", "createAudioContextConstructor", "baseAudioContextConstructor", "createInvalidStateError", "createNotSupportedError", "createUnknownError", "mediaElementAudioSourceNodeConstructor", "mediaStreamAudioDestinationNodeConstructor", "mediaStreamAudioSourceNodeConstructor", "mediaStreamTrackAudioSourceNodeConstructor", "nativeAudioContextConstructor", "options", "nativeAudioContext", "err", "isValidLatencyHint", "latencyHint", "sampleRate", "revokeState", "deactivateAudioGraph", "mediaElement", "mediaStream", "mediaStreamTrack", "resolve", "reject", "resolvePromise", "createAudioDestinationNodeConstructor", "audioNodeConstructor", "createAudioDestinationNodeRenderer", "createIndexSizeError", "createInvalidStateError", "createNativeAudioDestinationNode", "getNativeContext", "isNativeOfflineAudioContext", "renderInputsOfAudioNode", "context", "channelCount", "nativeContext", "isOffline", "nativeAudioDestinationNode", "audioDestinationNodeRenderer", "value", "createAudioDestinationNodeRenderer", "renderInputsOfAudioNode", "renderedNativeAudioDestinationNodes", "createAudioDestinationNode", "proxy", "nativeOfflineAudioContext", "nativeAudioDestinationNode", "renderedNativeAudioDestinationNode", "createAudioListenerFactory", "createAudioParam", "createNativeChannelMergerNode", "createNativeConstantSourceNode", "createNativeScriptProcessorNode", "createNotSupportedError", "getFirstSample", "isNativeOfflineAudioContext", "overwriteAccessors", "context", "nativeContext", "nativeListener", "createFakeAudioParams", "buffer", "channelMergerNode", "isOffline", "isScriptProcessorNodeCreated", "lastOrientation", "lastPosition", "createScriptProcessorNode", "scriptProcessorNode", "inputBuffer", "orientation", "value", "index", "positon", "createSetOrientation", "createSetPosition", "createFakeAudioParam", "input", "initialValue", "setValue", "constantSourceNode", "audioParam", "MOST_POSITIVE_SINGLE_FLOAT", "MOST_NEGATIVE_SINGLE_FLOAT", "get", "set", "err", "cancelAndHoldAtTime", "args", "cancelScheduledValues", "exponentialRampToValueAtTime", "linearRampToValueAtTime", "setTargetAtTime", "setValueAtTime", "setValueCurveAtTime", "forwardX", "forwardY", "forwardZ", "positionX", "positionY", "positionZ", "upX", "upY", "upZ", "isAudioNode", "audioNodeOrAudioParam", "isAudioNodeOutputConnection", "outputConnection", "isAudioNode", "insertElementInSet", "set", "element", "predicate", "ignoreDuplicates", "lmnt", "addActiveInputConnectionToAudioParam", "activeInputs", "source", "output", "eventListener", "ignoreDuplicates", "insertElementInSet", "activeInputConnection", "addPassiveInputConnectionToAudioParam", "passiveInputs", "source", "output", "eventListener", "ignoreDuplicates", "passiveInputConnections", "insertElementInSet", "passiveInputConnection", "isNativeAudioNodeFaker", "nativeAudioNodeOrNativeAudioNodeFaker", "connectNativeAudioNodeToNativeAudioNode", "nativeSourceAudioNode", "nativeDestinationAudioNode", "output", "input", "isNativeAudioNodeFaker", "fakeNativeDestinationAudioNode", "deleteActiveInputConnection", "activeInputConnections", "source", "output", "activeInputConnection", "deleteActiveInputConnectionToAudioParam", "activeInputs", "source", "output", "pickElementFromSet", "activeInputConnection", "deleteEventListenerOfAudioNode", "audioNode", "eventListener", "getEventListenersOfAudioNode", "deletePassiveInputConnectionToAudioParam", "passiveInputs", "source", "output", "passiveInputConnections", "getValueForKey", "matchingConnection", "pickElementFromSet", "passiveInputConnection", "disconnectNativeAudioNodeFromNativeAudioNode", "nativeSourceAudioNode", "nativeDestinationAudioNode", "output", "input", "isNativeAudioNodeFaker", "getNativeAudioNode", "audioNode", "getValueForKey", "AUDIO_NODE_STORE", "getNativeAudioParam", "audioParam", "getValueForKey", "AUDIO_PARAM_STORE", "isPartOfACycle", "audioNode", "CYCLE_COUNTERS", "isPassiveAudioNode", "audioNode", "ACTIVE_AUDIO_NODE_STORE", "testAudioNodeDisconnectMethodSupport", "nativeAudioContext", "nativeAudioWorkletNodeConstructor", "resolve", "analyzer", "dummy", "ones", "channelData", "source", "event", "chnnlDt", "sample", "visitEachAudioNodeOnce", "cycles", "visitor", "counts", "cycle", "audioNode", "count", "isNativeAudioNode", "nativeAudioNodeOrAudioParam", "wrapAudioNodeDisconnectMethod", "nativeAudioNode", "connections", "connect", "destination", "output", "input", "returnValue", "isNativeAudioNode", "connectionsToDestination", "connection", "disconnect", "destinationOrOutput", "filteredConnections", "addConnectionToAudioParamOfAudioContext", "source", "destination", "output", "isOffline", "activeInputs", "passiveInputs", "getAudioParamConnections", "outputs", "getAudioNodeConnections", "eventListeners", "getEventListenersOfAudioNode", "eventListener", "isActive", "nativeAudioNode", "getNativeAudioNode", "nativeAudioParam", "getNativeAudioParam", "partialConnection", "deletePassiveInputConnectionToAudioParam", "addActiveInputConnectionToAudioParam", "isPartOfACycle", "deleteActiveInputConnectionToAudioParam", "addPassiveInputConnectionToAudioParam", "insertElementInSet", "outputConnection", "isActiveAudioNode", "deleteInputConnectionOfAudioNode", "input", "activeInputConnection", "deleteActiveInputConnection", "deletePassiveInputConnectionToAudioNode", "deleteInputConnectionOfAudioParam", "deleteInputsOfAudioNode", "listener", "deleteEventListenerOfAudioNode", "disconnectNativeAudioNodeFromNativeAudioNode", "setInternalStateToPassiveWhenNecessary", "deleteInputsOfAudioParam", "deleteAnyConnection", "audioNodeConnectionsOfSource", "destinations", "isAudioNodeOutputConnection", "deleteConnectionAtOutput", "deleteConnectionToDestination", "createAudioNodeConstructor", "addAudioNodeConnections", "addConnectionToAudioNode", "cacheTestResult", "createIncrementCycleCounter", "createIndexSizeError", "createInvalidAccessError", "createNotSupportedError", "decrementCycleCounter", "detectCycles", "eventTargetConstructor", "getNativeContext", "isNativeAudioContext", "isNativeAudioNode", "isNativeAudioParam", "isNativeOfflineAudioContext", "nativeAudioWorkletNodeConstructor", "context", "audioNodeRenderer", "nativeContext", "testAudioNodeDisconnectMethodSupport", "wrapAudioNodeDisconnectMethod", "AUDIO_NODE_STORE", "EVENT_LISTENERS", "setInternalStateToActive", "value", "isAudioNode", "nativeDestinationAudioNode", "connection", "connectNativeAudioNodeToNativeAudioNode", "isPassive", "isPassiveAudioNode", "err", "cycles", "visitEachAudioNodeOnce", "destinationOrOutput", "import_automation_events", "createAudioParamFactory", "addAudioParamConnections", "audioParamAudioNodeStore", "audioParamStore", "createAudioParamRenderer", "createCancelAndHoldAutomationEvent", "createCancelScheduledValuesAutomationEvent", "createExponentialRampToValueAutomationEvent", "createLinearRampToValueAutomationEvent", "createSetTargetAutomationEvent", "createSetValueAutomationEvent", "createSetValueCurveAutomationEvent", "nativeAudioContextConstructor", "setValueAtTimeUntilPossible", "audioNode", "isAudioParamOfOfflineAudioContext", "nativeAudioParam", "maxValue", "minValue", "defaultValue", "automationEventList", "audioParamRenderer", "audioParam", "value", "cancelTime", "previousLastEvent", "currentLastEvent", "endTime", "currentTime", "target", "startTime", "timeConstant", "values", "duration", "convertedValues", "sampleRate", "firstSample", "lastSample", "numberOfInterpolatedValues", "interpolatedValues", "i", "theoreticIndex", "lowerIndex", "upperIndex", "timeOfLastSample", "createAudioParamRenderer", "automationEventList", "audioParam", "automationEvent", "endTime", "value", "startTime", "target", "timeConstant", "duration", "values", "ReadOnlyMap", "parameters", "callback", "thisArg", "value", "key", "name", "DEFAULT_OPTIONS", "createAudioWorkletNodeConstructor", "addUnrenderedAudioWorkletNode", "audioNodeConstructor", "createAudioParam", "createAudioWorkletNodeRenderer", "createNativeAudioWorkletNode", "getAudioNodeConnections", "getBackupOfflineAudioContext", "getNativeContext", "isNativeOfflineAudioContext", "nativeAudioWorkletNodeConstructor", "sanitizeAudioWorkletNodeOptions", "setActiveAudioWorkletNodeInputs", "testAudioWorkletNodeOptionsClonability", "wrapEventListener", "context", "name", "options", "nativeContext", "isOffline", "mergedOptions", "nodeNameToProcessorConstructorMap", "NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS", "processorConstructor", "nativeContextOrBackupOfflineAudioContext", "_a", "nativeAudioWorkletNode", "audioWorkletNodeRenderer", "parameters", "nativeAudioParam", "nm", "audioParam", "ReadOnlyMap", "activeInputs", "value", "wrappedListener", "nativeOnProcessorError", "copyFromChannel", "audioBuffer", "parent", "key", "channelNumber", "bufferOffset", "channelData", "slicedInput", "copyToChannel", "audioBuffer", "parent", "key", "channelNumber", "bufferOffset", "createNestedArrays", "x", "y", "arrays", "i", "array", "length", "j", "getAudioWorkletProcessor", "nativeOfflineAudioContext", "proxy", "nodeToProcessorMap", "getValueForKey", "NODE_TO_PROCESSOR_MAPS", "nativeAudioWorkletNode", "getNativeAudioNode", "processBuffer", "proxy", "renderedBuffer", "nativeOfflineAudioContext", "options", "outputChannelCount", "processorConstructor", "exposeCurrentFrameAndCurrentTime", "length", "numberOfInputChannels", "numberOfOutputChannels", "sum", "value", "processedBuffer", "audioNodeConnections", "getAudioNodeConnections", "audioWorkletProcessor", "getAudioWorkletProcessor", "inputs", "createNestedArrays", "outputs", "parameters", "prmtrs", "name", "i", "j", "k", "copyFromChannel", "index", "potentiallyEmptyInputs", "input", "activeSourceFlag", "outputChannelSplitterNodeOutput", "copyToChannel", "error", "createAudioWorkletNodeRendererFactory", "connectAudioParam", "connectMultipleOutputs", "createNativeAudioBufferSourceNode", "createNativeChannelMergerNode", "createNativeChannelSplitterNode", "createNativeConstantSourceNode", "createNativeGainNode", "deleteUnrenderedAudioWorkletNode", "disconnectMultipleOutputs", "getNativeAudioNode", "nativeAudioWorkletNodeConstructor", "nativeOfflineAudioContextConstructor", "renderAutomation", "renderInputsOfAudioNode", "renderNativeOfflineAudioContext", "renderedNativeAudioNodes", "processedBufferPromise", "createAudioNode", "nativeAudioWorkletNode", "nativeOutputNodes", "nativeAudioWorkletNodeIsOwnedByContext", "isOwnedByContext", "outputChannelSplitterNode", "outputChannelMergerNodes", "outputGainNode", "numberOfParameters", "numberOfChannels", "partialOfflineAudioContext", "gainNodes", "inputChannelSplitterNodes", "constantSourceNodes", "audioParam", "constantSourceNode", "inputChannelMergerNode", "gainNode", "audioBufferSourceNode", "outputChannelMergerNode", "nm", "renderedNativeAudioWorkletNodeOrGainNode", "createBaseAudioContextConstructor", "addAudioWorkletModule", "analyserNodeConstructor", "audioBufferConstructor", "audioBufferSourceNodeConstructor", "biquadFilterNodeConstructor", "channelMergerNodeConstructor", "channelSplitterNodeConstructor", "constantSourceNodeConstructor", "convolverNodeConstructor", "decodeAudioData", "delayNodeConstructor", "dynamicsCompressorNodeConstructor", "gainNodeConstructor", "iIRFilterNodeConstructor", "minimalBaseAudioContextConstructor", "oscillatorNodeConstructor", "pannerNodeConstructor", "periodicWaveConstructor", "stereoPannerNodeConstructor", "waveShaperNodeConstructor", "_nativeContext", "numberOfChannels", "moduleURL", "options", "length", "sampleRate", "numberOfInputs", "numberOfOutputs", "maxDelayTime", "feedforward", "feedback", "real", "imag", "constraints", "audioData", "successCallback", "errorCallback", "audioBuffer", "err", "DEFAULT_OPTIONS", "createBiquadFilterNodeConstructor", "audioNodeConstructor", "createAudioParam", "createBiquadFilterNodeRenderer", "createInvalidAccessError", "createNativeBiquadFilterNode", "getNativeContext", "isNativeOfflineAudioContext", "setAudioNodeTailTime", "context", "options", "nativeContext", "mergedOptions", "nativeBiquadFilterNode", "isOffline", "biquadFilterNodeRenderer", "MOST_POSITIVE_SINGLE_FLOAT", "MOST_NEGATIVE_SINGLE_FLOAT", "value", "frequencyHz", "magResponse", "phaseResponse", "err", "createBiquadFilterNodeRendererFactory", "connectAudioParam", "createNativeBiquadFilterNode", "getNativeAudioNode", "renderAutomation", "renderInputsOfAudioNode", "renderedNativeBiquadFilterNodes", "createBiquadFilterNode", "proxy", "nativeOfflineAudioContext", "nativeBiquadFilterNode", "nativeBiquadFilterNodeIsOwnedByContext", "isOwnedByContext", "options", "renderedNativeBiquadFilterNode", "createCacheTestResult", "ongoingTests", "testResults", "tester", "test", "cachedTestResult", "ongoingTest", "synchronousTestResult", "finalTestResult", "DEFAULT_OPTIONS", "createChannelMergerNodeConstructor", "audioNodeConstructor", "createChannelMergerNodeRenderer", "createNativeChannelMergerNode", "getNativeContext", "isNativeOfflineAudioContext", "context", "options", "nativeContext", "mergedOptions", "nativeChannelMergerNode", "channelMergerNodeRenderer", "createChannelMergerNodeRendererFactory", "createNativeChannelMergerNode", "getNativeAudioNode", "renderInputsOfAudioNode", "renderedNativeAudioNodes", "createAudioNode", "proxy", "nativeOfflineAudioContext", "nativeAudioNode", "isOwnedByContext", "options", "renderedNativeAudioNode", "DEFAULT_OPTIONS", "createChannelSplitterNodeConstructor", "audioNodeConstructor", "createChannelSplitterNodeRenderer", "createNativeChannelSplitterNode", "getNativeContext", "isNativeOfflineAudioContext", "sanitizeChannelSplitterOptions", "context", "options", "nativeContext", "mergedOptions", "nativeChannelSplitterNode", "channelSplitterNodeRenderer", "createChannelSplitterNodeRendererFactory", "createNativeChannelSplitterNode", "getNativeAudioNode", "renderInputsOfAudioNode", "renderedNativeAudioNodes", "createAudioNode", "proxy", "nativeOfflineAudioContext", "nativeAudioNode", "isOwnedByContext", "options", "renderedNativeAudioNode", "createConnectAudioParam", "renderInputsOfAudioParam", "nativeOfflineAudioContext", "audioParam", "nativeAudioParam", "createConnectMultipleOutputs", "createIndexSizeError", "outputAudioNodes", "destination", "output", "input", "outputAudioNode", "isNativeAudioNode", "createConnectedNativeAudioBufferSourceNodeFactory", "createNativeAudioBufferSourceNode", "nativeContext", "nativeAudioNode", "nativeAudioBufferSourceNode", "nativeAudioBuffer", "DEFAULT_OPTIONS", "createConstantSourceNodeConstructor", "audioNodeConstructor", "createAudioParam", "createConstantSourceNodeRendererFactory", "createNativeConstantSourceNode", "getNativeContext", "isNativeOfflineAudioContext", "wrapEventListener", "context", "options", "nativeContext", "mergedOptions", "nativeConstantSourceNode", "isOffline", "constantSourceNodeRenderer", "MOST_POSITIVE_SINGLE_FLOAT", "MOST_NEGATIVE_SINGLE_FLOAT", "value", "wrappedListener", "nativeOnEnded", "when", "setInternalStateToActive", "resetInternalStateToPassive", "isActiveAudioNode", "setInternalStateToPassive", "createConstantSourceNodeRendererFactory", "connectAudioParam", "createNativeConstantSourceNode", "getNativeAudioNode", "renderAutomation", "renderInputsOfAudioNode", "renderedNativeConstantSourceNodes", "start", "stop", "createConstantSourceNode", "proxy", "nativeOfflineAudioContext", "nativeConstantSourceNode", "nativeConstantSourceNodeIsOwnedByContext", "isOwnedByContext", "options", "value", "renderedNativeConstantSourceNode", "createConvertNumberToUnsignedLong", "unit32Array", "value", "DEFAULT_OPTIONS", "createConvolverNodeConstructor", "audioNodeConstructor", "createConvolverNodeRenderer", "createNativeConvolverNode", "getNativeContext", "isNativeOfflineAudioContext", "setAudioNodeTailTime", "context", "options", "nativeContext", "mergedOptions", "nativeConvolverNode", "convolverNodeRenderer", "value", "createConvolverNodeRendererFactory", "createNativeConvolverNode", "getNativeAudioNode", "renderInputsOfAudioNode", "renderedNativeConvolverNodes", "createConvolverNode", "proxy", "nativeOfflineAudioContext", "nativeConvolverNode", "isOwnedByContext", "options", "isNativeAudioNodeFaker", "renderedNativeConvolverNode", "createCreateNativeOfflineAudioContext", "createNotSupportedError", "nativeOfflineAudioContextConstructor", "numberOfChannels", "length", "sampleRate", "err", "createDataCloneError", "detachArrayBuffer", "arrayBuffer", "port1", "port2", "resolve", "closeAndResolve", "createDecodeAudioData", "audioBufferStore", "cacheTestResult", "createDataCloneError", "createEncodingError", "detachedArrayBuffers", "getNativeContext", "isNativeContext", "testAudioBufferCopyChannelMethodsOutOfBoundsSupport", "testPromiseSupport", "wrapAudioBufferCopyChannelMethods", "wrapAudioBufferCopyChannelMethodsOutOfBounds", "anyContext", "audioData", "nativeContext", "err", "audioBuffer", "detachArrayBuffer", "resolve", "reject", "complete", "fail", "wrapAudioBufferGetChannelDataMethod", "createDecrementCycleCounter", "connectNativeAudioNodeToNativeAudioNode", "cycleCounters", "getAudioNodeConnections", "getNativeAudioNode", "getNativeAudioParam", "getNativeContext", "isActiveAudioNode", "isNativeOfflineAudioContext", "audioNode", "count", "cycleCounter", "nativeContext", "isOffline", "nativeSourceAudioNode", "outputs", "output", "isAudioNodeOutputConnection", "nativeDestinationAudioNode", "nativeDestinationAudioParam", "DEFAULT_OPTIONS", "createDelayNodeConstructor", "audioNodeConstructor", "createAudioParam", "createDelayNodeRenderer", "createNativeDelayNode", "getNativeContext", "isNativeOfflineAudioContext", "setAudioNodeTailTime", "context", "options", "nativeContext", "mergedOptions", "nativeDelayNode", "isOffline", "delayNodeRenderer", "createDelayNodeRendererFactory", "connectAudioParam", "createNativeDelayNode", "getNativeAudioNode", "renderAutomation", "renderInputsOfAudioNode", "maxDelayTime", "renderedNativeDelayNodes", "createDelayNode", "proxy", "nativeOfflineAudioContext", "nativeDelayNode", "nativeDelayNodeIsOwnedByContext", "isOwnedByContext", "options", "renderedNativeDelayNode", "createDeleteActiveInputConnectionToAudioNode", "pickElementFromSet", "activeInputs", "source", "output", "input", "activeInputConnection", "createDeleteUnrenderedAudioWorkletNode", "getUnrenderedAudioWorkletNodes", "nativeContext", "audioWorkletNode", "isDelayNode", "audioNode", "createDetectCycles", "audioParamAudioNodeStore", "getAudioNodeConnections", "getValueForKey", "detectCycles", "chain", "nextLink", "audioNode", "isAudioNode", "isDelayNode", "outputs", "outputConnection", "mergedCycles", "nestedCycles", "getOutputAudioNodeAtIndex", "createIndexSizeError", "outputAudioNodes", "output", "outputAudioNode", "createDisconnectMultipleOutputs", "destinationOrOutput", "input", "isNativeAudioNode", "DEFAULT_OPTIONS", "createDynamicsCompressorNodeConstructor", "audioNodeConstructor", "createAudioParam", "createDynamicsCompressorNodeRenderer", "createNativeDynamicsCompressorNode", "createNotSupportedError", "getNativeContext", "isNativeOfflineAudioContext", "setAudioNodeTailTime", "context", "options", "nativeContext", "mergedOptions", "nativeDynamicsCompressorNode", "isOffline", "dynamicsCompressorNodeRenderer", "value", "previousChannelCount", "createDynamicsCompressorNodeRendererFactory", "connectAudioParam", "createNativeDynamicsCompressorNode", "getNativeAudioNode", "renderAutomation", "renderInputsOfAudioNode", "renderedNativeDynamicsCompressorNodes", "createDynamicsCompressorNode", "proxy", "nativeOfflineAudioContext", "nativeDynamicsCompressorNode", "nativeDynamicsCompressorNodeIsOwnedByContext", "isOwnedByContext", "options", "renderedNativeDynamicsCompressorNode", "createEncodingError", "createEvaluateSource", "window", "source", "resolve", "reject", "head", "script", "blob", "url", "originalOnErrorHandler", "removeErrorEventListenerAndRevokeUrl", "message", "src", "lineno", "colno", "error", "createEventTargetConstructor", "wrapEventListener", "_nativeEventTarget", "type", "listener", "options", "wrappedEventListener", "event", "createExposeCurrentFrameAndCurrentTime", "window", "currentTime", "sampleRate", "fn", "createFetchSource", "createAbortError", "url", "response", "DEFAULT_OPTIONS", "createGainNodeConstructor", "audioNodeConstructor", "createAudioParam", "createGainNodeRenderer", "createNativeGainNode", "getNativeContext", "isNativeOfflineAudioContext", "context", "options", "nativeContext", "mergedOptions", "nativeGainNode", "isOffline", "gainNodeRenderer", "MOST_POSITIVE_SINGLE_FLOAT", "MOST_NEGATIVE_SINGLE_FLOAT", "createGainNodeRendererFactory", "connectAudioParam", "createNativeGainNode", "getNativeAudioNode", "renderAutomation", "renderInputsOfAudioNode", "renderedNativeGainNodes", "createGainNode", "proxy", "nativeOfflineAudioContext", "nativeGainNode", "nativeGainNodeIsOwnedByContext", "isOwnedByContext", "options", "renderedNativeGainNode", "createGetActiveAudioWorkletNodeInputs", "activeAudioWorkletNodeInputsStore", "getValueForKey", "nativeAudioWorkletNode", "createGetAudioNodeRenderer", "getAudioNodeConnections", "audioNode", "audioNodeConnections", "createGetAudioNodeTailTime", "audioNodeTailTimeStore", "audioNode", "_a", "createGetAudioParamRenderer", "getAudioParamConnections", "audioParam", "audioParamConnections", "createGetBackupOfflineAudioContext", "backupOfflineAudioContextStore", "nativeContext", "createInvalidStateError", "createGetNativeContext", "contextStore", "context", "nativeContext", "createInvalidStateError", "createGetOrCreateBackupOfflineAudioContext", "backupOfflineAudioContextStore", "nativeOfflineAudioContextConstructor", "nativeContext", "backupOfflineAudioContext", "createGetUnrenderedAudioWorkletNodes", "unrenderedAudioWorkletNodeStore", "nativeContext", "unrenderedAudioWorkletNodes", "createInvalidAccessError", "wrapIIRFilterNodeGetFrequencyResponseMethod", "nativeIIRFilterNode", "getFrequencyResponse", "frequencyHz", "magResponse", "phaseResponse", "createInvalidAccessError", "DEFAULT_OPTIONS", "createIIRFilterNodeConstructor", "audioNodeConstructor", "createNativeIIRFilterNode", "createIIRFilterNodeRenderer", "getNativeContext", "isNativeOfflineAudioContext", "setAudioNodeTailTime", "context", "options", "nativeContext", "isOffline", "mergedOptions", "nativeIIRFilterNode", "iirFilterNodeRenderer", "wrapIIRFilterNodeGetFrequencyResponseMethod", "frequencyHz", "magResponse", "phaseResponse", "filterBuffer", "feedback", "feedbackLength", "feedforward", "feedforwardLength", "minLength", "xBuffer", "yBuffer", "bufferIndex", "bufferLength", "input", "output", "inputLength", "i", "j", "y", "k", "filterFullBuffer", "renderedBuffer", "nativeOfflineAudioContext", "feedback", "feedforward", "convertedFeedback", "convertedFeedforward", "feedbackLength", "feedforwardLength", "minLength", "i", "bufferLength", "xBuffer", "yBuffer", "filteredBuffer", "numberOfChannels", "input", "output", "filterBuffer", "createIIRFilterNodeRendererFactory", "createNativeAudioBufferSourceNode", "getNativeAudioNode", "nativeOfflineAudioContextConstructor", "renderInputsOfAudioNode", "renderNativeOfflineAudioContext", "renderedNativeAudioNodes", "filteredBufferPromise", "createAudioNode", "proxy", "nativeAudioBufferSourceNode", "nativeIIRFilterNode", "nativeIIRFilterNodeIsOwnedByContext", "isOwnedByContext", "partialOfflineAudioContext", "renderedNativeAudioNode", "createIncrementCycleCounterFactory", "cycleCounters", "disconnectNativeAudioNodeFromNativeAudioNode", "getAudioNodeConnections", "getNativeAudioNode", "getNativeAudioParam", "isActiveAudioNode", "isOffline", "audioNode", "count", "cycleCounter", "nativeSourceAudioNode", "outputs", "output", "isAudioNodeOutputConnection", "nativeDestinationAudioNode", "nativeDestinationAudioParam", "createIsAnyAudioContext", "contextStore", "isNativeAudioContext", "anything", "nativeContext", "createIsAnyAudioNode", "audioNodeStore", "isNativeAudioNode", "anything", "createIsAnyAudioParam", "audioParamStore", "isNativeAudioParam", "anything", "createIsAnyOfflineAudioContext", "contextStore", "isNativeOfflineAudioContext", "anything", "nativeContext", "createIsNativeAudioContext", "nativeAudioContextConstructor", "anything", "createIsNativeAudioNode", "window", "anything", "createIsNativeAudioParam", "window", "anything", "createIsNativeContext", "isNativeAudioContext", "isNativeOfflineAudioContext", "anything", "createIsNativeOfflineAudioContext", "nativeOfflineAudioContextConstructor", "anything", "createIsSecureContext", "window", "createMediaElementAudioSourceNodeConstructor", "audioNodeConstructor", "createNativeMediaElementAudioSourceNode", "getNativeContext", "isNativeOfflineAudioContext", "context", "options", "nativeContext", "nativeMediaElementAudioSourceNode", "DEFAULT_OPTIONS", "createMediaStreamAudioDestinationNodeConstructor", "audioNodeConstructor", "createNativeMediaStreamAudioDestinationNode", "getNativeContext", "isNativeOfflineAudioContext", "context", "options", "nativeContext", "mergedOptions", "nativeMediaStreamAudioDestinationNode", "createMediaStreamAudioSourceNodeConstructor", "audioNodeConstructor", "createNativeMediaStreamAudioSourceNode", "getNativeContext", "isNativeOfflineAudioContext", "context", "options", "nativeContext", "nativeMediaStreamAudioSourceNode", "createMediaStreamTrackAudioSourceNodeConstructor", "audioNodeConstructor", "createNativeMediaStreamTrackAudioSourceNode", "getNativeContext", "context", "options", "nativeContext", "nativeMediaStreamTrackAudioSourceNode", "createMinimalAudioContextConstructor", "createInvalidStateError", "createNotSupportedError", "createUnknownError", "minimalBaseAudioContextConstructor", "nativeAudioContextConstructor", "options", "nativeAudioContext", "err", "isValidLatencyHint", "latencyHint", "sampleRate", "revokeState", "deactivateAudioGraph", "resolve", "reject", "resolvePromise", "createMinimalBaseAudioContextConstructor", "audioDestinationNodeConstructor", "createAudioListener", "eventTargetConstructor", "isNativeOfflineAudioContext", "unrenderedAudioWorkletNodeStore", "wrapEventListener", "_nativeContext", "numberOfChannels", "CONTEXT_STORE", "value", "wrappedListener", "nativeOnStateChange", "testPromiseSupport", "nativeContext", "uint32Array", "promise", "DEFAULT_OPTIONS", "createMinimalOfflineAudioContextConstructor", "cacheTestResult", "createInvalidStateError", "createNativeOfflineAudioContext", "minimalBaseAudioContextConstructor", "startRendering", "options", "length", "numberOfChannels", "sampleRate", "nativeOfflineAudioContext", "testPromiseSupport", "i", "delayStateChangeEvent", "event", "deactivateAudioGraph", "createMonitorConnections", "insertElementInSet", "isNativeAudioNode", "nativeAudioNode", "whenConnected", "whenDisconnected", "connections", "connect", "destination", "output", "input", "wasDisconnected", "connection", "disconnect", "destinationOrOutput", "wasConnected", "isDisconnected", "assignNativeAudioNodeOption", "nativeAudioNode", "options", "option", "value", "assignNativeAudioNodeOptions", "nativeAudioNode", "options", "assignNativeAudioNodeOption", "testAnalyserNodeGetFloatTimeDomainDataMethodSupport", "nativeAnalyserNode", "wrapAnalyserNodeGetFloatTimeDomainDataMethod", "nativeAnalyserNode", "array", "byteTimeDomainData", "length", "i", "createNativeAnalyserNodeFactory", "cacheTestResult", "createIndexSizeError", "nativeContext", "options", "nativeAnalyserNode", "assignNativeAudioNodeOptions", "assignNativeAudioNodeOption", "testAnalyserNodeGetFloatTimeDomainDataMethodSupport", "wrapAnalyserNodeGetFloatTimeDomainDataMethod", "createNativeAudioBufferConstructor", "window", "assignNativeAudioNodeAudioParamValue", "nativeAudioNode", "options", "audioParam", "value", "wrapAudioBufferSourceNodeStartMethodConsecutiveCalls", "nativeAudioBufferSourceNode", "start", "isScheduled", "when", "offset", "duration", "createInvalidStateError", "wrapAudioScheduledSourceNodeStartMethodNegativeParameters", "nativeAudioScheduledSourceNode", "start", "when", "offset", "duration", "wrapAudioScheduledSourceNodeStopMethodNegativeParameters", "nativeAudioScheduledSourceNode", "stop", "when", "createNativeAudioBufferSourceNodeFactory", "addSilentConnection", "cacheTestResult", "testAudioBufferSourceNodeStartMethodConsecutiveCallsSupport", "testAudioBufferSourceNodeStartMethodOffsetClampingSupport", "testAudioBufferSourceNodeStopMethodNullifiedBufferSupport", "testAudioScheduledSourceNodeStartMethodNegativeParametersSupport", "testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport", "testAudioScheduledSourceNodeStopMethodNegativeParametersSupport", "wrapAudioBufferSourceNodeStartMethodOffsetClampling", "wrapAudioBufferSourceNodeStopMethodNullifiedBuffer", "wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls", "nativeContext", "options", "nativeAudioBufferSourceNode", "assignNativeAudioNodeOptions", "assignNativeAudioNodeAudioParamValue", "assignNativeAudioNodeOption", "wrapAudioBufferSourceNodeStartMethodConsecutiveCalls", "wrapAudioScheduledSourceNodeStartMethodNegativeParameters", "wrapAudioScheduledSourceNodeStopMethodNegativeParameters", "createNativeAudioContextConstructor", "window", "createNativeAudioDestinationNodeFactory", "createNativeGainNode", "overwriteAccessors", "nativeContext", "channelCount", "isNodeOfNativeOfflineAudioContext", "nativeAudioDestinationNode", "gainNode", "get", "set", "value", "err", "createNativeAudioWorkletNodeConstructor", "window", "testClonabilityOfAudioWorkletNodeOptions", "audioWorkletNodeOptions", "port1", "createNativeAudioWorkletNodeFactory", "createInvalidStateError", "createNativeAudioWorkletNodeFaker", "createNativeGainNode", "createNotSupportedError", "monitorConnections", "nativeContext", "baseLatency", "nativeAudioWorkletNodeConstructor", "name", "processorConstructor", "options", "nativeAudioWorkletNode", "patchedEventListeners", "onprocessorerror", "value", "addEventListener", "args", "unpatchedEventListener", "patchedEventListener", "event", "removeEventListener", "nativeGainNode", "err", "testClonabilityOfAudioWorkletNodeOptions", "computeBufferSize", "baseLatency", "sampleRate", "cloneAudioWorkletNodeOptions", "audioWorkletNodeOptions", "resolve", "reject", "port1", "port2", "data", "createAudioWorkletProcessorPromise", "processorConstructor", "audioWorkletNodeOptions", "clonedAudioWorkletNodeOptions", "cloneAudioWorkletNodeOptions", "createAudioWorkletProcessor", "nativeContext", "nativeAudioWorkletNode", "processorConstructor", "audioWorkletNodeOptions", "nodeToProcessorMap", "NODE_TO_PROCESSOR_MAPS", "audioWorkletProcessorPromise", "createAudioWorkletProcessorPromise", "createNativeAudioWorkletNodeFakerFactory", "connectMultipleOutputs", "createIndexSizeError", "createInvalidStateError", "createNativeChannelMergerNode", "createNativeChannelSplitterNode", "createNativeConstantSourceNode", "createNativeGainNode", "createNativeScriptProcessorNode", "createNotSupportedError", "disconnectMultipleOutputs", "exposeCurrentFrameAndCurrentTime", "getActiveAudioWorkletNodeInputs", "monitorConnections", "nativeContext", "baseLatency", "processorConstructor", "options", "outputChannelCount", "channelCount", "numberOfInputChannels", "numberOfOutputChannels", "sum", "value", "numberOfParameters", "messageChannel", "gainNodes", "inputChannelSplitterNodes", "i", "constantSourceNodes", "defaultValue", "maxValue", "minValue", "name", "constantSourceNode", "MOST_POSITIVE_SINGLE_FLOAT", "MOST_NEGATIVE_SINGLE_FLOAT", "inputChannelMergerNode", "bufferSize", "computeBufferSize", "scriptProcessorNode", "outputChannelSplitterNode", "outputChannelMergerNodes", "j", "parameterMap", "ReadOnlyMap", "index", "channelInterpretation", "onprocessorerror", "outputAudioNodes", "nativeAudioWorkletNodeFaker", "_", "gainNode", "args", "patchedEventListeners", "addEventListener", "unpatchedEventListener", "patchedEventListener", "event", "removeEventListener", "onmessage", "audioWorkletProcessor", "createAudioWorkletProcessor", "dWrkltPrcssr", "inputs", "createNestedArrays", "outputs", "parameters", "prmtrs", "isActive", "disconnectOutputsGraph", "outputChannelSplitterNodeOutput", "outputChannelMergerNode", "activeInputIndexes", "inputBuffer", "outputBuffer", "activeInputs", "k", "copyFromChannel", "potentiallyEmptyInputs", "input", "count", "channelData", "sample", "copyToChannel", "error", "length", "isConnected", "disconnectFakeGraph", "nativeGainNode", "connectFakeGraph", "whenConnected", "whenDisconnected", "createNativeBiquadFilterNode", "nativeContext", "options", "nativeBiquadFilterNode", "assignNativeAudioNodeOptions", "assignNativeAudioNodeAudioParamValue", "assignNativeAudioNodeOption", "createNativeChannelMergerNodeFactory", "nativeAudioContextConstructor", "wrapChannelMergerNode", "nativeContext", "options", "nativeChannelMergerNode", "assignNativeAudioNodeOptions", "wrapChannelSplitterNode", "channelSplitterNode", "channelCount", "value", "createInvalidStateError", "createNativeChannelSplitterNode", "nativeContext", "options", "nativeChannelSplitterNode", "assignNativeAudioNodeOptions", "wrapChannelSplitterNode", "createNativeConstantSourceNodeFactory", "addSilentConnection", "cacheTestResult", "createNativeConstantSourceNodeFaker", "testAudioScheduledSourceNodeStartMethodNegativeParametersSupport", "testAudioScheduledSourceNodeStopMethodNegativeParametersSupport", "nativeContext", "options", "nativeConstantSourceNode", "assignNativeAudioNodeOptions", "assignNativeAudioNodeAudioParamValue", "wrapAudioScheduledSourceNodeStartMethodNegativeParameters", "wrapAudioScheduledSourceNodeStopMethodNegativeParameters", "interceptConnections", "original", "interceptor", "createNativeConstantSourceNodeFakerFactory", "addSilentConnection", "createNativeAudioBufferSourceNode", "createNativeGainNode", "monitorConnections", "nativeContext", "offset", "audioNodeOptions", "audioBuffer", "audioBufferSourceNode", "gainNode", "channelData", "nativeConstantSourceNodeFaker", "value", "args", "when", "whenConnected", "whenDisconnected", "interceptConnections", "createNativeConvolverNodeFactory", "createNotSupportedError", "overwriteAccessors", "nativeContext", "options", "nativeConvolverNode", "assignNativeAudioNodeOptions", "assignNativeAudioNodeOption", "get", "set", "value", "createNativeDelayNode", "nativeContext", "options", "nativeDelayNode", "assignNativeAudioNodeOptions", "assignNativeAudioNodeAudioParamValue", "createNativeDynamicsCompressorNodeFactory", "createNotSupportedError", "nativeContext", "options", "nativeDynamicsCompressorNode", "assignNativeAudioNodeOptions", "assignNativeAudioNodeAudioParamValue", "createNativeGainNode", "nativeContext", "options", "nativeGainNode", "assignNativeAudioNodeOptions", "assignNativeAudioNodeAudioParamValue", "createNativeIIRFilterNodeFactory", "createNativeIIRFilterNodeFaker", "nativeContext", "baseLatency", "options", "nativeIIRFilterNode", "assignNativeAudioNodeOptions", "divide", "a", "b", "denominator", "multiply", "evaluatePolynomial", "coefficient", "z", "result", "i", "createNativeIIRFilterNodeFakerFactory", "createInvalidAccessError", "createInvalidStateError", "createNativeScriptProcessorNode", "createNotSupportedError", "nativeContext", "baseLatency", "channelCount", "channelCountMode", "channelInterpretation", "feedback", "feedforward", "bufferSize", "computeBufferSize", "convertedFeedback", "convertedFeedforward", "feedbackLength", "feedforwardLength", "minLength", "scriptProcessorNode", "bufferLength", "bufferIndexes", "xBuffers", "yBuffers", "xBuffer", "yBuffer", "event", "inputBuffer", "outputBuffer", "numberOfChannels", "input", "output", "filterBuffer", "nyquist", "interceptConnections", "value", "args", "frequencyHz", "magResponse", "phaseResponse", "length", "omega", "numerator", "response", "createNativeMediaElementAudioSourceNode", "nativeAudioContext", "options", "createNativeMediaStreamAudioDestinationNode", "nativeAudioContext", "options", "nativeMediaStreamAudioDestinationNode", "assignNativeAudioNodeOptions", "createNativeMediaStreamAudioSourceNode", "nativeAudioContext", "mediaStream", "audioStreamTracks", "a", "b", "filteredAudioStreamTracks", "nativeMediaStreamAudioSourceNode", "createNativeMediaStreamTrackAudioSourceNodeFactory", "createInvalidStateError", "isNativeOfflineAudioContext", "nativeAudioContext", "mediaStreamTrack", "mediaStream", "nativeMediaStreamAudioSourceNode", "createNativeOfflineAudioContextConstructor", "window", "createNativeOscillatorNodeFactory", "addSilentConnection", "cacheTestResult", "testAudioScheduledSourceNodeStartMethodNegativeParametersSupport", "testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport", "testAudioScheduledSourceNodeStopMethodNegativeParametersSupport", "wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls", "nativeContext", "options", "nativeOscillatorNode", "assignNativeAudioNodeOptions", "assignNativeAudioNodeAudioParamValue", "assignNativeAudioNodeOption", "wrapAudioScheduledSourceNodeStartMethodNegativeParameters", "wrapAudioScheduledSourceNodeStopMethodNegativeParameters", "createNativePannerNodeFactory", "createNativePannerNodeFaker", "nativeContext", "options", "nativePannerNode", "assignNativeAudioNodeOptions", "assignNativeAudioNodeAudioParamValue", "assignNativeAudioNodeOption", "createNativePannerNodeFakerFactory", "connectNativeAudioNodeToNativeAudioNode", "createInvalidStateError", "createNativeChannelMergerNode", "createNativeGainNode", "createNativeScriptProcessorNode", "createNativeWaveShaperNode", "createNotSupportedError", "disconnectNativeAudioNodeFromNativeAudioNode", "getFirstSample", "monitorConnections", "nativeContext", "coneInnerAngle", "coneOuterAngle", "coneOuterGain", "distanceModel", "maxDistance", "orientationX", "orientationY", "orientationZ", "panningModel", "positionX", "positionY", "positionZ", "refDistance", "rolloffFactor", "audioNodeOptions", "pannerNode", "assignNativeAudioNodeOptions", "SINGLE_CHANNEL_OPTIONS", "channelMergerNode", "inputGainNode", "orientationXGainNode", "orientationYGainNode", "orientationZGainNode", "positionXGainNode", "positionYGainNode", "positionZGainNode", "scriptProcessorNode", "waveShaperNode", "lastOrientation", "lastPosition", "buffer", "inputBuffer", "orientation", "value", "index", "positon", "nativePannerNodeFaker", "args", "whenConnected", "whenDisconnected", "interceptConnections", "createNativePeriodicWaveFactory", "createIndexSizeError", "nativeContext", "disableNormalization", "imag", "real", "convertedImag", "convertedReal", "nativePeriodicWave", "createNativeScriptProcessorNode", "nativeContext", "bufferSize", "numberOfInputChannels", "numberOfOutputChannels", "createNativeStereoPannerNodeFactory", "createNativeStereoPannerNodeFaker", "createNotSupportedError", "nativeContext", "options", "channelCountMode", "nativeStereoPannerNode", "assignNativeAudioNodeOptions", "assignNativeAudioNodeAudioParamValue", "value", "createNativeStereoPannerNodeFakerFactory", "createNativeChannelMergerNode", "createNativeChannelSplitterNode", "createNativeGainNode", "createNativeWaveShaperNode", "createNotSupportedError", "monitorConnections", "DC_CURVE", "HALF_PI", "SINGLE_CHANNEL_OPTIONS", "SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS", "buildInternalGraphForMono", "nativeContext", "inputGainNode", "panGainNode", "channelMergerNode", "leftWaveShaperCurve", "rightWaveShaperCurve", "i", "x", "leftGainNode", "leftWaveShaperNode", "panWaveShaperNode", "rightGainNode", "rightWaveShaperNode", "buildInternalGraphForStereo", "leftInputForLeftOutputWaveShaperCurve", "leftInputForRightOutputWaveShaperCurve", "rightInputForLeftOutputWaveShaperCurve", "rightInputForRightOutputWaveShaperCurve", "centerIndex", "channelSplitterNode", "leftInputForLeftOutputGainNode", "leftInputForLeftOutputWaveShaperNode", "leftInputForRightOutputGainNode", "leftInputForRightOutputWaveShaperNode", "rightInputForLeftOutputGainNode", "rightInputForLeftOutputWaveShaperNode", "rightInputForRightOutputGainNode", "rightInputForRightOutputWaveShaperNode", "buildInternalGraph", "channelCount", "channelCountMode", "pan", "audioNodeOptions", "connectGraph", "disconnectGraph", "nativeStereoPannerNodeFakerFactory", "value", "isConnected", "args", "whenConnected", "whenDisconnected", "interceptConnections", "createNativeWaveShaperNodeFactory", "createConnectedNativeAudioBufferSourceNode", "createInvalidStateError", "createNativeWaveShaperNodeFaker", "isDCCurve", "monitorConnections", "nativeAudioContextConstructor", "overwriteAccessors", "nativeContext", "options", "nativeWaveShaperNode", "assignNativeAudioNodeOptions", "curve", "assignNativeAudioNodeOption", "disconnectNativeAudioBufferSourceNode", "isConnected", "get", "set", "value", "createNativeWaveShaperNodeFakerFactory", "createConnectedNativeAudioBufferSourceNode", "createInvalidStateError", "createNativeGainNode", "isDCCurve", "monitorConnections", "nativeContext", "curve", "oversample", "audioNodeOptions", "negativeWaveShaperNode", "positiveWaveShaperNode", "assignNativeAudioNodeOptions", "inputGainNode", "invertGainNode", "outputGainNode", "revertGainNode", "disconnectNativeAudioBufferSourceNode", "isConnected", "unmodifiedCurve", "nativeWaveShaperNodeFaker", "value", "curveLength", "negativeCurve", "positiveCurve", "length", "centerIndex", "i", "theoreticIndex", "lowerIndex", "upperIndex", "args", "whenConnected", "whenDisconnected", "interceptConnections", "createNotSupportedError", "DEFAULT_OPTIONS", "createOfflineAudioContextConstructor", "baseAudioContextConstructor", "cacheTestResult", "createInvalidStateError", "createNativeOfflineAudioContext", "startRendering", "a", "b", "c", "options", "length", "numberOfChannels", "sampleRate", "nativeOfflineAudioContext", "testPromiseSupport", "i", "delayStateChangeEvent", "event", "deactivateAudioGraph", "DEFAULT_OPTIONS", "createOscillatorNodeConstructor", "audioNodeConstructor", "createAudioParam", "createNativeOscillatorNode", "createOscillatorNodeRenderer", "getNativeContext", "isNativeOfflineAudioContext", "wrapEventListener", "context", "options", "nativeContext", "mergedOptions", "nativeOscillatorNode", "isOffline", "oscillatorNodeRenderer", "nyquist", "value", "wrappedListener", "nativeOnEnded", "periodicWave", "when", "setInternalStateToActive", "resetInternalStateToPassive", "isActiveAudioNode", "setInternalStateToPassive", "createOscillatorNodeRendererFactory", "connectAudioParam", "createNativeOscillatorNode", "getNativeAudioNode", "renderAutomation", "renderInputsOfAudioNode", "renderedNativeOscillatorNodes", "periodicWave", "start", "stop", "createOscillatorNode", "proxy", "nativeOfflineAudioContext", "nativeOscillatorNode", "nativeOscillatorNodeIsOwnedByContext", "isOwnedByContext", "options", "value", "renderedNativeOscillatorNode", "DEFAULT_OPTIONS", "createPannerNodeConstructor", "audioNodeConstructor", "createAudioParam", "createNativePannerNode", "createPannerNodeRenderer", "getNativeContext", "isNativeOfflineAudioContext", "setAudioNodeTailTime", "context", "options", "nativeContext", "mergedOptions", "nativePannerNode", "isOffline", "pannerNodeRenderer", "MOST_POSITIVE_SINGLE_FLOAT", "MOST_NEGATIVE_SINGLE_FLOAT", "value", "createPannerNodeRendererFactory", "connectAudioParam", "createNativeChannelMergerNode", "createNativeConstantSourceNode", "createNativeGainNode", "createNativePannerNode", "getNativeAudioNode", "nativeOfflineAudioContextConstructor", "renderAutomation", "renderInputsOfAudioNode", "renderNativeOfflineAudioContext", "renderedNativeAudioNodes", "renderedBufferPromise", "createAudioNode", "proxy", "nativeOfflineAudioContext", "nativeGainNode", "nativePannerNode", "commonAudioNodeOptions", "commonNativePannerNodeOptions", "nativePannerNodeIsOwnedByContext", "isOwnedByContext", "options", "partialOfflineAudioContext", "nativeChannelMergerNode", "nativeConstantSourceNodes", "audioParam", "index", "nativeConstantSourceNode", "i", "renderedBuffer", "inputGainNode", "channelDatas", "lastOrientation", "lastPosition", "gateGainNode", "partialPannerNode", "orientation", "positon", "value", "currentTime", "isNativeAudioNodeFaker", "renderedNativeGainNodeOrNativePannerNode", "DEFAULT_OPTIONS", "createPeriodicWaveConstructor", "createNativePeriodicWave", "getNativeContext", "periodicWaveStore", "sanitizePeriodicWaveOptions", "PeriodicWave", "context", "options", "nativeContext", "mergedOptions", "periodicWave", "instance", "createRenderAutomation", "getAudioParamRenderer", "renderInputsOfAudioParam", "nativeOfflineAudioContext", "audioParam", "nativeAudioParam", "createRenderInputsOfAudioNode", "getAudioNodeConnections", "getAudioNodeRenderer", "isPartOfACycle", "audioNode", "nativeOfflineAudioContext", "nativeAudioNode", "audioNodeConnections", "connections", "input", "source", "output", "renderedNativeAudioNode", "destination", "allRenderingPromises", "renderingPromises", "createRenderInputsOfAudioParam", "getAudioNodeRenderer", "getAudioParamConnections", "isPartOfACycle", "audioParam", "nativeOfflineAudioContext", "nativeAudioParam", "audioParamConnections", "source", "output", "renderedNativeAudioNode", "createRenderNativeOfflineAudioContext", "cacheTestResult", "createNativeGainNode", "createNativeScriptProcessorNode", "testOfflineAudioContextCurrentTimeSupport", "nativeOfflineAudioContext", "testPromiseSupport", "isOfflineAudioContextCurrentTimeSupported", "scriptProcessorNode", "resolve", "gainNode", "event", "createSetActiveAudioWorkletNodeInputs", "activeAudioWorkletNodeInputsStore", "nativeAudioWorkletNode", "activeInputs", "createSetAudioNodeTailTime", "audioNodeTailTimeStore", "audioNode", "tailTime", "createStartRendering", "audioBufferStore", "cacheTestResult", "getAudioNodeRenderer", "getUnrenderedAudioWorkletNodes", "renderNativeOfflineAudioContext", "testAudioBufferCopyChannelMethodsOutOfBoundsSupport", "wrapAudioBufferCopyChannelMethods", "wrapAudioBufferCopyChannelMethodsOutOfBounds", "destination", "nativeOfflineAudioContext", "audioWorkletNode", "audioBuffer", "wrapAudioBufferGetChannelDataMethod", "DEFAULT_OPTIONS", "createStereoPannerNodeConstructor", "audioNodeConstructor", "createAudioParam", "createNativeStereoPannerNode", "createStereoPannerNodeRenderer", "getNativeContext", "isNativeOfflineAudioContext", "context", "options", "nativeContext", "mergedOptions", "nativeStereoPannerNode", "isOffline", "stereoPannerNodeRenderer", "createStereoPannerNodeRendererFactory", "connectAudioParam", "createNativeStereoPannerNode", "getNativeAudioNode", "renderAutomation", "renderInputsOfAudioNode", "renderedNativeStereoPannerNodes", "createStereoPannerNode", "proxy", "nativeOfflineAudioContext", "nativeStereoPannerNode", "nativeStereoPannerNodeIsOwnedByContext", "isOwnedByContext", "options", "isNativeAudioNodeFaker", "renderedNativeStereoPannerNode", "createTestAudioBufferConstructorSupport", "nativeAudioBufferConstructor", "createTestAudioWorkletProcessorPostMessageSupport", "nativeAudioWorkletNodeConstructor", "nativeOfflineAudioContextConstructor", "blob", "offlineAudioContext", "url", "isEmittingMessageEvents", "isEmittingProcessorErrorEvents", "audioWorkletNode", "oscillator", "resolve", "createTestOfflineAudioContextCurrentTimeSupport", "createNativeGainNode", "nativeOfflineAudioContextConstructor", "nativeOfflineAudioContext", "gainNode", "resolve", "createUnknownError", "DEFAULT_OPTIONS", "createWaveShaperNodeConstructor", "audioNodeConstructor", "createInvalidStateError", "createNativeWaveShaperNode", "createWaveShaperNodeRenderer", "getNativeContext", "isNativeOfflineAudioContext", "setAudioNodeTailTime", "context", "options", "nativeContext", "mergedOptions", "nativeWaveShaperNode", "waveShaperNodeRenderer", "value", "createWaveShaperNodeRendererFactory", "createNativeWaveShaperNode", "getNativeAudioNode", "renderInputsOfAudioNode", "renderedNativeWaveShaperNodes", "createWaveShaperNode", "proxy", "nativeOfflineAudioContext", "nativeWaveShaperNode", "isOwnedByContext", "options", "isNativeAudioNodeFaker", "renderedNativeWaveShaperNode", "createWindow", "createWrapAudioBufferCopyChannelMethods", "convertNumberToUnsignedLong", "createIndexSizeError", "audioBuffer", "destination", "channelNumberAsNumber", "bufferOffsetAsNumber", "bufferOffset", "channelNumber", "audioBufferLength", "channelData", "destinationLength", "i", "source", "sourceLength", "createWrapAudioBufferCopyChannelMethodsOutOfBounds", "convertNumberToUnsignedLong", "audioBuffer", "copyFromChannel", "destination", "channelNumberAsNumber", "bufferOffsetAsNumber", "bufferOffset", "channelNumber", "copyToChannel", "source", "createWrapAudioBufferSourceNodeStopMethodNullifiedBuffer", "overwriteAccessors", "nativeAudioBufferSourceNode", "nativeContext", "nullifiedBuffer", "get", "value", "set", "createWrapChannelMergerNode", "createInvalidStateError", "monitorConnections", "nativeContext", "channelMergerNode", "audioBufferSourceNode", "length", "i", "getFirstSample", "audioBuffer", "buffer", "channelNumber", "isDCCurve", "curve", "length", "overwriteAccessors", "object", "property", "createGetter", "createSetter", "prototype", "get", "set", "sanitizeAudioWorkletNodeOptions", "options", "sanitizeChannelSplitterOptions", "options", "sanitizePeriodicWaveOptions", "options", "imag", "real", "setValueAtTimeUntilPossible", "audioParam", "value", "startTime", "err", "testAudioBufferSourceNodeStartMethodConsecutiveCallsSupport", "nativeContext", "nativeAudioBufferSourceNode", "testAudioBufferSourceNodeStartMethodOffsetClampingSupport", "nativeContext", "nativeAudioBufferSourceNode", "nativeAudioBuffer", "testAudioBufferSourceNodeStopMethodNullifiedBufferSupport", "nativeContext", "nativeAudioBufferSourceNode", "testAudioScheduledSourceNodeStartMethodNegativeParametersSupport", "nativeContext", "nativeAudioBufferSourceNode", "err", "testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport", "nativeContext", "nativeAudioBuffer", "nativeAudioBufferSourceNode", "testAudioScheduledSourceNodeStopMethodNegativeParametersSupport", "nativeContext", "nativeAudioBufferSourceNode", "err", "testAudioWorkletNodeOptionsClonability", "audioWorkletNodeOptions", "port1", "port2", "wrapAudioBufferSourceNodeStartMethodOffsetClamping", "nativeAudioBufferSourceNode", "start", "when", "offset", "duration", "buffer", "clampedOffset", "wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls", "nativeAudioScheduledSourceNode", "nativeContext", "nativeGainNode", "disconnectGainNode", "disconnect", "interceptConnections", "stop", "isStopped", "when", "wrapEventListener", "target", "eventListener", "event", "descriptor", "addActiveInputConnectionToAudioNode", "createAddActiveInputConnectionToAudioNode", "insertElementInSet", "addPassiveInputConnectionToAudioNode", "createAddPassiveInputConnectionToAudioNode", "deleteActiveInputConnectionToAudioNode", "createDeleteActiveInputConnectionToAudioNode", "pickElementFromSet", "audioNodeTailTimeStore", "getAudioNodeTailTime", "createGetAudioNodeTailTime", "cacheTestResult", "createCacheTestResult", "window", "createWindow", "createNativeAnalyserNode", "createNativeAnalyserNodeFactory", "createIndexSizeError", "getAudioNodeRenderer", "createGetAudioNodeRenderer", "getAudioNodeConnections", "renderInputsOfAudioNode", "createRenderInputsOfAudioNode", "isPartOfACycle", "createAnalyserNodeRenderer", "createAnalyserNodeRendererFactory", "getNativeAudioNode", "getNativeContext", "createGetNativeContext", "CONTEXT_STORE", "nativeOfflineAudioContextConstructor", "createNativeOfflineAudioContextConstructor", "isNativeOfflineAudioContext", "createIsNativeOfflineAudioContext", "audioParamAudioNodeStore", "eventTargetConstructor", "createEventTargetConstructor", "wrapEventListener", "nativeAudioContextConstructor", "createNativeAudioContextConstructor", "isNativeAudioContext", "createIsNativeAudioContext", "isNativeAudioNode", "createIsNativeAudioNode", "isNativeAudioParam", "createIsNativeAudioParam", "nativeAudioWorkletNodeConstructor", "createNativeAudioWorkletNodeConstructor", "audioNodeConstructor", "createAudioNodeConstructor", "createAddAudioNodeConnections", "AUDIO_NODE_CONNECTIONS_STORE", "createAddConnectionToAudioNode", "connectNativeAudioNodeToNativeAudioNode", "disconnectNativeAudioNodeFromNativeAudioNode", "getEventListenersOfAudioNode", "isActiveAudioNode", "isPassiveAudioNode", "createIncrementCycleCounterFactory", "CYCLE_COUNTERS", "getNativeAudioParam", "createInvalidAccessError", "createNotSupportedError", "createDecrementCycleCounter", "createDetectCycles", "getValueForKey", "analyserNodeConstructor", "createAnalyserNodeConstructor", "audioBufferStore", "nativeAudioBufferConstructor", "createNativeAudioBufferConstructor", "window", "convertNumberToUnsignedLong", "createConvertNumberToUnsignedLong", "wrapAudioBufferCopyChannelMethods", "createWrapAudioBufferCopyChannelMethods", "createIndexSizeError", "wrapAudioBufferCopyChannelMethodsOutOfBounds", "createWrapAudioBufferCopyChannelMethodsOutOfBounds", "audioBufferConstructor", "createAudioBufferConstructor", "cacheTestResult", "createNotSupportedError", "nativeOfflineAudioContextConstructor", "createTestAudioBufferConstructorSupport", "addSilentConnection", "createAddSilentConnection", "createNativeGainNode", "renderInputsOfAudioParam", "createRenderInputsOfAudioParam", "getAudioNodeRenderer", "getAudioParamConnections", "isPartOfACycle", "connectAudioParam", "createConnectAudioParam", "createNativeAudioBufferSourceNode", "createNativeAudioBufferSourceNodeFactory", "cacheTestResult", "testAudioBufferSourceNodeStartMethodConsecutiveCallsSupport", "testAudioBufferSourceNodeStartMethodOffsetClampingSupport", "testAudioBufferSourceNodeStopMethodNullifiedBufferSupport", "testAudioScheduledSourceNodeStartMethodNegativeParametersSupport", "testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport", "testAudioScheduledSourceNodeStopMethodNegativeParametersSupport", "wrapAudioBufferSourceNodeStartMethodOffsetClamping", "createWrapAudioBufferSourceNodeStopMethodNullifiedBuffer", "overwriteAccessors", "wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls", "renderAutomation", "createRenderAutomation", "createGetAudioParamRenderer", "createAudioBufferSourceNodeRenderer", "createAudioBufferSourceNodeRendererFactory", "getNativeAudioNode", "renderInputsOfAudioNode", "createAudioParam", "createAudioParamFactory", "createAddAudioParamConnections", "AUDIO_PARAM_CONNECTIONS_STORE", "audioParamAudioNodeStore", "AUDIO_PARAM_STORE", "createAudioParamRenderer", "nativeAudioContextConstructor", "setValueAtTimeUntilPossible", "audioBufferSourceNodeConstructor", "createAudioBufferSourceNodeConstructor", "audioNodeConstructor", "createInvalidStateError", "getNativeContext", "isNativeOfflineAudioContext", "wrapEventListener", "audioDestinationNodeConstructor", "createAudioDestinationNodeConstructor", "audioNodeConstructor", "createAudioDestinationNodeRenderer", "createIndexSizeError", "createInvalidStateError", "createNativeAudioDestinationNodeFactory", "createNativeGainNode", "overwriteAccessors", "getNativeContext", "isNativeOfflineAudioContext", "renderInputsOfAudioNode", "createBiquadFilterNodeRenderer", "createBiquadFilterNodeRendererFactory", "connectAudioParam", "createNativeBiquadFilterNode", "getNativeAudioNode", "renderAutomation", "setAudioNodeTailTime", "createSetAudioNodeTailTime", "audioNodeTailTimeStore", "biquadFilterNodeConstructor", "createBiquadFilterNodeConstructor", "createAudioParam", "createInvalidAccessError", "monitorConnections", "createMonitorConnections", "insertElementInSet", "isNativeAudioNode", "wrapChannelMergerNode", "createWrapChannelMergerNode", "createNativeChannelMergerNode", "createNativeChannelMergerNodeFactory", "nativeAudioContextConstructor", "createChannelMergerNodeRenderer", "createChannelMergerNodeRendererFactory", "channelMergerNodeConstructor", "createChannelMergerNodeConstructor", "createChannelSplitterNodeRenderer", "createChannelSplitterNodeRendererFactory", "createNativeChannelSplitterNode", "channelSplitterNodeConstructor", "createChannelSplitterNodeConstructor", "sanitizeChannelSplitterOptions", "createNativeConstantSourceNodeFaker", "createNativeConstantSourceNodeFakerFactory", "addSilentConnection", "createNativeAudioBufferSourceNode", "createNativeConstantSourceNode", "createNativeConstantSourceNodeFactory", "cacheTestResult", "testAudioScheduledSourceNodeStartMethodNegativeParametersSupport", "testAudioScheduledSourceNodeStopMethodNegativeParametersSupport", "createConstantSourceNodeRenderer", "createConstantSourceNodeRendererFactory", "constantSourceNodeConstructor", "createConstantSourceNodeConstructor", "wrapEventListener", "createNativeConvolverNode", "createNativeConvolverNodeFactory", "createNotSupportedError", "createConvolverNodeRenderer", "createConvolverNodeRendererFactory", "convolverNodeConstructor", "createConvolverNodeConstructor", "createDelayNodeRenderer", "createDelayNodeRendererFactory", "createNativeDelayNode", "delayNodeConstructor", "createDelayNodeConstructor", "createNativeDynamicsCompressorNode", "createNativeDynamicsCompressorNodeFactory", "createDynamicsCompressorNodeRenderer", "createDynamicsCompressorNodeRendererFactory", "dynamicsCompressorNodeConstructor", "createDynamicsCompressorNodeConstructor", "createGainNodeRenderer", "createGainNodeRendererFactory", "gainNodeConstructor", "createGainNodeConstructor", "createNativeIIRFilterNodeFaker", "createNativeIIRFilterNodeFakerFactory", "createNativeScriptProcessorNode", "renderNativeOfflineAudioContext", "createRenderNativeOfflineAudioContext", "createTestOfflineAudioContextCurrentTimeSupport", "nativeOfflineAudioContextConstructor", "createIIRFilterNodeRenderer", "createIIRFilterNodeRendererFactory", "createNativeIIRFilterNode", "createNativeIIRFilterNodeFactory", "iIRFilterNodeConstructor", "createIIRFilterNodeConstructor", "createAudioListener", "createAudioListenerFactory", "getFirstSample", "unrenderedAudioWorkletNodeStore", "minimalBaseAudioContextConstructor", "createMinimalBaseAudioContextConstructor", "eventTargetConstructor", "createNativeOscillatorNode", "createNativeOscillatorNodeFactory", "testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport", "wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls", "createOscillatorNodeRenderer", "createOscillatorNodeRendererFactory", "oscillatorNodeConstructor", "createOscillatorNodeConstructor", "createConnectedNativeAudioBufferSourceNode", "createConnectedNativeAudioBufferSourceNodeFactory", "createNativeWaveShaperNodeFaker", "createNativeWaveShaperNodeFakerFactory", "isDCCurve", "createNativeWaveShaperNode", "createNativeWaveShaperNodeFactory", "createNativePannerNodeFaker", "createNativePannerNodeFakerFactory", "connectNativeAudioNodeToNativeAudioNode", "disconnectNativeAudioNodeFromNativeAudioNode", "createNativePannerNode", "createNativePannerNodeFactory", "createPannerNodeRenderer", "createPannerNodeRendererFactory", "pannerNodeConstructor", "createPannerNodeConstructor", "createNativePeriodicWave", "createNativePeriodicWaveFactory", "periodicWaveConstructor", "createPeriodicWaveConstructor", "sanitizePeriodicWaveOptions", "nativeStereoPannerNodeFakerFactory", "createNativeStereoPannerNodeFakerFactory", "createNativeStereoPannerNode", "createNativeStereoPannerNodeFactory", "createStereoPannerNodeRenderer", "createStereoPannerNodeRendererFactory", "stereoPannerNodeConstructor", "createStereoPannerNodeConstructor", "createWaveShaperNodeRenderer", "createWaveShaperNodeRendererFactory", "waveShaperNodeConstructor", "createWaveShaperNodeConstructor", "isSecureContext", "createIsSecureContext", "window", "exposeCurrentFrameAndCurrentTime", "createExposeCurrentFrameAndCurrentTime", "backupOfflineAudioContextStore", "getOrCreateBackupOfflineAudioContext", "createGetOrCreateBackupOfflineAudioContext", "addAudioWorkletModule", "createAddAudioWorkletModule", "createEvaluateSource", "createFetchSource", "createAbortError", "nativeAudioWorkletNodeConstructor", "createTestAudioWorkletProcessorPostMessageSupport", "isNativeContext", "createIsNativeContext", "isNativeAudioContext", "decodeAudioData", "createDecodeAudioData", "audioBufferStore", "createDataCloneError", "createEncodingError", "testAudioBufferCopyChannelMethodsOutOfBoundsSupport", "testPromiseSupport", "wrapAudioBufferCopyChannelMethods", "wrapAudioBufferCopyChannelMethodsOutOfBounds", "baseAudioContextConstructor", "createBaseAudioContextConstructor", "analyserNodeConstructor", "audioBufferConstructor", "audioBufferSourceNodeConstructor", "mediaElementAudioSourceNodeConstructor", "createMediaElementAudioSourceNodeConstructor", "createNativeMediaElementAudioSourceNode", "mediaStreamAudioDestinationNodeConstructor", "createMediaStreamAudioDestinationNodeConstructor", "createNativeMediaStreamAudioDestinationNode", "mediaStreamAudioSourceNodeConstructor", "createMediaStreamAudioSourceNodeConstructor", "createNativeMediaStreamAudioSourceNode", "createNativeMediaStreamTrackAudioSourceNode", "createNativeMediaStreamTrackAudioSourceNodeFactory", "mediaStreamTrackAudioSourceNodeConstructor", "createMediaStreamTrackAudioSourceNodeConstructor", "audioContextConstructor", "createAudioContextConstructor", "createUnknownError", "getUnrenderedAudioWorkletNodes", "createGetUnrenderedAudioWorkletNodes", "unrenderedAudioWorkletNodeStore", "addUnrenderedAudioWorkletNode", "createAddUnrenderedAudioWorkletNode", "connectMultipleOutputs", "createConnectMultipleOutputs", "createIndexSizeError", "deleteUnrenderedAudioWorkletNode", "createDeleteUnrenderedAudioWorkletNode", "disconnectMultipleOutputs", "createDisconnectMultipleOutputs", "activeAudioWorkletNodeInputsStore", "getActiveAudioWorkletNodeInputs", "createGetActiveAudioWorkletNodeInputs", "getValueForKey", "createNativeAudioWorkletNodeFaker", "createNativeAudioWorkletNodeFakerFactory", "createInvalidStateError", "createNativeChannelMergerNode", "createNativeChannelSplitterNode", "createNativeConstantSourceNode", "createNativeGainNode", "createNativeScriptProcessorNode", "createNotSupportedError", "exposeCurrentFrameAndCurrentTime", "monitorConnections", "createNativeAudioWorkletNode", "createNativeAudioWorkletNodeFactory", "createAudioWorkletNodeRenderer", "createAudioWorkletNodeRendererFactory", "connectAudioParam", "createNativeAudioBufferSourceNode", "getNativeAudioNode", "nativeAudioWorkletNodeConstructor", "nativeOfflineAudioContextConstructor", "renderAutomation", "renderInputsOfAudioNode", "renderNativeOfflineAudioContext", "getBackupOfflineAudioContext", "createGetBackupOfflineAudioContext", "backupOfflineAudioContextStore", "setActiveAudioWorkletNodeInputs", "createSetActiveAudioWorkletNodeInputs", "audioWorkletNodeConstructor", "isSecureContext", "createAudioWorkletNodeConstructor", "audioNodeConstructor", "createAudioParam", "getAudioNodeConnections", "getNativeContext", "isNativeOfflineAudioContext", "sanitizeAudioWorkletNodeOptions", "testAudioWorkletNodeOptionsClonability", "wrapEventListener", "minimalAudioContextConstructor", "createMinimalAudioContextConstructor", "createInvalidStateError", "createNotSupportedError", "createUnknownError", "minimalBaseAudioContextConstructor", "nativeAudioContextConstructor", "createNativeOfflineAudioContext", "createCreateNativeOfflineAudioContext", "createNotSupportedError", "nativeOfflineAudioContextConstructor", "startRendering", "createStartRendering", "audioBufferStore", "cacheTestResult", "getAudioNodeRenderer", "getUnrenderedAudioWorkletNodes", "renderNativeOfflineAudioContext", "testAudioBufferCopyChannelMethodsOutOfBoundsSupport", "wrapAudioBufferCopyChannelMethods", "wrapAudioBufferCopyChannelMethodsOutOfBounds", "minimalOfflineAudioContextConstructor", "createMinimalOfflineAudioContextConstructor", "createInvalidStateError", "minimalBaseAudioContextConstructor", "offlineAudioContextConstructor", "createOfflineAudioContextConstructor", "baseAudioContextConstructor", "cacheTestResult", "createInvalidStateError", "createNativeOfflineAudioContext", "startRendering", "isAnyAudioContext", "createIsAnyAudioContext", "CONTEXT_STORE", "isNativeAudioContext", "isAnyAudioNode", "createIsAnyAudioNode", "AUDIO_NODE_STORE", "isNativeAudioNode", "isAnyAudioParam", "createIsAnyAudioParam", "AUDIO_PARAM_STORE", "isNativeAudioParam", "isAnyOfflineAudioContext", "createIsAnyOfflineAudioContext", "isNativeOfflineAudioContext", "render", "audioBuffer", "offset", "duration", "offlineAudioContext", "offlineAudioContextConstructor", "biquadFilter", "bufferSourceNode", "renderedBuffer", "channelData", "sampleRate", "load", "url", "worker", "ongoingRecordingRequests", "args", "audioBuffer", "offsetOrTempoSettings", "durationOrTempoSettings", "offset", "duration", "tempoSettings", "_a", "resolve", "reject", "channelData", "sampleRate", "render", "id", "onMessage", "data", "createLoadOrReturnBroker", "loadBroker", "worker", "broker", "blob", "url", "worker", "loadOrReturnBroker", "createLoadOrReturnBroker", "load", "worker", "guess", "args", "loadOrReturnBroker", "TabRecorder", "__publicField", "stream", "event", "error", "blob", "url", "a", "TabClipper", "index", "recorder", "menu", "guess", "TabClipper", "body", "ball", "ws"]
}
